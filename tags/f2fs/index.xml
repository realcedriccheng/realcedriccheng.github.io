<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>F2FS on The Orange Flavored Whisper</title><link>https://realcedriccheng.github.io/tags/f2fs/</link><description>Recent content in F2FS on The Orange Flavored Whisper</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 08 Dec 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://realcedriccheng.github.io/tags/f2fs/index.xml" rel="self" type="application/rss+xml"/><item><title>F2FS的优点以及与LFS的区别</title><link>https://realcedriccheng.github.io/p/f2fs_lfs/</link><pubDate>Sun, 08 Dec 2024 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/f2fs_lfs/</guid><description>&lt;h2 id="什么是lfs">什么是LFS
&lt;/h2>&lt;p>LFS即日志结构文件系统（log-structured file system）。日志结构文件系统是一种只允许顺序写的文件系统。原始的LFS叫做Sprite(精灵) LFS，是 Sprite 网络操作系统的一部分。&lt;/p>
&lt;h2 id="为什么要将文件系统设计成日志结构的">为什么要将文件系统设计成日志结构的
&lt;/h2>&lt;p>LFS的基本假设是IO 瓶颈在写不在读，因为文件在内存有 cache。&lt;/p>
&lt;p>在写入许多小文件时，将许多同步小写转化成一个大的异步写，从而充分利用磁盘带宽。&lt;/p>
&lt;h2 id="日志结构文件系统和日志型文件系统的区别">日志结构文件系统和日志型文件系统的区别
&lt;/h2>&lt;p>日志型文件系统的 log 仅用作临时存储，在崩溃恢复时使用&lt;/p>
&lt;p>日志结构文件系统将 log 作为主要存储区域，并且磁盘上没有其他的结构（这是原始的 LFS）&lt;/p>
&lt;h2 id="怎样实现lfs">怎样实现LFS
&lt;/h2>&lt;h3 id="仅允许顺序写">仅允许顺序写
&lt;/h3>&lt;p>将文件的改动暂存在 file cache 中，并向磁盘一次将所有的数据顺序写到 log 中（包括数据及元数据）。&lt;/p>
&lt;h3 id="支持随机读">支持随机读
&lt;/h3>&lt;p>每一个文件有对应的 inode，inode 包含访问控制等信息以及指向起始 10 个数据块地址的指针、指向其他数据块地址或者其他 indirect block 的 indirect block。&lt;/p>
&lt;h3 id="空闲空间的管理">空闲空间的管理
&lt;/h3>&lt;ul>
&lt;li>将磁盘划分为一系列固定大小的 segment（512KB，这样使得找到一个 segment 不会比遍历 segment 本身更慢）&lt;/li>
&lt;li>segment 中的有效数据搬移之后才能重用（垃圾回收）&lt;/li>
&lt;li>有些 segment 中存放寿命较长的数据，可以在分配空间的时候跳过，以免重复搬移（冷热数据分离）&lt;/li>
&lt;/ul>
&lt;h3 id="垃圾回收">垃圾回收
&lt;/h3>&lt;p>将一些 segment 读入内存，识别有效数据，并将有效数据写回干净的 segment&lt;/p>
&lt;p>每个 segment 都有一个或多个 segment summary block，包含一个块属于哪个文件（ino）以及 index（为了 GC 修改映射关系）。用于识别有效数据（trivial： 检查文件 index 处的指针是否指向这个块；sprite lfs：检查版本号）&lt;/p>
&lt;p>在Sprite LFS中写几十个 seg 就清理。&lt;/p>
&lt;h3 id="崩溃一致性">崩溃一致性
&lt;/h3>&lt;p>LFS 采用 checkpoints 和前滚恢复保证崩溃一致性。&lt;/p>
&lt;p>崩溃恢复快，只需扫描最近的 log。&lt;/p>
&lt;p>（待续）&lt;/p>
&lt;h2 id="lfs的问题">LFS的问题
&lt;/h2>&lt;h3 id="wandering-tree-问题滚雪球式更新">wandering tree 问题/滚雪球式更新
&lt;/h3>&lt;p>在 LFS 中，修改一个文件的数据块会导致其位置发生变化，即追加到尾部。这就导致指向该数据块的直接指针需要修改。然而修改其指针会导致指向直接指针的间接指针也需要修改。因此 inode、inode map 和 cp block 都需要递归修改。&lt;/p>
&lt;h3 id="清理开销">清理开销
&lt;/h3>&lt;p>由于 LFS 的顺序写和异地更新特性，更新一个块后原来的块就作废了。这样导致盘上存在大量作废的垃圾块，需要做垃圾回收。垃圾回收的开销需要对用户隐藏，并且移动的数据量应该尽可能少，移动应该尽可能快。&lt;/p>
&lt;p>LFS 中的垃圾回收严重影响性能，缩短 SSD 寿命（写放大）&lt;/p>
&lt;p>&lt;em>SFS: Random write considered harmful in solid state drives FAST 12&lt;/em>&lt;/p>
&lt;h2 id="f2fs的优点以及与lfs的区别">F2FS的优点以及与LFS的区别
&lt;/h2>&lt;h3 id="日志结构文件系统的固有优点">日志结构文件系统的固有优点
&lt;/h3>&lt;p>f2fs 采用顺序写，因此具有适合闪存介质特性的特点。&lt;/p>
&lt;ul>
&lt;li>闪存介质只支持异地更新，不支持就地更新。&lt;/li>
&lt;li>随机写导致闪存内部碎片化。&lt;/li>
&lt;/ul>
&lt;h3 id="解决了wandering-tree问题">解决了wandering tree问题
&lt;/h3>&lt;p>在 LFS 中，修改一个文件的数据块会导致其位置发生变化，即追加到尾部。这就导致指向该数据块的直接指针需要修改。然而修改其指针会导致指向直接指针的间接指针也需要修改。因此 inode、inode map 和 cp block 都需要递归修改。&lt;/p>
&lt;p>在F2FS中，增加了一个随机写的元数据区域。其中，引入 NAT 表记录 node 位置，切断递归更新。&lt;/p>
&lt;ul>
&lt;li>更新文件数据块-&amp;gt;更新 dnode 内容-&amp;gt;更新 NAT 表中 dnode位置-&amp;gt;结束&lt;/li>
&lt;/ul>
&lt;h3 id="解决了lfs的高gc开销问题">解决了LFS的高GC开销问题
&lt;/h3>&lt;h4 id="采用multi-head-logging实现冷热数据分离">采用multi-head logging实现冷热数据分离
&lt;/h4>&lt;p>F2FS中存在6个log，即{Hot, Warm, Cold}* {Node, Data}。&lt;/p>
&lt;p>LFS中只有一个全局的大log，而F2FS中通过将空间划分为6个log实现了冷热数据分离。冷热数据分离就是为了减少GC开销。&lt;/p>
&lt;h4 id="自适应切换写入方式">自适应切换写入方式
&lt;/h4>&lt;p>当空间利用率不高时，F2FS采用append方式顺序写入。&lt;/p>
&lt;p>当空间利用率太高时，为了找到干净的segment需要频繁GC。这时F2FS可以采用threaded logging方式写入数据。&lt;/p>
&lt;p>threaded logging是指直接在脏segment里面利用内碎片接着写，不用提前清理。&lt;/p>
&lt;h4 id="gc单位与ftl操作单元对齐">GC单位与FTL操作单元对齐
&lt;/h4>&lt;p>采用Section作为GC单位，与FTL操作单元对齐。&lt;/p>
&lt;p>在ZNS SSD上，Section就和Zone对齐，因此只需要做一次GC。&lt;/p>
&lt;h2 id="未列出的参考资料">未列出的参考资料
&lt;/h2>&lt;p>&lt;a class="link" href="https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener"
>https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/总体结构.md&lt;/a>&lt;/p>
&lt;p>The design and implementation of a log-structured file system&lt;/p></description></item><item><title>Linux 3.8中的F2FS崩溃恢复</title><link>https://realcedriccheng.github.io/p/crash_recovery_f2fs_linux3.8/</link><pubDate>Sun, 08 Dec 2024 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/crash_recovery_f2fs_linux3.8/</guid><description>&lt;p>崩溃恢复包括正常状态下的fsync和上电后的前滚恢复。因3.8版本中的f2fs是初版，较为简单。因此本文分析Linux 3.8版本中的崩溃恢复流程，借以了解崩溃恢复。&lt;/p>
&lt;h2 id="fsync分析">fsync分析
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">flowchart LR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A[f2fs_sync_file]--&amp;gt;B[filemap_write_and_wait_range]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A--&amp;gt;C[f2fs_balance_fs]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A--need_cp--&amp;gt;D[f2fs_sync_fs]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A--!need_cp--&amp;gt;E[sync_node_pages]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A--!need_cp--&amp;gt;F[f2fs_write_inode]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A--!need_cp--&amp;gt;G[filemap_fdatawait_range]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>fsync函数的原型为int f2fs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)，其作用是将file指向的文件中，偏移量从start到end的部分刷写下盘。&lt;/p>
&lt;h3 id="刷写数据部分">刷写数据部分
&lt;/h3>&lt;p>文件系统通过wbc结构体来控制写回过程的行为。这里设置wbc为&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">writeback_control&lt;/span> &lt;span class="n">wbc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">sync_mode&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">WB_SYNC_ALL&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 同步写回，等待所有页面的写回完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="n">nr_to_write&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">LONG_MAX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 暂时不设置在本次操作中最多写回的页面数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="n">for_reclaim&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1">// 表示当前的写回操作不是为了回收页面触发的，而是由于fsync
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 在内存不足的情况下，内核通过回收页面来释放内存，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 在回收页面之前要先将页面写回存储设备
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果文件系统在挂载时设置为只读的，即sb中设置了MS_RDONLY标志位，则直接返回0，因为无法在只读的文件系统中写回。&lt;/p>
&lt;p>接下来通过filemap_write_and_wait_range函数写回start到end的数据。函数原型是&lt;code>int filemap_write_and_wait_range(struct address_space * mapping, loff_t lstart, loff_t lend);&lt;/code>&lt;/p>
&lt;p>该函数是一个同步操作，将mapping中lstart至lend中的脏页刷盘，等待写回完成后再返回。也即将文件指定范围的内容持久化。mapping是文件在内存中的地址空间。&lt;/p>
&lt;p>在写回数据之后，调用f2fs_balance_fs检测sbi以确定是否还有足够的空闲section，如果没有就做一次主动GC。实际上这个函数经常在和写入相关的操作中被调用，每次写入后都要检查一下。&lt;/p>
&lt;p>fsync和fdatasync都通过f2fs_sync_file函数执行。如果当前执行的时fdatasync，则到这里就已经结束返回了。下面是fsync中针对元数据的操作。&lt;/p>
&lt;h3 id="刷写元数据部分">刷写元数据部分
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">F2FS_I&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">data_version&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">cur_version&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_state&lt;/span> &lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">I_DIRTY&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">goto&lt;/span> &lt;span class="n">out&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">F2FS_I&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">data_version&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>检查该文件的data_version是否等于当前CP的cur_version。如果不等于，说明该文件是上一次CP之前就存在的，盘上有它的inode结构和目录结构。如果该文件的I_DIRTY标志位没有置位，则该文件没有发生任何变化。因此不需要做任何操作。&lt;/p>
&lt;p>问题：如果该文件没有发生任何变化，为何不在最开始就做这个判断？并且5.15中没有做这个判断。&lt;/p>
&lt;p>问题：为何需要F2FS_I(inode)-&amp;gt;data_version&amp;ndash;;？&lt;/p>
&lt;p>接下来判断是否需要CP。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">S_ISREG&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_mode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">i_nlink&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">need_cp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">is_inode_flag_set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nf">F2FS_I&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">inode&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">FI_NEED_CP&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">need_cp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="nf">space_for_roll_forward&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sbi&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">need_cp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nf">need_to_sync_dir&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sbi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">inode&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">need_cp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>第一个if：如果不是普通文件或硬链接计数不为1（文件已被删除或有多个硬链接） 问题：为什么有多个硬链接也要CP？&lt;/li>
&lt;li>第二个if：如果具有需要CP的标记&lt;/li>
&lt;li>第三个if：如果没有足够的空间做前滚，也就是距离上一次CP太远了，需要前滚的数据太多了&lt;/li>
&lt;li>第四个if：如果该文件所在目录文件不在上一个CP点中&lt;/li>
&lt;/ul>
&lt;p>如果需要CP则做CP，否则只落盘元数据，包括dnode和inode。&lt;/p>
&lt;p>接下来使用sync_node_pages落盘该文件的inode和脏dnode。f2fs在做fsync的时候先将所有修改过的数据落盘（即上面的filemap_write_and_wait_range），再将其node元数据落盘（即这里的sync_node_pages）。必须保证这个顺序，否则如果fsync没有做完就断电了，上电后根据node恢复数据的时候dnode指向的数据是空的或错的。&lt;/p>
&lt;p>&lt;em>这里需要对照具体的代码看。&lt;/em>&lt;/p>
&lt;p>在sync_node_pages中，用到的地址空间是sbi→node_inode→i_mapping。其中node_inode是一个特殊的文件，用于管理内存中的node。&lt;/p>
&lt;p>扫描node_inode中的所有node，pagevec_lookup_tag用于查找其中具有PAGECACHE_TAG_DIRTY标记的脏node，并将其放入pvec中。&lt;/p>
&lt;p>扫描pvec。当扫描到的node属于该文件时，为其打上fsync标记。如果扫描到的是inode，还要打dentry标记。dentry标记是指如果某个文件没有持久化过，则盘上的目录文件没有相应的结构，也没办法寻找到这个文件。&lt;em>&lt;strong>因此需要为其单独创建一个inode结构&lt;/strong>&lt;/em>，并在目录中加入这个文件。（在5.15版本中，当文件没有CP过并且也没有做过fsync才打dentry标记，第二次fsync不打）&lt;/p>
&lt;p>打完标记后，通过f2fs_write_node_page和f2fs_submit_bio将node page刷写下盘。这里前者应当只是构造合并了bio，放在sbi-&amp;gt;bio[NODE]还没有提交。后者提交bio。&lt;/p>
&lt;p>如果sync_node_pages没有写下任何node page，说明该文件的node都不脏。这种情况应当是truncate过，也就是删除了文件的一部分，因此没有脏node。这种情况下仅通过f2fs_write_inode刷写其inode。&lt;/p>
&lt;p>问题：truncate后不应该做CP吗？可能这个早期版本没有考虑周全。&lt;/p>
&lt;p>最后调用filemap_fdatawait_range确保所有的脏node都已经刷盘，这是一个同步等待操作。&lt;/p>
&lt;h1 id="前滚回复分析">前滚回复分析
&lt;/h1>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">flowchart
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> A[f2fs_fill_super]--&amp;gt;B[recover_fsync_data]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> B--&amp;gt;C[find_fsync_dnodes]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> B--&amp;gt;D[recover_data]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> C--&amp;gt;E[recover_inode]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> E--&amp;gt;F[recover_dentry]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> D--&amp;gt;G[do_recover_data]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在挂载文件系统后，f2fs_fill_super函数调用recover_fsync_data函数做前滚回复。前滚恢复的过程包括两次扫描，即find_fsync_dnodes和recover_data。&lt;/p>
&lt;p>第一次扫描find_fsync_dnodes的作用是通过扫描恢复区域的node page，确定有哪些文件是需要恢复的，并将其加入inode_list链表中。第二次扫描recover_data的作用是通过扫描恢复区域的node page，利用这些node page的内容重建文件。&lt;/p>
&lt;p>&lt;em>&lt;strong>注意：&lt;/strong>&lt;/em>&lt;/p>
&lt;ul>
&lt;li>两次扫描的范围相同。&lt;/li>
&lt;li>扫描的对象是普通文件的dnode，也就是直接存储文件数据地址的node。inode中也存储了923个数据地址，也算作dnode。这些node在warm node log中。&lt;/li>
&lt;li>恢复数据实际上是修改文件中dnode指向数据的地址。因为数据已经通过fsync落盘了，本身是不需要恢复的。但是dnode的指向关系还没有更新，因此才需要前滚回复来完成这一流程。&lt;/li>
&lt;li>在前滚回复开始之前，文件系统的状态是回滚到上一次CP点。所以上一次CP点没有的文件，直接读是读不到的。因此才需要对具有dentry标记的文件单独从头恢复。
&lt;ul>
&lt;li>如果P是一个 inode，并具有 dentry 标记DENT_BIT_SHIFT，就为P对应的 inode 打FI_INC_LINK 标记。&lt;/li>
&lt;li>如果某个 dnode 在 footer 中没有 checkpointed 标记，则要打上 dentry 标记。意思是这个文件没有持久化过，因此盘上的目录文件没有相应的结构，也没办法寻找到这个文件。&lt;em>&lt;strong>因此需要为其单独创建一个inode结构&lt;/strong>&lt;/em>，并在目录中加入这个文件。&lt;/li>
&lt;li>既然这个表项已经存在于inode_list链表中了，那么说明P的inode结构已经创建出来了，增加引用计数是恢复目录结构中目录对该inode的引用。
问题：我感觉FI_INC_LINK标记没有用到，因为recover_dentry中增加计数的时候并没有根据这个标记判断。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="第一次扫描-find_fsync_dnodes">第一次扫描 find_fsync_dnodes
&lt;/h2>&lt;p>第一次扫描的作用是找到需要恢复的文件，并将其inode插入记录链表inode_list中。注意，inode_list并非直接存储inode结构，而是存储fsync_inode_entry结构。&lt;/p>
&lt;h3 id="扫描范围">扫描范围
&lt;/h3>&lt;p>扫描的范围是上一次CP后写入的第一个node到最后一个有记录的node。其中，起始地址这样确定：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">curseg&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">CURSEG_I&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sbi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">CURSEG_WARM_NODE&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">blkaddr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nf">START_BLOCK&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sbi&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">curseg&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">segno&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">curseg&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">next_blkoff&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>需要扫描的node都在warm node log中，通过CURSEG_I(sbi, CURSEG_WARM_NODE)找到上一次CP记录的warm node log对应的segment（这个信息存储在sbi中，只有CP的时候才落盘sbi）。并且找到下一个segment的起始地址。&lt;/p>
&lt;p>node的footer中记录了下一个node的地址，通过blkaddr = next_blkaddr_of_node(page)可以获得。扫描终止条件是（1）下一个地址不是合法地址、取不出页面；（2）取得的 node 是上一次 CP 之前的；（3）函数返回错误、资源分配错误，可能因为盘上数据已损坏。&lt;/p>
&lt;p>在扫描过程中，仅处理通过fsync落盘、具有fsync标记（FSYNC_BIT_SHIFT）的node page，通过is_fsync_dnode(page)判断。&lt;/p>
&lt;h3 id="扫描过程">扫描过程
&lt;/h3>&lt;p>设当前正在扫描的node page为P，则&lt;/p>
&lt;ol>
&lt;li>首先检查P所属的inode是否已经插入inode_list。
&lt;ol>
&lt;li>
&lt;p>如果已有，则&lt;/p>
&lt;ol>
&lt;li>
&lt;p>将entry的blkaddr字段更新成P。这个地址指的是该 entry 对应的文件，在盘上扫描到的最后一个 node 的地址。也即是恢复数据的时候，处理完这个 node，就代表该文件恢复完毕了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果P是一个 inode，并具有 dentry 标记DENT_BIT_SHIFT，就为P对应的 inode 打FI_INC_LINK 标记。&lt;/p>
&lt;ol>
&lt;li>如果某个 dnode 在 footer 中没有 checkpointed 标记，则要打上 dentry 标记。意思是这个文件没有持久化过，因此盘上的目录文件没有相应的结构，也没办法寻找到这个文件。&lt;em>&lt;strong>因此需要为其单独创建一个inode结构&lt;/strong>&lt;/em>，并在目录中加入这个文件。&lt;/li>
&lt;li>既然这个表项已经存在于inode_list链表中了，那么说明P的inode结构已经创建出来了，增加引用计数是恢复目录结构中目录对该inode的引用。&lt;/li>
&lt;/ol>
&lt;p>问题：我感觉FI_INC_LINK标记没有用到，因为recover_dentry中增加计数的时候并没有根据这个标记判断。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>如果没有，则&lt;/p>
&lt;ol>
&lt;li>如果P是一个 inode，并具有 dentry 标记DENT_BIT_SHIFT，就根据P创建它的inode结构。&lt;/li>
&lt;li>根据P的inode创建一个entry表项，并插入到inode_list链表中。&lt;/li>
&lt;li>将entry的blkaddr字段设置成P。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>如果P是一个inode，则根据P恢复文件系统中对应inode的结构。其中如果P是刚创建出来的，则还需要通过recover_dentry恢复目录结构。
&lt;ol>
&lt;li>recover_inode 函数中恢复一些时间戳、文件大小和 mode。然后调用 recover_dentry 恢复目录结构。&lt;/li>
&lt;li>只有具有 DENT_BIT_SHIFT 标记的 page，也就是之前过的没有持久化过的文件才需要单独在这里恢复目录结构。&lt;/li>
&lt;li>得到其目录文件的 inode，并建立相应的目录结构 dent。&lt;/li>
&lt;li>如果在目录文件中存在本文件名字的目录项则没事，如果不存在，就将 dent 加入目录文件中（f2fs_add_link）。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="第二次扫描-recover_data">第二次扫描 recover_data
&lt;/h2>&lt;h3 id="扫描范围-1">扫描范围
&lt;/h3>&lt;p>第二次扫描的范围和第一次相同。&lt;/p>
&lt;h3 id="扫描过程-1">扫描过程
&lt;/h3>&lt;p>将当前扫描到的 node page （设为P）读上来，检查是否属于第一轮扫描中加入到 inode_list 链表中的文件。如果是，则通过 do_recover_data 利用P的内容恢复数据。&lt;/p>
&lt;ol>
&lt;li>获取P中包含数据的范围&lt;/li>
&lt;/ol>
&lt;p>首先通过P中的标志位获知P是第几个dnode，从而计算其中存储数据的index范围。&lt;/p>
&lt;p>ofs_of_node 函数通过获取P的 node_ofs 获取该 dnode 在整个文件中的偏移量。这个 node_ofs 保存在中 footer.flag 的高位中（低 3 位保存的是 COLD_BIT、FSYNC_BIT 和 DENT_BIT），右移 OFFSET_BIT_SHIFT 位即可得到 node_ofs。&lt;/p>
&lt;p>node_ofs 指的是 dnode 在整个文件中的偏移量，即第几个 dnode。从而可以得到该 dnode 指向的数据在整个文件中的 index。&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/geshifei/article/details/126745306" target="_blank" rel="noopener"
>F2FS数据块寻址（linux5.18.11）_f2fs node和data-CSDN博客&lt;/a>&lt;/p>
&lt;p>总之，这里获得了P中保存的数据之首尾 index，分别叫 start 和 end。&lt;/p>
&lt;ol start="2">
&lt;li>根据P恢复文件中对应index的数据&lt;/li>
&lt;/ol>
&lt;p>注意恢复数据是指将上一给CP点中该文件指向的旧的数据地址更新为P中包含的地址，还涉及涉及对 summary、extent cache 和 SIT 等的修改。&lt;/p>
&lt;p>接下来从 start 开始一直恢复到 end。在一个 for 循环内，逐个恢复每个 index 对应的数据块。src 表示盘上读出的数据块地址、dest 表示扫描到的 page 里得到的数据块地址。&lt;/p>
&lt;p>如果 src== dest，表示盘上读出的地址就是最新的地址，没必要恢复。如果 dest== NEW_ADDR 或 NULL_ADDR，表示 page 上扫描到的这个数据块有问题，没有办法恢复。&lt;/p>
&lt;p>恢复完数据后，如果P和刚恢复完的都是inode，就刷下去。&lt;/p>
&lt;p>用P恢复读上来的 node page自身结构，如footer等。&lt;/p>
&lt;ol start="3">
&lt;li>回到 recover_data&lt;/li>
&lt;/ol>
&lt;p>在用 do_recover_data 恢复数据后，如果P就是 inode list entry 记录的最后一个 blkaddr，则表示该 inode 对应的文件已经恢复完成，删除这个表项。&lt;/p>
&lt;p>找到下一个 node 的地址，继续下一轮恢复。&lt;/p>
&lt;h2 id="收尾工作">收尾工作
&lt;/h2>&lt;p>在恢复完 inode_list 中的所有表项以后，就删除临时创建的所有数据结构、收回分配的所有空间。&lt;/p>
&lt;p>最后再做一次 CP。&lt;/p>
&lt;h1 id="注意">注意
&lt;/h1>&lt;ol>
&lt;li>要使用一个 page 的内容，先要通过 page_address 取得其内容在内存中的虚拟地址，然后通过结构体访问。&lt;/li>
&lt;li>盘上的 node page 实际是以 f2fs_node 的形式存放的。并不是 vfs 的 inode 结构体。&lt;/li>
&lt;/ol>
&lt;h1 id="文中未列出的参考资料">文中未列出的参考资料
&lt;/h1>&lt;p>（&lt;a class="link" href="https://blog.csdn.net/luckyapple1028/article/details/61413724%EF%BC%89" target="_blank" rel="noopener"
>https://blog.csdn.net/luckyapple1028/article/details/61413724）&lt;/a>&lt;/p></description></item><item><title>使用F2FS文件系统</title><link>https://realcedriccheng.github.io/p/use_f2fs_filesystem/</link><pubDate>Sun, 08 Dec 2024 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/use_f2fs_filesystem/</guid><description>&lt;h2 id="挂载f2fs">挂载F2FS
&lt;/h2>&lt;p>文件系统可以挂载在盘上，也可以挂载在文件上。有时候为了实验会在文件上挂载一个文件系统。&lt;/p>
&lt;h3 id="创建一个100m的空文件">创建一个100M的空文件：
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">dd&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="o">=/&lt;/span>&lt;span class="n">dev&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">zero&lt;/span> &lt;span class="n">of&lt;/span>&lt;span class="o">=/&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">local&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">f2fs_100MB&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">bin&lt;/span> &lt;span class="n">bs&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="n">M&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">100&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中，if是指从zero设备中取数据，取出的都是0。of是指将0写入后面路径的文件中，大小是100个1M。&lt;/p>
&lt;h3 id="格式化文件系统">格式化文件系统
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">make_f2fs&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">f&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">d1&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">g&lt;/span> &lt;span class="n">android&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">O&lt;/span> &lt;span class="n">compression&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">O&lt;/span> &lt;span class="n">extra_attr&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">local&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">f2fs_100MB&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">bin&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>(参数待查)&lt;/p>
&lt;h3 id="获取文件系统信息">获取文件系统信息
&lt;/h3>&lt;p>使用dump.f2fs命令获取文件系统的信息&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">dump&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">f2fs&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">d&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="n">f2fs_100MB&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">bin&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>(参数待查)&lt;/p>
&lt;h2 id="未列出的参考资料">未列出的参考资料
&lt;/h2>&lt;p>&lt;a class="link" href="https://mp.weixin.qq.com/s/FbGyxclb1Gesk8_apEexPQ" target="_blank" rel="noopener"
>https://mp.weixin.qq.com/s/FbGyxclb1Gesk8_apEexPQ&lt;/a>&lt;/p></description></item><item><title>F2FS 文件系统相关概念</title><link>https://realcedriccheng.github.io/p/concepts_on_f2fs_filesystem/</link><pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/concepts_on_f2fs_filesystem/</guid><description>&lt;blockquote>
&lt;p>可参看https://github.com/RiweiPan/F2FS-NOTES/&lt;/p>&lt;/blockquote>
&lt;h2 id="什么是f2fs">什么是F2FS
&lt;/h2>&lt;p>F2FS, Flash Friendly File System，是一种采用日志结构，适合闪存特性的文件系统。&lt;/p>
&lt;p>F2FS是从原始LFS的基础上发展来的。详见：[[原始LFS设计]]&lt;/p>
&lt;p>F2FS 的设计主要解决了原始 LFS 中的滚雪球式更新元数据（wandering tree）问题。&lt;/p>
&lt;h2 id="f2fs的优点">F2FS的优点
&lt;/h2>&lt;p>详见：（本站）F2FS的优点以及与LFS的区别&lt;/p>
&lt;h2 id="f2fs文件系统设计">F2FS文件系统设计
&lt;/h2>&lt;p>F2FS在盘上组织为两个区域：随机写区域和顺序写区域。&lt;/p>
&lt;p>因此在ZNS SSD上使用F2FS时，还需挂载另一块用于存放元数据的可随机写的盘。&lt;/p>
&lt;p>&lt;img src="https://realcedriccheng.github.io/p/concepts_on_f2fs_filesystem/a74771c951a07366914be4397c464189_MD5.jpeg"
width="777"
height="166"
srcset="https://realcedriccheng.github.io/p/concepts_on_f2fs_filesystem/a74771c951a07366914be4397c464189_MD5_hu_5b46c2407e8102ae.jpeg 480w, https://realcedriccheng.github.io/p/concepts_on_f2fs_filesystem/a74771c951a07366914be4397c464189_MD5_hu_31893e4e74bfe147.jpeg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="468"
data-flex-basis="1123px"
>&lt;/p>
&lt;p>随机写区域存放的是文件系统的元数据，包括超级块、CP、SIT、NAT和SSA。&lt;/p>
&lt;p>顺序写区域，也叫Main Area。存放的是Data Page和Node Page。顺序写区域还分为冷热分离的6个log。&lt;/p>
&lt;h2 id="f2fs文件系统的元数据">F2FS文件系统的元数据
&lt;/h2>&lt;p>F2FS中的元数据有超级块、CP、SIT、NAT、SSA。这些元数据放在随机写区域。&lt;/p>
&lt;p>这里说的元数据是整个F2FS文件系统的元数据，而不是data的元数据（各种node）。&lt;/p>
&lt;h3 id="超级块">超级块
&lt;/h3>&lt;p>每个文件系统都有自己的超级块，超级块中存放文件系统整体的关键元数据。超级块（Superblock）存放在F2FS文件系统的起始位置，这样挂载后不用寻址就能直接读到超级块。&lt;/p>
&lt;p>超级块区域包含两个struct f2fs_super_block，互为备份。超级块区域的大小为2M，其中前1K留空，每个超级块占4K，后面留空。&lt;/p>
&lt;p>&lt;img src="https://realcedriccheng.github.io/p/concepts_on_f2fs_filesystem/85c11a4687276d9ec23684b7735f7321_MD5.jpeg"
width="385"
height="553"
srcset="https://realcedriccheng.github.io/p/concepts_on_f2fs_filesystem/85c11a4687276d9ec23684b7735f7321_MD5_hu_34f0846c927f893d.jpeg 480w, https://realcedriccheng.github.io/p/concepts_on_f2fs_filesystem/85c11a4687276d9ec23684b7735f7321_MD5_hu_80549a13a4311011.jpeg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="69"
data-flex-basis="167px"
>&lt;/p>
&lt;p>文件系统相关的数据结构通常都有三个：盘上的、内存中文件系统专属的和内存中vfs使用的。&lt;/p>
&lt;h4 id="盘上数据结构struct-f2fs_super_block">盘上数据结构struct f2fs_super_block
&lt;/h4>&lt;p>f2fs_super_block中的主要内容有：&lt;/p>
&lt;ul>
&lt;li>zone、section和segment的数量对应关系&lt;/li>
&lt;li>section、segment、block数量&lt;/li>
&lt;li>元数据区各个部分、主区域segment数量&lt;/li>
&lt;li>元数据区各个部分、主区域起始地址&lt;/li>
&lt;li>特殊文件的inode（见下文）&lt;/li>
&lt;li>用于辨识冷数据的后缀表&lt;/li>
&lt;/ul>
&lt;p>详见：&lt;a class="link" href="https://mp.weixin.qq.com/s/FbGyxclb1Gesk8_apEexPQ" target="_blank" rel="noopener"
>https://mp.weixin.qq.com/s/FbGyxclb1Gesk8_apEexPQ&lt;/a>&lt;/p>
&lt;h4 id="内存管理结构f2fs_sb_info">内存管理结构f2fs_sb_info
&lt;/h4>&lt;p>f2fs_sb_info是内存中用于管理超级块的结构。&lt;/p>
&lt;p>在挂载文件系统时，通过init_sb_info将f2fs_super_block中的数据填入f2fs_sb_info中。&lt;/p>
&lt;p>包含vfs superblock指针、f2fs_super_block指针以及锁、SIT、NAT对应的内存管理结构等。&lt;/p>
&lt;h4 id="vfs-superblock结构">vfs superblock结构
&lt;/h4>&lt;p>略&lt;/p>
&lt;h3 id="cp">CP
&lt;/h3>&lt;p>Checkpoint维护了f2fs的数据一致性，例如segment、node、active segment的状态等。&lt;/p>
&lt;p>F2FS在满足一定的条件的情况下，会将当前系统的分配状态写入到Checkpoint中，万一系统出现突然宕机，可以从Checkpoint中恢复到上次回写时的状态。&lt;/p>
&lt;p>F2FS维护了两个Checkpoint结构，其中一个是当前正在使用的Checkpoint。另外一个上次回写的稳定的cp。&lt;/p>
&lt;p>如果系统出现了宕机，就恢复到上次的稳定cp中。&lt;/p>
&lt;h4 id="cp的盘上结构">CP的盘上结构
&lt;/h4>&lt;p>CP占用2个segment大小（4M）。&lt;/p>
&lt;p>有资料说CP区域就是两个struct f2fs_checkpoint。但是还有资料说还包含orphan node和active segments。&lt;/p>
&lt;p>暂且认为盘上的cp区域由两套f2fs_checkpoint+orphan node+active segment组成。&lt;/p>
&lt;p>F2FS使用数据结构&lt;code>f2fs_checkpoint&lt;/code>表示Checkpoint结构，它保存在磁盘中&lt;code>f2fs_super_block&lt;/code>之后区域中。&lt;/p>
&lt;p>详见 &lt;a class="link" href="https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Checkpoint%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener"
>https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Checkpoint%E7%BB%93%E6%9E%84.md&lt;/a>&lt;/p>
&lt;p>CP中存的是做CP时候的segment journal等，在恢复的时候会恢复到CP时的curseg状态。为了减少写盘次数，f2fs不会每次分配seg、node的时候就去写NAT、SSA等区域，而是放在journal保存在CP结构中。只有这个seg写完的时候才去更新一下。&lt;/p>
&lt;h3 id="sit">SIT
&lt;/h3>&lt;p>Segment Info Table 占据大小由Main Area中Segment数量决定。主要用于记录Main Area中Segment的分配信息，例如哪些Segment可用，Segment最后修改时间等信息。&lt;/p>
&lt;p>SIT的作用是维护每一个segment的block的使用状态以及有效无效状态，目的是便于分配block以及垃圾回收。&lt;/p>
&lt;p>详见：&lt;a class="link" href="https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Segment%20Infomation%20Table%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener"
>https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Segment%20Infomation%20Table%E7%BB%93%E6%9E%84.md&lt;/a>&lt;/p>
&lt;h3 id="nat">NAT
&lt;/h3>&lt;p>用于记录Node的地址，这是解决wandering tree的关键设计。&lt;/p>
&lt;p>详见：&lt;a class="link" href="https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Node%20Address%20Table%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener"
>https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Node%20Address%20Table%E7%BB%93%E6%9E%84.md&lt;/a>&lt;/p>
&lt;h3 id="ssa">SSA
&lt;/h3>&lt;p>用于反向索引。通过SIT和NAT可以正向索引到主区域中的block。在这里可以通过block找到所属的node。也就是可以实现通过物理地址找到逻辑地址。GC的时候很有用。&lt;/p>
&lt;p>同时它也具有通过journal缓存sit或者nat的操作用于数据恢复的作用。&lt;/p>
&lt;p>详见：&lt;a class="link" href="https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Segment%20Summary%20Area%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener"
>https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Segment%20Summary%20Area%E7%BB%93%E6%9E%84.md&lt;/a>&lt;/p>
&lt;h2 id="f2fs中的journal">F2FS中的journal
&lt;/h2>&lt;p>在f2fs读写文件的时候，每修改一个块，都会改动f2fs_node的地址映射和NAT、SIT信息。为了避免频繁刷盘，f2fs将这种小变化写到journal里，在CP的时候再写入磁盘。&lt;/p>
&lt;p>journal相关的数据结构有&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_journal&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">union&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le16&lt;/span> &lt;span class="n">n_nats&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* 这个journal里面包含多少个nat_journal对象 */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le16&lt;/span> &lt;span class="n">n_sits&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* 这个journal里面包含多少个sit_journal对象 */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/* spare area is used by NAT or SIT journals or extra info */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">union&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">nat_journal&lt;/span> &lt;span class="n">nat_j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">sit_journal&lt;/span> &lt;span class="n">sit_j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_extra_info&lt;/span> &lt;span class="n">info&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这表示一个f2fs_journal要么保存nat，要么保存sit。&lt;/p>
&lt;p>nat journal:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">nat_journal&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">nat_journal_entry&lt;/span> &lt;span class="n">entries&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NAT_JOURNAL_ENTRIES&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__u8&lt;/span> &lt;span class="n">reserved&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NAT_JOURNAL_RESERVED&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">nat_journal_entry&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">nid&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_nat_entry&lt;/span> &lt;span class="n">ne&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_nat_entry&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__u8&lt;/span> &lt;span class="n">version&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* latest version of cached nat entry */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">ino&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* inode number */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">block_addr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* block address */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>sit journal&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">sit_journal&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">sit_journal_entry&lt;/span> &lt;span class="n">entries&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">SIT_JOURNAL_ENTRIES&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__u8&lt;/span> &lt;span class="n">reserved&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">SIT_JOURNAL_RESERVED&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">sit_journal_entry&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">segno&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_sit_entry&lt;/span> &lt;span class="n">se&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_sit_entry&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le16&lt;/span> &lt;span class="n">vblocks&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* reference above */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__u8&lt;/span> &lt;span class="n">valid_map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">SIT_VBLOCK_MAP_SIZE&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="cm">/* SIT_VBLOCK_MAP_SIZE = 64，64 * 8 = 512 可以表示每一个块的valid状态 */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le64&lt;/span> &lt;span class="n">mtime&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* segment age for cleaning */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在f2fs_get_node_info中，首先在journal中找到地址。如果没找到，再去读盘上的f2fs_nat_block。&lt;/p>
&lt;p>在cp的时候，将journal的信息写盘。&lt;/p>
&lt;ol>
&lt;li>&lt;code>f2fs_flush_nat_entries&lt;/code> 和 &lt;code>f2fs_flush_sit_entries&lt;/code> 函数将entry都写入到 &lt;code>curseg_info-&amp;gt;f2fs_summary-&amp;gt;journal&lt;/code> 的变量中。&lt;/li>
&lt;li>&lt;code>do_checkpoint函数&lt;/code> 读取 &lt;code>curseg_info-&amp;gt;f2fs_summary&lt;/code>，然后通过函数&lt;code>f2fs_write_node_summaries&lt;/code>或&lt;code>f2fs_write_data_summaries&lt;/code> 刷写到磁盘中。&lt;/li>
&lt;/ol>
&lt;h2 id="f2fs中文件的组织">F2FS中文件的组织
&lt;/h2>&lt;p>文件分为数据和元数据两部分：数据是指文件保存的内容，元数据是指为了管理和组织数据而附加的结构。&lt;/p>
&lt;p>一般文件采用inode-data模式，即一个inode代表管理一个文件的抓手，通过inode的操作可以访问文件数据。&lt;/p>
&lt;p>F2FS中的inode包括Metadata部分和数据块寻址部分。Metadata部分是用于描述文件的元数据，数据块寻址部分是用来找到文件中给定index的块。&lt;/p>
&lt;h3 id="文件寻址">文件寻址
&lt;/h3>&lt;p>直接记录数据块地址的元数据称为dnode。一个dnode中包含许多index-&amp;gt;数据地址的映射条目。&lt;/p>
&lt;p>dnode数量太多，无法全部放入inode中，因此存在indnode，用来存放index-&amp;gt;dnode的映射条目。&lt;/p>
&lt;p>由于inode自己保存了923个数据块地址，所以inode也可以算作dnode。&lt;/p>
&lt;p>每个node page的大小都是4K。&lt;/p>
&lt;ol>
&lt;li>inode本身保存了923个数据块的地址，称为direct pointer&lt;/li>
&lt;li>&lt;code>f2fs_inode-&amp;gt;i_nid[0~1]&lt;/code> 保存了两个 &lt;code>direct_node&lt;/code> 的地址，这里可以保存 2 x 1018个block的数据&lt;/li>
&lt;li>&lt;code>f2fs_inode-&amp;gt;i_nid[2~3]&lt;/code> 保存了两个&lt;code>indirect_node&lt;/code> 的地址，这两个其中2个&lt;code>indirect_node&lt;/code>保存的是 &lt;code>direct_node&lt;/code> 的nid，因此可以保存 2 x 1018 x 1018个block的数据;&lt;/li>
&lt;li>&lt;code>f2fs_inode-&amp;gt;i_nid[4]&lt;/code> 保存了一个&lt;code>indirect_node&lt;/code> 的地址，这个&lt;code>indirect_node&lt;/code>保存的是 &lt;code>indirect_node&lt;/code> 的nid，因此可以保存 1018 x 1018 x 1018个页的数据&lt;/li>
&lt;/ol>
&lt;p>可以得到如下计算公式: &lt;strong>4KB x (923 + 2 x 1018 + 2 x 1018 x 1018 + 1 x 1018 x 1018 x 1018) = 3.93TB&lt;/strong> 因此F2FS单个文件最多了保存3.93TB数据。&lt;/p>
&lt;h3 id="node-结构">node 结构
&lt;/h3>&lt;p>这里说的是盘上结构。为了方便管理，inode、dnode和indnode都用f2fs_node描述。用footer区分，nid == ino则是inode。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_node&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">union&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_inode&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">direct_node&lt;/span> &lt;span class="n">dn&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">indirect_node&lt;/span> &lt;span class="n">in&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">node_footer&lt;/span> &lt;span class="n">footer&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// footer用于记录node的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">node_footer&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">nid&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* node id */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">ino&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* inode nunmber */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* include cold/fsync/dentry marks and offset */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le64&lt;/span> &lt;span class="n">cp_ver&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* checkpoint version */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">next_blkaddr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* next node page block address */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中，inode的结构为&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">f2fs_inode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">i_addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">DEF_ADDRS_PER_INODE&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// DEF_ADDRS_PER_INODE=923
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">__le32&lt;/span> &lt;span class="n">i_nid&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">DEF_NIDS_PER_INODE&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// DEF_NIDS_PER_INODE=5
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>数组i_addr保存了直接指向的923个地址，下标是数据块的index。&lt;/p>
&lt;p>数组i_nid保存了指向的dnode和indnode。下标已经解释过。&lt;/p>
&lt;p>dnode的结构为&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">direct_node&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">addr&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">ADDRS_PER_BLOCK&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// ADDRS_PER_BLOCK=1018
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>数组addr保存了直接指向的1018个地址，下标是处理后的index。&lt;/p>
&lt;p>indnode的结构为&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="n">indirect_node&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">__le32&lt;/span> &lt;span class="n">nid&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">NIDS_PER_BLOCK&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// NIDS_PER_BLOCK=1018
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span> &lt;span class="n">__packed&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>数组nid保存了指向的dnode的nid，下标是处理后的index。&lt;/p>
&lt;p>注意：指向node的都是nid而不是node的地址，因为node的地址在NAT中。&lt;/p>
&lt;p>假设一个文件的数据块发生修改，只需要将数据块异地更新后的新地址填入dnode中（这也是异地更新），再在NAT中更新dnode的地址（就地更新）。这样就解决了wandering tree问题。&lt;/p>
&lt;h3 id="内联数据">内联数据
&lt;/h3>&lt;p>小于922 * 4=3688B的文件，数据可以直接放在inode中。&lt;/p>
&lt;p>详见：&lt;a class="link" href="https://github.com/RiweiPan/F2FS-NOTES/blob/master/Reading-and-Writing/file_data_structure.md" target="_blank" rel="noopener"
>https://github.com/RiweiPan/F2FS-NOTES/blob/master/Reading-and-Writing/file_data_structure.md&lt;/a>&lt;/p>
&lt;h2 id="f2fs中的特殊文件">F2FS中的特殊文件
&lt;/h2>&lt;p>f2fs中有3个特殊的文件，其inode号分别为1、2、3。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">set_sb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">node_ino&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">set_sb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">meta_ino&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">set_sb&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root_ino&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="node_inode">node_inode
&lt;/h3>&lt;p>盘上除了数据外，还有node。文件系统将node读入内存后，放在node_inode对应的文件中便于管理和访问。&lt;/p>
&lt;p>node_inode文件的data page 里保存了文件系统中读入内存的 node 的数据，顺序更新。根据 nid 可以从 node inode 的 mapping 里获取对应的 page，之后通过 f2fs_get_node_info 从 NAT 获取 nid 对应的 blkaddr，最后提交 io 获取 page。接口为 f2fs_get_node_page。&lt;/p>
&lt;p>在 inode 创建时，通过 f2fs_new_inode_page 创建 node page。另外在保留 data block 时，如果现有 node 空间不足以存放 data block addr，则需要通过 ALLOC_NODE 模式调用 f2fs_get_dnode_of_data，在内部创建 node page。&lt;/p>
&lt;h3 id="meta_inode">meta_inode
&lt;/h3>&lt;p>盘上还有元数据区域，如SSA、NAT等。这些数据在读入内存后，放在meta_inode文件中管理。&lt;/p>
&lt;h3 id="root_inode">root_inode
&lt;/h3>&lt;p>文件系统在挂载之后有一个根目录。root_inode对应的就是根目录的目录文件。&lt;/p>
&lt;h3 id="compress_inode">compress_inode
&lt;/h3>&lt;p>如果开启了压缩功能，还有一个compress_inode，这里略过。&lt;/p>
&lt;p>特殊文件的ino号是从1开始的，因为 nid = 0 被视作未分配，或者无效。参考 __get_node_page。另外在 truncate_dnode 里，nid == 0 即视作已经 truncate。&lt;/p>
&lt;h2 id="ipu-和-opu">IPU 和 OPU
&lt;/h2>&lt;p>ipu，in-place-update 就地更新：在原地更新数据。传统文件系统如 ext4 都采用。&lt;/p>
&lt;p>opu，out-of-place-update 异地更新：将更新后的数据写在新的地址，修改映射到新地址。&lt;/p>
&lt;ol>
&lt;li>分配一个新的物理地址&lt;/li>
&lt;li>将数据写入新的物理地址&lt;/li>
&lt;li>将旧的物理地址无效掉，然后等GC回收&lt;/li>
&lt;li>更新逻辑地址和物理地址的映射关系&lt;/li>
&lt;/ol>
&lt;p>异地更新更适合闪存特性。 OPU 的缺点在于（1）产生无效块，造成 GC 开销；（2）更新元数据的开销；（3）数据碎片化&lt;/p>
&lt;h2 id="参考资料">参考资料
&lt;/h2>&lt;p>&lt;a class="link" href="https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Superblock%E7%BB%93%E6%9E%84.md" target="_blank" rel="noopener"
>https://github.com/RiweiPan/F2FS-NOTES/blob/master/F2FS-Layout/Superblock结构.md&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://mp.weixin.qq.com/s/9bQSO1rAZIAv9-VMXOfaCA" target="_blank" rel="noopener"
>https://mp.weixin.qq.com/s/9bQSO1rAZIAv9-VMXOfaCA&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://mp.weixin.qq.com/s/FbGyxclb1Gesk8_apEexPQ" target="_blank" rel="noopener"
>https://mp.weixin.qq.com/s/FbGyxclb1Gesk8_apEexPQ&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/liuchao719/p/some_special_node_id_in_F2FS.html%EF%BC%89" target="_blank" rel="noopener"
>https://www.cnblogs.com/liuchao719/p/some_special_node_id_in_F2FS.html&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/liuchao719/p/some_special_node_id_in_F2FS.html%EF%BC%89" target="_blank" rel="noopener"
>https://www.cnblogs.com/liuchao719/p/some_special_node_id_in_F2FS.html&lt;/a>&lt;/p></description></item></channel></rss>
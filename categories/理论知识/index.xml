<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>理论知识 on The Orange Flavored Whisper</title><link>https://realcedriccheng.github.io/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/</link><description>Recent content in 理论知识 on The Orange Flavored Whisper</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 07 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://realcedriccheng.github.io/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/index.xml" rel="self" type="application/rss+xml"/><item><title>C++理论知识</title><link>https://realcedriccheng.github.io/p/cpplilunzhishi/</link><pubDate>Mon, 07 Apr 2025 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/cpplilunzhishi/</guid><description>&lt;h2 id="指针和引用">指针和引用
&lt;/h2>&lt;p>指针是占用内存地址的独立变量，内存中存储的就是一个地址。而引用是某个变量的别名，不占用独立内存空间。&lt;/p>
&lt;p>指针定义时可以不初始化，但是最好初始化，指向的内容可以变，存在空指针。引用定义时必须初始化，绑定后不可改变，不存在空引用。&lt;/p>
&lt;p>使用指针访问地址内容时需要星号解引用，引用不需要。&lt;/p>
&lt;p>指针一般用于动态内存分配，数组操作以及函数参数传递。引用通常用于函数传参，操作符重载和创建别名。&lt;/p>
&lt;h2 id="数据类型">数据类型
&lt;/h2>&lt;p>short至少16位、int至少与short一样长、long至少32位、long long至少64位。一般int就是32位和long一样。为了避免歧义可以使用uint32_t/int32_t&lt;/p>
&lt;h2 id="关键字">关键字
&lt;/h2>&lt;h3 id="const关键字用于修饰只读变量">const关键字用于修饰只读变量
&lt;/h3>&lt;p>必须定义时就赋初值。&lt;/p>
&lt;p>对于指针：&lt;/p>
&lt;ol>
&lt;li>底层const是const int *a = 地址或者int const *a =地址，指针可以指向别的地址，但是a的内容不能变&lt;/li>
&lt;li>顶层const是int *const a = 地址，指针只能指向这个地址，但是地址存放的内容可以变&lt;/li>
&lt;/ol>
&lt;p>常量引用：const int &amp;amp;a = b引用的值是常量，不能通过引用修改。&lt;/p>
&lt;p>常量成员函数：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Hero&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">getBlood&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="p">{...}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>大括号之前写const，表示不会修改对象的非静态成员变量，但是可以修改静态成员变量。只能调用其他常量成员函数，不能调用非const成员函数（避免事实修改）&lt;/p>
&lt;p>常量对象：const Hero hero(&amp;hellip;);必须在创建对象时调用构造函数，使用初始化列表。创建后不可修改成员变量，只能调用常量成员函数。&lt;/p>
&lt;p>常引用参数：void foo(const string&amp;amp; str)确保参数不会被修改，可以绑定右值。&lt;/p>
&lt;p>常量指针参数：也分为底层和顶层，保护指针指向地址不变或指针地址指向值不变。&lt;/p>
&lt;h3 id="const和constexpr">const和constexpr
&lt;/h3>&lt;p>const表示只读，而constexpr表示常量。&lt;/p>
&lt;p>• const的值可以由函数返回值等在运行时初始化，而constexpr必须在编译时由常量表达式初始化&lt;/p>
&lt;p>• const可以修饰成员函数，表示不改变非静态成员变量的值，但是不能修饰普通函数；constexpr可以修饰函数，意思时能在编译期调用并返回函数值，注意不能动态分配内存，必须非常简单。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">constexpr&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">factorial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">?&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">factorial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// C++14起支持递归[1,6](@ref)。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">constexpr&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">factorial&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 编译期计算结果为120[1,4](@ref)。• constexpr可以将一些计算提前到编译期做，避免运行时开销。constexpr还可以用于检查一个表达式是否是常量表达式
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="static关键字定义静态变量和函数">static关键字定义静态变量和函数
&lt;/h3>&lt;p>静态变量：static修饰的局部变量或全局变量，生命周期和进程一样长，不会因离开函数作用域而销毁，默认初始化为0。可以用于计数函数调用次数、在递归函数中缓存中间结果等。&lt;/p>
&lt;p>全局静态变量和全局变量的区别在于全局静态变量不能在其他文件中通过extern关键字引用。&lt;/p>
&lt;p>静态函数是static修饰的普通函数，作用域仅限当前文件，不可被其他文件通过extern声明。&lt;/p>
&lt;p>静态成员变量是类内用static修饰的成员变量，属于类而不是对象。所有实例共享同一份数据，必须在类外单独初始化。&lt;/p>
&lt;p>静态成员函数是类中使用static修饰的成员函数，静态成员函数不能直接访问非静态成员或调用非静态成员函数，可以通过类名调用而需要创建类的示例.&lt;/p>
&lt;p>静态成员或静态成员函数可以通过实例调用，但是不合适。1. 容易混淆静态和非静态成员2.最好使用类名调用&lt;/p>
&lt;p>const和static不能一起使用，因为静态成员函数不含有this指针，而const成员函数必须具体到某一实例。&lt;/p>
&lt;h3 id="mutable">Mutable
&lt;/h3>&lt;p>const函数不修改对象成员，但是某些成员如计数器等要求修改，则可以用，mutable修饰，在const中可以修改这些成员。&lt;/p>
&lt;h3 id="define和typedef">define和typedef
&lt;/h3>&lt;p>• define只是字符串替换，没有类型检查，作用于编译的预处理阶段，可以防止头文件重复引用（写头文件的开头结尾有#ifndef和#endif）。不分配内存，有多少次使用就有多少次替换&lt;/p>
&lt;p>• typedef为类型定义别名，作用于编译处理阶段，有对应的数据类型，在静态区分配空间，程序运行过程中内存中只有一个拷贝&lt;/p>
&lt;h3 id="define和inline">define和inline
&lt;/h3>&lt;p>• inline用于定义内联函数，在调用函数处将函数展开，因此能够避免调用函数带来的压栈、跳转等开销&lt;/p>
&lt;p>• 必须是小的函数体，不能存在循环，必须减少条件判断&lt;/p>
&lt;p>• inline先编译再插入，在编译阶段。define在预处理阶段展开&lt;/p>
&lt;h3 id="define和const">define和const
&lt;/h3>&lt;p>const和define都可以用于定义常量&lt;/p>
&lt;p>• const在编译阶段、define在预处理阶段&lt;/p>
&lt;p>• const定义的常量放在内存中，define直接替换&lt;/p>
&lt;p>• const常量有类型，define没有&lt;/p>
&lt;h3 id="using和typedef">using和typedef
&lt;/h3>&lt;p>都可以定义别名&lt;/p>
&lt;p>typedef int Integer&lt;/p>
&lt;p>using Integer = int建议使用using，因为可读性更强，更简洁。&lt;/p>
&lt;p>using还能用来引入命名空间，引入基类成员。&lt;/p>
&lt;p>通过using namespace &amp;hellip;将命名空间内所有成员引入当前作用域，因此不需要前缀。但是最好不要在头文件中使用，以免导致命名冲突。过度使用会降低可读性，不好确定成员是哪个命名空间的。&lt;/p>
&lt;p>通过using std::cout可以引入特定成员，减少命名冲突风险。&lt;/p>
&lt;p>（要不跳过吧）通过在派生类中声明using Base::Base 继承基类构造函数，避免重复定义。在派生类中使用Base::func可以将基类中private的func提升为派生类的public成员。当派生类定义同名成员时可以显式保留基类成员。&lt;/p>
&lt;h2 id="命名空间">命名空间
&lt;/h2>&lt;p>命名空间通过将代码元素封装在特定作用域内避免变量的命名冲突。&lt;/p>
&lt;p>例如定义两个命名空间，可以通过两个冒号解析&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">namespace&lt;/span> &lt;span class="n">NS1&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">namespace&lt;/span> &lt;span class="n">NS2&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">NS1&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">NS2&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="new和malloc都可以用于动态内存分配">new和malloc都可以用于动态内存分配
&lt;/h3>&lt;p>• new分配对象大小的内存后调用构造函数初始化对象，返回对象指针；malloc需要指定分配大小，并且返回void指针&lt;/p>
&lt;p>• 空间不足时，new抛出异常，而malloc返回空指针&lt;/p>
&lt;p>• new必须用delete释放，调用析构函数；malloc必须用free释放，不调用析构函数&lt;/p>
&lt;p>• malloc在堆上分配空间，new在自由存储区分配（允许自定义内存池，但一般也是堆）。&lt;/p>
&lt;p>malloc在底层使用malloc分配，但是会额外完成构造逻辑，通过重载new可以将自由存储区指向其他区域。&lt;/p>
&lt;h3 id="delete和free">delete和free
&lt;/h3>&lt;p>• delete会调用析构函数，free仅释放内存，可能导致资源泄漏，如未关闭文件等。&lt;/p>
&lt;p>• delete可以正确释放new直接创建的数组，free必须手动循环释放数组的每一项&lt;/p>
&lt;h3 id="extern">extern
&lt;/h3>&lt;p>声明在其他文件定义的非静态变量或非静态函数&lt;/p>
&lt;p>i++, ++i&lt;/p>
&lt;p>i++返回的是i，++i返回的是i+1。&lt;/p>
&lt;p>i++创建了一个临时对象保存i，并返回临时对象。&lt;/p>
&lt;h3 id="stdatomic">std::atomic
&lt;/h3>&lt;p>确保对变量的读写、修改等操作不可分割，操作过程中不会被其他线程打断。&lt;/p>
&lt;h3 id="struct和class">struct和class
&lt;/h3>&lt;p>struct和class的功能几乎完全一样，只是默认行为不同。struct默认成员、继承方式都是公有的，class默认私有。&lt;/p>
&lt;h2 id="函数指针">函数指针
&lt;/h2>&lt;p>指针指向的是函数的地址（代码段），允许在运行时动态选择要调用的函数。&lt;/p>
&lt;p>int (*func)(int, int)&lt;/p>
&lt;p>如果省略括号就会编程返回指针的函数&lt;/p>
&lt;p>可以用于实现1. 回调函数机制，将函数指针作为参数传递2.根据不同参数选择不同函数处理&lt;/p>
&lt;h2 id="强制类型转换">强制类型转换
&lt;/h2>&lt;p>四种强制类型转换的关键字：static_cast，dynamic_cast，reinterpret_cast和const_cast&lt;/p>
&lt;p>• static_cast用于截断或扩展整数、上行转换（将派生类转换为基类）
◦ 编译时检查，无运行开销
◦ 下行转换不安全，因为没有动态类型检查
◦ 支持void*和整数之间的互换&lt;/p>
&lt;p>• dynamic_cast用于动态类型转换，可以将基类指针转换为派生类指针
◦ 运行时有类型检查，转换失败返回空指针，引用的话抛出异常
◦ 通过虚函数表获取对象的实际类型信息，检查目标类型是否是实际类型&lt;/p>
&lt;p>• const_cast用于去除const属性，但是如果对象是真正的常量，则会导致未定义行为。编译器也有可能将const优化成字面量，导致修改无效。&lt;/p>
&lt;p>• reinterpret_cast用于无关类型的转换，如int转为char，基于内存的位重新解释，绕过类型系统，高风险。&lt;/p>
&lt;p>static是按类型规则逻辑处理数据，但reinterpret是物理上重新解释内存&lt;/p>
&lt;h2 id="c内存管理">C++内存管理
&lt;/h2>&lt;h3 id="堆和栈">堆和栈
&lt;/h3>&lt;p>栈是由编译器自动管理，存放局部变量、函数参数以及返回地址，通过移动栈指针分配内存，栈上变量的生命周期和所在函数相同。&lt;/p>
&lt;p>堆由用户手动管理，存放动态分配数据，生命周期由用户控制。&lt;/p>
&lt;p>栈分配得块，因为进程本身就有一段连续的段空间，仅需调整栈指针就可以分配和回收。每个线程有独立的栈，栈的容量较小。&lt;/p>
&lt;p>堆不是先进后出的，因此每次从堆中分配内存时需要先通过空闲内存块链表搜索合适大小的内存块，如果没有再移动堆顶指针。可能还会触发碎片整理。同一个进程的不同线程共享堆空间，因此可能需要同步机制。&lt;/p>
&lt;h3 id="内存分区">内存分区
&lt;/h3>&lt;p>栈&lt;/p>
&lt;p>堆&lt;/p>
&lt;p>全局/静态：bss未初始化，data初始化&lt;/p>
&lt;p>只读数据段.rodata&lt;/p>
&lt;p>代码段&lt;/p>
&lt;h3 id="内存泄漏">内存泄漏
&lt;/h3>&lt;p>内存泄漏是程序分配内存后失去了对该内存的控制，因此无法释放。&lt;/p>
&lt;p>• 堆内存泄漏：通过malloc，new等动态分配的对象忘记释放&lt;/p>
&lt;p>• 系统资源泄漏：程序使用系统分配的资源，如socket等，却没有释放或关闭。&lt;/p>
&lt;p>• 对象泄漏：没有正确定义析构函数或没有将基类的析构函数定义为虚函数，这样导致基类指针指向的派生类对象会调用基类的析构函数，从而无法正确释放派生类资源&lt;/p>
&lt;p>防止内存泄漏的方法有：将内存的分配和释放封装在类中，从而避免忘记释放；使用智能指针。&lt;/p>
&lt;h3 id="智能指针">智能指针
&lt;/h3>&lt;p>智能指针用来避免内存泄漏，生命周期后会自动释放资源，不需要用户手动释放。&lt;/p>
&lt;p>3种智能指针：
• 独占智能指针unique_ptr：一个独占指针唯一拥有资源，别的指针不能指向他管理的内存。没有额外开销，性能接近于原生指针
• 共享智能指针shared_ptr：允许多个指针指向同一个对象，利用计数器机制管理。只有最后一个指针销毁时才释放。但是可能导致循环引用
• 弱引用指针weak_ptr：不增加引用计数，因此不会导致循环引用，例如父节点通过shared_ptr引用子节点，子节点通过weak_ptr引用父节点&lt;/p>
&lt;h3 id="野指针和悬浮指针">野指针和悬浮指针
&lt;/h3>&lt;p>野指针是指向无效或位置内存地址的指针，使用野指针会导致不可预知的行为。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>未初始化的指针，其值为随机内存地址，如栈和堆中的垃圾地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>释放后未置空的指针，内存值已不可用，如释放了参数指针&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回局部变量的指针（变量在函数作用域外被销毁）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指针越界访问（数组越界、分配内存之外等）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>悬空指针是指向已释放内存的指针，是野指针的一种。&lt;/p>
&lt;h3 id="内存对齐">内存对齐
&lt;/h3>&lt;p>内存对齐是指数据在内存中的存储起始地址是某个值的倍数。&lt;/p>
&lt;p>结构体中可能包含不同类型的变量，变量按照声明的顺序放置，第一个成员和整个结构体的地址相同。&lt;/p>
&lt;p>出于CPU访问效率的考虑，变量的起始地址应当在长度的整数倍上，比如4字节的int，起始地址应该是4字节的整数倍。&lt;/p>
&lt;h3 id="乱序执行">乱序执行
&lt;/h3>&lt;p>• CPU层面，允许不共享数据的指令并行执行&lt;/p>
&lt;p>• 编译器层面允许调整无数据以来的指令顺序、将循环体展开为多个迭代以减少分支预测、分支预测优化。&lt;/p>
&lt;p>单线程场景可以提升执行效率，多线程场景可能导致数据竞争，线程同步关系颠倒可能导致逻辑错误&lt;/p>
&lt;p>可以采用原子类型std::atomic保证操作的原子性、插入内存屏障指令限制某些重排序。&lt;/p>
&lt;h2 id="stl">stl
&lt;/h2>&lt;p>string实际不属于stl，而是C++标准库的独立组件&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 构造
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">s1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 空，默认构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="nf">s2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 默认构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="nf">s3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="sc">&amp;#39;c&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 默认构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="nf">s4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 拷贝构造
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 子串
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">s5&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">substr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 起始，偏移量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">getline&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">istream&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">in&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">string&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">length&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">返回字符个数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">empty&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">判断是否空&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">capacity&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">返回分配的存储容量，不含&lt;/span>&lt;span class="sc">&amp;#39;\0&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">len&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">就是&lt;/span>&lt;span class="n">truncate&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">clear&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">清空字符串内容，但是保留容量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">reserve&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="err">预分配内存减少扩容开销&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>[]通过下标访问，不检查越界。&lt;/p>
&lt;p>at()通过下标访问并检查越界&lt;/p>
&lt;p>front(), back()访问首尾字符&lt;/p>
&lt;p>c_str()返回以\0结尾的c风格字符串&lt;/p>
&lt;p>+= / append()追加字符串或字符&lt;/p>
&lt;p>push_back()追加字符&lt;/p>
&lt;p>insert(pos, str)在pos处插入str&lt;/p>
&lt;p>replace(pos, len, str)替换从pos开始的len个字符为str&lt;/p>
&lt;p>erase(pos, len)删除从pos开始的len个字符&lt;/p>
&lt;p>find(str, pos)从pos开始查找str，返回首次出现的位置&lt;/p>
&lt;p>rfind(str, pos)反向查找&lt;/p>
&lt;p>find_first_of(str)返回包含str任意字符的首个位置&lt;/p>
&lt;p>查找失败返回npos（-1的无符号形式）&lt;/p>
&lt;p>==和&amp;lt;&amp;gt;直接比较（字典序）&lt;/p>
&lt;p>compare(str)返回0（相等），正数（大于），负数（小于）&lt;/p>
&lt;p>begin(), end(), rbegin(), rend()等迭代器&lt;/p>
&lt;h2 id="程序编译过程">程序编译过程
&lt;/h2>&lt;p>• 源代码
• 预处理
◦ 宏替换、包含头文件（将头文件内容插入源文件）、删除注释
• 编译
◦ 生成汇编代码.s文件。词法分析、语法分析、语义分析、中间代码生成与优化
• 汇编
◦ 将汇编代码翻译为机器指令，生成目标文件.o，有代码段、数据段、符号表
• 链接
◦ 链接器将多个目标文件和库文件合并为可执行文件
◦ 跨文件符号解析、地址重定位
◦ 静态链接将库代码拷贝到可执行文件、动态链接在运行时加载共享库&lt;/p>
&lt;h2 id="初始化">初始化
&lt;/h2>&lt;p>int a = 1; int a(1)和int a = {1}的区别&lt;/p>
&lt;p>int a = 1是复制初始化，编译器先将右值转换为目标类型对象，然后调用拷贝构造函数初始化左侧对象。&lt;/p>
&lt;p>int a (1)调用了int类的构造函数，1是参数s。&lt;/p>
&lt;p>int a = {1}是列表初始化，可以避免隐式类型转换带来的窄化，因为编译器会检查是否窄化。&lt;/p>
&lt;h2 id="右值引用用来实现移动语义和完美转发">右值引用用来实现移动语义和完美转发
&lt;/h2>&lt;p>左值是占用一定内存空间的，可以取地址的值。右值是不占用地址空间的，一般是立即数等。&lt;/p>
&lt;p>左值的生命周期取决于变量类型，而右值一般执行完所在语句后就死亡。&lt;/p>
&lt;p>右值引用，例如int &amp;amp;&amp;amp; a = 1；可以将1这个右值的生命周期延长到作用域结束。&lt;/p>
&lt;p>右值引用可以实现移动语义，也就是将资源从一个所有者移动到另一个所有者，而不需要拷贝。例如某个函数的返回值是一个对象，而函数的返回值是一个右值，因为函数结束后，变量所在作用域就结束了。因此本来调用函数的语句执行完后返回值就死亡了，是一个右值。然而使用右值引用可以延长其生命周期，可以用其初始化另一个对象。该类具有移动构造函数的情况下，会把对象的成员直接转移给新对象，而不是调用拷贝构造函数复制。&lt;/p>
&lt;p>完美转发一般用于模板函数，可以在传递参数时原样转发，而不是构造一个新的参数。通过std::forward实现&lt;/p>
&lt;p>移动语义只适合实现了移动构造函数的类，对于int，double等还是会复制&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">rv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">42&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 绑定右值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span> &lt;span class="n">s&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">string&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">s_rv&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">move&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 转换为右值引用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyString&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 移动构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">MyString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyString&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">noexcept&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">:&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">nullptr&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 原对象资源置空
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">other&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size_t&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">MyString&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">vec&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">MyString&lt;/span> &lt;span class="nf">tmp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;test&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">vec&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">move&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">// 调用移动构造函数而非拷贝
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* 处理左值 */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* 处理右值 */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="n">relay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">arg&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">process&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">forward&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arg&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">// 保持arg的原始类型
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">relay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 调用process(int&amp;amp;)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">relay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 调用process(int&amp;amp;&amp;amp;)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="面向对象特性">面向对象特性
&lt;/h2>&lt;p>CPP的面向对象特性包括 封装、继承、多态&lt;/p>
&lt;h3 id="封装">封装
&lt;/h3>&lt;p>将数据和对数据的操作捆绑在一个类中，通过访问控制隐藏内部实现，对外暴露有限接口。作用：数据安全，避免外部直接修改或访问私有成员；模块化，类便于复用和维护；简化使用，用户无需了解具体实现
访问权限&lt;/p>
&lt;p>public - 公有成员可以被外部访问&lt;/p>
&lt;p>protected - 保护成员只能被类内部、友元函数和派生类函数访问&lt;/p>
&lt;p>private - 私有成员只能被类内部访问&lt;/p>
&lt;p>友元：允许非成员函数或其他类访问protected和private。单向的，不具有传递性。&lt;/p>
&lt;h3 id="构造函数和析构函数">构造函数和析构函数
&lt;/h3>&lt;p>构造函数在对象创建时自动调用初始化数据成员，与类名完全相同，没有返回值，可以重载。&lt;/p>
&lt;p>构造函数不能是虚函数。&lt;/p>
&lt;p>• 默认构造函数
◦ 无参数时自动构造，不会初始化int等内置类型。string有自己的构造函数所以初始化为空字符串
◦ 如果没有定义任何构造函数则会生成默认构造函数，如果有构造函数则需要自己定义不带参数的构造函数
◦ 同时定义无参构造函数和全缺省构造函数会产生冲突（a(){}和a(int a = 0){}）&lt;/p>
&lt;p>• 带参数构造函数
◦ 自己定义的构造函数&lt;/p>
&lt;p>• 拷贝构造函数
◦ 使用一个对象构造一个新对象
◦ 浅拷贝：对指针成员仅复制指针地址，若原对象销毁则指针内容会释放
▪ 需要自定义深拷贝函数，创建空间并将值复制过来&lt;/p>
&lt;p>• 移动构造函数
◦ 通过资源转移将原对象的成员转移到自身，不需要拷贝。原对象不再拥有资源，可以安全删除。
◦ 参数必须是右值引用，如果要处理左值需要用std::move显式转换&lt;/p>
&lt;p>析构函数在对象生命周期结束时释放资源，包括局部对象离开作用域、delete删除对象。函数名为波浪号加类名，不允许带参数，不可重载。自动调用。默认析构函数不会释放资源，因此必须自己定义析构函数。基类的析构函数需要定义为虚函数。&lt;/p>
&lt;p>构造顺序：基类构造函数 - 成员构造函数 - 自己的构造函数&lt;/p>
&lt;p>析构顺序反向：自己析构函数 - 成员析构函数 - 基类析构函数&lt;/p>
&lt;p>构造函数不能是虚函数，基类的析构函数需要设为虚函数&lt;/p>
&lt;p>构造函数不能是虚函数，因为虚函数有虚函数表动态绑定，而虚函数表由对象的虚指针指向。虚指针在构造函数中初始化，因此构造函数无法使用虚指针。另一方面，虚函数的语义是根据对象的实际类型实现运行时多态，而构造函数正是用于确定对象的具体类型，因此有语义冲突。&lt;/p>
&lt;p>基类的析构函数需要是虚函数，否则通过基类指针或引用释放派生类对象时会调用基类的析构函数，导致无法正确释放资源。但是如果是子类指针指向则可以正确析构。&lt;/p>
&lt;h3 id="继承">继承
&lt;/h3>&lt;p>允许派生类继承基类的非私有属性和方法。作用：派生类可以复用基类代码减少重复实现、派生类可以扩展基类代码实现更多功能&lt;/p>
&lt;p>• 继承方式&lt;/p>
&lt;pre>&lt;code>◦ public：表达特例关系，例如学生是一种人，因此学生具有人的所有成员
▪ 成员属性保持不变
◦ protected：可以用于实现多级继承中的中间层，既不对外暴露成员，又允许再次继承
▪ public和protected变为protected
◦ private：实现新功能，例如用链表实现栈，但是不暴露链表接口，只保留栈的接口
▪ public和protected变为private
◦ 三种继承方式，派生类都不能访问基类的private成员
&lt;/code>&lt;/pre>
&lt;h3 id="多重继承">多重继承
&lt;/h3>&lt;p>允许一个派生类同时继承多个基类，基类构造函数的调用顺序取决于派生类声明时的排列顺序，而不是参数列表顺序。析构函数的调用顺序于构造函数相反。&lt;/p>
&lt;p>允许组合不同基类的功能，例如基类手机、电脑等和基类输出电池容量（纯接口类）。&lt;/p>
&lt;p>• 二义性&lt;/p>
&lt;pre>&lt;code>◦ 多个基类有重名成员，需要用两个冒号指明哪个基类
&lt;/code>&lt;/pre>
&lt;p>• 菱形继承&lt;/p>
&lt;pre>&lt;code>◦ 多个中间基类来自同一个基类，则派生类继承多个相同成员副本
◦ 确保中间基类使用虚继承，则派生类仅保留一份副本
▪ 虚继承就是继承时加virtual关键字，虚继承的用处就是解决菱形继承
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">A&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">B&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">virtual&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">A&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">C&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">virtual&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">A&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">D&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">B&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">C&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>• 最好用组合代替多重继承，避免深层次多重继承导致难以维护&lt;/p>
&lt;p>派生类会调用基类构造函数和析构函数&lt;/p>
&lt;p>创建派生类对象时会调用基类构造函数。如果有默认基类构造函数会隐式调用，否则必须显式调用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">A&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">A&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">B&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="k">public&lt;/span> &lt;span class="n">A&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">B&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">B&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">A&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>构造函数调用顺序：基类构造函数 - 派生类成员构造函数 - 派生类构造函数&lt;/p>
&lt;p>析构时会自动调用派生类的析构函数，再自动调用基类的析构函数。注意，如果用基类指针指向派生类，而基类的析构函数未声明为虚函数，则导致派生类析构函数未调用。因此最好将基类的析构函数声明为虚函数。&lt;/p>
&lt;h2 id="多态">多态
&lt;/h2>&lt;p>同一操作作用于不同对象表现不同特性，分为编译时多态和运行时多态&lt;/p>
&lt;p>• 编译时多态：无运行时开销，但无法根据运行情况调整行为
◦ 函数/运算符重载/模板
▪ 函数重载：同一作用域中定义多个同名函数，参数列表不同
▪ 运算符重载：自定义类对象的运算操作&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 左操作数是当前类的对象，则用成员函数重载
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">vector&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector&lt;/span> &lt;span class="k">operator&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">vector&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 隐含this-&amp;gt;x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nf">vector&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 左操作数不是当前类对象，用友元函数重载。注意友元关系无法继承
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="nc">array&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">friend&lt;/span> &lt;span class="n">ostream&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="k">operator&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ostream&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">os&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">const&lt;/span> &lt;span class="n">array&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">os&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34; &amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;pre>&lt;code> ▪ 模板：泛化参数类型从而定义可以处理多种数据类型的函数或类
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">stack&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 函数操作
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">T&lt;/span> &lt;span class="nf">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">T&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 如果a是整型，b是浮点就会编译失败，注意这是编译时多态，不会等到运行时
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>• 运行时多态：允许程序通过对象的实际类型调用对用的函数
◦ 重写
▪ 派生类重写并覆盖基类的函数，根据对象实际类型调用该对象的函数。
▪ 基类的函数必须声明为虚函数，参数列表、返回类型等声明必须完全一致，但是访问权限可以不同（变得更开放）
▪ 不能重写private函数（根本看不见），静态方法不能重写为非静态方法
▪ 重写时可以在大括号前写override，但是也可以不写
• 不写override则编译器不会检查签名是否一致，若不一致不会报错，而是将重写的函数视为新函数（重定义），导致基类函数隐藏，无法使用多态（基类指针指向派生类对象，只能使用基类函数， 派生类指针指向派生类对象，只能使用派生类函数，但可以用::显式调用基类函数。将基类函数声明为virtual，则为省略override的重写）。&lt;/p>
&lt;p>不将基类函数声明为虚函数，则为重定义。&lt;/p>
&lt;p>基类指针可以指向派生类，但派生类指针不能指向基类&lt;/p>
&lt;p>在派生类对象的内存布局中，基类部分在派生类部分前部，因此基类指针可以访问派生类对象中属于基类的成员而不会越界。&lt;/p>
&lt;p>通过虚函数机制，基类指针可以调用派生类重写的虚函数。&lt;/p>
&lt;p>因此，基类析构函数不设置为虚函数的话，基类指针无法调用派生类的析构函数。&lt;/p>
&lt;p>派生类指针无法指向基类对象，因为基类对象不包含派生类特有的成员，因此会有越界风险。不允许隐式转换，强制转换可能导致运行时错误。&lt;/p>
&lt;h3 id="虚函数">虚函数
&lt;/h3>&lt;h4 id="虚函数表存放">虚函数表存放
&lt;/h4>&lt;p>虚函数表指针和对象一起存储，放在对象的起始地址。&lt;/p>
&lt;p>虚函数表在编译时生成，本身放在只读数据段。&lt;/p>
&lt;p>虚函数内容放在代码段。&lt;/p>
&lt;p>构造函数会隐式初始化对象的虚函数表指针。&lt;/p>
&lt;p>通过基类指针调用虚函数时程序会通过对象的虚函数表指针找到虚函数表，根据函数在表中的偏移量调用正确的派生函数。&lt;/p>
&lt;p>派生类会继承基类的虚函数表，若重写虚函数则替换虚表中的地址。&lt;/p>
&lt;p>虚函数表是所有的类共享，还是每个类有自己的虚函数表&lt;/p>
&lt;p>每个类有自己的虚函数表，编译器会为每个包含虚函数的类单独生成虚函数表，同一类的不同对象共享一个虚表，不同的类不共享一张虚表。&lt;/p>
&lt;p>纯虚函数&lt;/p>
&lt;p>纯虚函数没有函数体，只有=0声明。含有纯虚函数的基类是虚基类（抽象类），虚基类无法实例化，只能用于派生类，派生类必须要实现否则派生类也是虚基类。用于提供一种接口规范。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">A&lt;/span>&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 实现，允许重写
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">virtual&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">func2&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 纯虚函数，必须重写
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不能被声明为虚函数&lt;/p>
&lt;ol>
&lt;li>
&lt;p>构造函数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>普通非成员函数（只能重载，不能重写）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>静态成员函数（无法访问虚函数表（虚函数指针在对象首部））&lt;/p>
&lt;/li>
&lt;li>
&lt;p>友元函数（友元函数不能继承）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内联成员函数（内联在编译时就展开了，而重写是运行时的多态）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="空类的大小">空类的大小
&lt;/h2>&lt;p>空类是不包含非静态成员变量、虚函数或虚基类的类&lt;/p>
&lt;p>空类会默认生成默认构造函数、拷贝构造函数、默认析构函数、赋值运算符和取地址运算符。&lt;/p>
&lt;p>空类可以用来作为接口占位，具体逻辑由不同子类完成。&lt;/p>
&lt;p>• 默认为1字节，因为每个对象必须有唯一的地址&lt;/p>
&lt;p>• 当空类作为基类时，编译器可能会用空基类优化，就是将占位字节和派生类成员合并。但是如果继承了多个空基类，则不能这样优化&lt;/p>
&lt;p>• 如果包含虚函数，则需存储虚函数表指针，大小是指针的大小（64位系统8字节）&lt;/p>
&lt;p>• 空类作为其他类成员则可能需要内存对齐&lt;/p>
&lt;p>• 静态成员变量存放在数据段，成员函数存放在代码段，因此不影响类大小。&lt;/p>
&lt;h2 id="运算符重载">运算符重载
&lt;/h2>&lt;p>重载运算符本质上是重载函数，只是函数名为operator+或其他运算符。&lt;/p>
&lt;p>使用运算符比函数调用的形式更直观。&lt;/p>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>C++中作用域解析::， 成员访问.，三目条件运算符?:等不可重载&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重载运算符不能改变优先级，比如+的优先级低于*&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不能改变运算符的操作数，二元运算符必须有两个参数&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重载的运算符必须至少有一个操作数是用户自定义类型，也就是int double等内置类型不能重载&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要注意操作符在语义上要直观，相关的操作符也要重载，比如重载了==，也应该重载!=&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="段错误segmentation-fault">段错误Segmentation Fault
&lt;/h2>&lt;p>段错误的本质是程序运行访问了非法地址或违反了访问权限，导致被操作系统强行终止。&lt;/p>
&lt;p>• 访问未分配的内存（释放指针后又使用）&lt;/p>
&lt;p>• 越界访问&lt;/p>
&lt;p>• 修改只读数据&lt;/p>
&lt;p>MMU检测到非法访问后，向操作系统发送错误信号sigsegv，进程终止并生成core文件，这叫做核心转储。&lt;/p>
&lt;p>要注意指针的使用和边界检查、是否栈过深等。&lt;/p>
&lt;h2 id="lambda表达式">lambda表达式
&lt;/h2>&lt;p>lambda表达式是一种匿名函数工具，对于比较简短的逻辑，可以写一个lambda表达式代替定义一个函数。&lt;/p>
&lt;p>lambda表达式的完整形式是&lt;a class="link" href="%e5%8f%82%e6%95%b0%e5%88%97%e8%a1%a8" >捕获列表&lt;/a>mutable-&amp;gt;返回类型{函数体}&lt;/p>
&lt;p>捕获列表表示能够访问哪些外部变量，=：按值捕获所有外部变量、&amp;amp;：按引用捕获所有外部变量、x, &amp;amp;y：x按值，y按引用、this：捕获当前对象的成员变量&lt;/p>
&lt;p>mutable：允许修改按值捕获的变量部分，默认是const不能改变&lt;/p>
&lt;p>-&amp;gt; int 返回值是int，也可以不写，让编译器推导&lt;/p>
&lt;p>既然捕获了所有变量，就可以不写参数列表。&lt;/p>
&lt;h2 id="多线程条件变量condition-variable和mutex">多线程、条件变量condition variable和mutex
&lt;/h2>&lt;p>条件变量是实现线程间同步的工具，引入condition_variable头文件，和mutex配合使用。
通过wait等待，通过notify_one和notify_all唤醒
cv.wait(lock)或者cv.wait(lock, 一个lambda表达式谓词)。前者：释放lock并等待notify；后者：释放lock并等待notify，只有在lambda表达式为真才唤醒。
std::thread用来创建线程，接收函数名、lambda表达式。线程也是一种对象。thread不可复制，可以移动。这是为了防止多个线程对象管理同一线程资源造成竞争。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;hello, &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 线程参数按值传递，线程在构造函数调用时立即启动
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kr">thread&lt;/span> &lt;span class="nf">t1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hello&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">thread&lt;/span> &lt;span class="nf">t2&lt;/span>&lt;span class="p">([](){&lt;/span>&lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;lambda&amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyClass&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;MyClass: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">val&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 绑定对象函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">MyClass&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kr">thread&lt;/span> &lt;span class="nf">t3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyClass&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">34&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// join的意思是主线程等待该线程完成再继续进行
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t3&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>thread的join方法是让主线程阻塞等待该线程完成，用来同步。detach方法是将子线程从主线程的管理分离，在后台独立运行。由C++库自己管理回收。detach后无法用原来的thread对象管理线程。
thread在销毁之前必须被join或者detach，必须保证线程函数运行期间线程对象有效或者detach&lt;/p>
&lt;h3 id="lock_guard和unique_lock">lock_guard和unique_lock
&lt;/h3>&lt;p>lock_guard创建就上锁，作用域结束析构时候解锁，不能中途手工解锁，也不能复制&lt;/p>
&lt;p>unique_lock允许创建时不上锁而是延迟上锁，可以随时手动加锁解锁(unique_lock&lt;mutex> lock(mtx); lock.unlock(); lock(lock);)，析构时自动释放，不可复制可以移动，条件变量必须配合unique_lock使用&lt;/p>
&lt;h3 id="互斥锁和条件变量程序例子">互斥锁和条件变量程序例子
&lt;/h3>&lt;p>多线程交替打印数字&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;condition_variable&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mutex&lt;/span> &lt;span class="n">mtx&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">condition_variable&lt;/span> &lt;span class="n">cv&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">bool&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">print_odd&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 打印奇数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mtx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 在使用条件变量之前必须持有锁，否则对条件变量的检查不是原子的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[](){&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;odd: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">print_even&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 打印偶数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mtx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[](){&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">;});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;even: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">print_odd&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">print_even&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>生产者消费者问题&lt;/p>
&lt;p>只用了一个cv，可能导致无效唤醒。因此可以用两个条件变量，分别专门唤醒消费者和生产者。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;condition_variable&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;atomic&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;queue&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">TOTAL_ITEMS&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">BUFFER_SIZE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">atomic&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">done&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">mutex&lt;/span> &lt;span class="n">mtx&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">condition_variable&lt;/span> &lt;span class="n">cv&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">producer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">TOTAL_ITEMS&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mtx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[](){&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">BUFFER_SIZE&lt;/span>&lt;span class="p">;});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;producer: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34; q.size: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">done&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">consumer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">true&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mtx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[](){&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="p">;});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">done&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;consumer: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34; q.size&amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">producer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kr">thread&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">consumer&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>读写锁&lt;/p>
&lt;p>C++17的shared_mutex可以直接实现读写锁（写者优先）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;shared_mutex&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;vector&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">ThreadSafeResource&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shared_mutex&lt;/span> &lt;span class="n">sm&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">read&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shared_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">shared_mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">l&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">sm&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;read: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">shared_mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">l&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sm&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;write: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">ThreadSafeResource&lt;/span> &lt;span class="n">TSR&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建5个读者线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">](){&lt;/span>&lt;span class="n">TSR&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">read&lt;/span>&lt;span class="p">();});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 创建写者线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">](){&lt;/span>&lt;span class="n">TSR&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">write&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>C++11中，使用条件变量和mutex实现读写锁。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;mutex&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;condition_variable&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;vector&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;thread&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="k">using&lt;/span> &lt;span class="k">namespace&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">RWL&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">write_active&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">nr_reader&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">mutex&lt;/span> &lt;span class="n">mtx&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">condition_variable&lt;/span> &lt;span class="n">cv&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RWL&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">nr_reader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">write_active&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">false&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">readLock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mtx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">](){&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">write_active&lt;/span>&lt;span class="p">;});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nr_reader&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">readUnlock&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mtx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">nr_reader&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">nr_reader&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_one&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">writeLock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mtx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 不能有其他写者，不能有读者
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">](){&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">write_active&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">nr_reader&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">write_active&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">writeUnlock&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">unique_lock&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mtx&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">write_active&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cv&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">notify_all&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">RWL&lt;/span> &lt;span class="n">rwl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kr">thread&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 5个读线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">]{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">rwl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">readLock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;reader &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">rwl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">readUnlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 5个写线程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">([&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">]{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">rwl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">writeLock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;writer &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="s">&amp;#34;: &amp;#34;&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">&amp;lt;&amp;lt;&lt;/span>&lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">rwl&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">writeUnlock&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">});&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">k&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">].&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="原子变量">原子变量
&lt;/h2>&lt;p>对原子变量的读写修改时不可中断的，两个线程同时递增一个原子变量不会导致出错，这是硬件上的CPU指令保证的。&lt;/p>
&lt;h2 id="函数名是地址">函数名是地址
&lt;/h2>&lt;p>函数名是函数的地址，在代码中会隐式转换成指向函数的指针&lt;/p>
&lt;h2 id="stl-1">STL
&lt;/h2>&lt;p>STL包括算法、容器和迭代器、仿函数、适配器和分配器。&lt;/p>
&lt;p>• 容器是存放数据的各种数据结构，包括vector，deque、set、map等&lt;/p>
&lt;p>• 算法通过迭代器操作容器数据，包括sort、find等常用算法&lt;/p>
&lt;p>• 迭代器是访问容器元素的的抽象或者广义上的指针，重载了*、-&amp;gt;和++等运算符&lt;/p>
&lt;p>• 仿函数是重载了小括号的对象或者结构体，可以像调用函数一样使用这种对象。&lt;/p>
&lt;pre>&lt;code>◦ 内置的仿函数有算数运算（plus&amp;lt;T&amp;gt;，multiplies&amp;lt;T&amp;gt;等）、关系和逻辑运算（less&amp;lt;T&amp;gt;, equal_to&amp;lt;T&amp;gt;等，用于排序和条件判断）
◦ sort(v.begin(), v.end(), greater&amp;lt;int&amp;gt;())可以实现降序排列，也可以自定义一个bool cmp(int a, int b) {return a&amp;gt;b;}然后调用sort(v.begin(), v.end(), cmp);
&lt;/code>&lt;/pre>
&lt;p>• 适配器通过容器实现更高级的功能，例如stack和queue都是借助deque容器实现的&lt;/p>
&lt;p>• 分配器用于管理内存的动态分配和释放&lt;/p>
&lt;p>STL的优点在于具有高可重用性（采用模板类和模板函数，更通用）、高性能（精心设计的低复杂度算法，利用红黑树等复杂底层结构）、高移植性（使用STL编写的模块可以方便移植到其他项目，而不需要顺带移植很多实现函数）。&lt;/p>
&lt;h3 id="常用容器">常用容器
&lt;/h3>&lt;p>• pair&amp;lt;T1, T2&amp;gt; p&lt;/p>
&lt;pre>&lt;code>◦ 定义为一个struct，通过pair.first和pair.second访问两个成员
◦ 用来操作关联容器，例如可以将一个pair插入map
&lt;/code>&lt;/pre>
&lt;p>• vector&lt;/p>
&lt;pre>&lt;code>◦ 在堆中分配了一段连续的内存空间存放元素
◦ 迭代器first，end。first是起始元素位置，end是最后一个元素之后的位置。还有rbegin和rend。
◦ 扩容：vector.capacity()表示不分配新内存的情况下最多可以保存的元素个数（预分配的大小），vector.size()表示当前已经存储的元素个数，capacity永远大于等于size，相等时就会扩容。扩容就是动态
申请一段新的连续空间并把数组迁移过去
▪ 固定扩容是每次在原capacity的基础上增加固定的容量，比如每次都加20，优点是浪费较少，缺点是可能需要多次扩容
▪ 加倍扩容是每次将capacity翻倍，则需要预留较多空间，但是减少迁移开销
▪ 注意扩容会使得原来的迭代器失效
◦ resize：改变当前容器中含有元素的数量，如果resize(len)中的len&amp;lt;=capacity则只调整size=len，如果len &amp;gt;capacity则将size和capacity均设置为len。新增元素调用默认构造函数。
◦ reserve(len)改变capacity，如果len &amp;lt; capacity就不做任何改变，len&amp;gt;capacity就扩容，包括迁移
◦ emplace_back直接在容器的内存空间内使用对象的构造函数，无需临时对象，而pushback需要先构造一个临时对象再拷贝到容器尾部，因此emplaceback更高效
◦ 操作
&lt;/code>&lt;/pre>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="c1">// 5个10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="p">[]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">arr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">arr&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="c1">// 迭代器或指针范围初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 拷贝构造
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v5&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">};&lt;/span> &lt;span class="c1">// 列表初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v6&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">};&lt;/span> &lt;span class="c1">// 等号可以省略
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 尾部插入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 尾部插入，但是emplace_back更高效
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 把10插入到第二个位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop_back&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 删除尾部最后一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">erase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 删除第二个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">erase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 删除第2，3个元素（左闭右开）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clear&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 删除所有元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 检查越界
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// 不检查越界
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 调整大小
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">resize&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">42&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 调整大小并将 新增元素 初始化为42
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reserve&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 预留空间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">shrink_to_fit&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 释放预留的未使用空间
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 元素个数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">capacity&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 预留空间可以存放的元素个数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 传统遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 迭代器遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nl">i&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 简洁写法
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span> &lt;span class="c1">// 升序遍历
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">sort&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">greater&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">());&lt;/span> &lt;span class="c1">// 降序遍历• list 环状双向链表
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>◦ 在任意位置插入删除元素不会影响其他元素的迭代器，迭代器只支持++和&amp;ndash;，不能下标或跳跃（i+5）访问&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt"> 10
&lt;/span>&lt;span class="lnt"> 11
&lt;/span>&lt;span class="lnt"> 12
&lt;/span>&lt;span class="lnt"> 13
&lt;/span>&lt;span class="lnt"> 14
&lt;/span>&lt;span class="lnt"> 15
&lt;/span>&lt;span class="lnt"> 16
&lt;/span>&lt;span class="lnt"> 17
&lt;/span>&lt;span class="lnt"> 18
&lt;/span>&lt;span class="lnt"> 19
&lt;/span>&lt;span class="lnt"> 20
&lt;/span>&lt;span class="lnt"> 21
&lt;/span>&lt;span class="lnt"> 22
&lt;/span>&lt;span class="lnt"> 23
&lt;/span>&lt;span class="lnt"> 24
&lt;/span>&lt;span class="lnt"> 25
&lt;/span>&lt;span class="lnt"> 26
&lt;/span>&lt;span class="lnt"> 27
&lt;/span>&lt;span class="lnt"> 28
&lt;/span>&lt;span class="lnt"> 29
&lt;/span>&lt;span class="lnt"> 30
&lt;/span>&lt;span class="lnt"> 31
&lt;/span>&lt;span class="lnt"> 32
&lt;/span>&lt;span class="lnt"> 33
&lt;/span>&lt;span class="lnt"> 34
&lt;/span>&lt;span class="lnt"> 35
&lt;/span>&lt;span class="lnt"> 36
&lt;/span>&lt;span class="lnt"> 37
&lt;/span>&lt;span class="lnt"> 38
&lt;/span>&lt;span class="lnt"> 39
&lt;/span>&lt;span class="lnt"> 40
&lt;/span>&lt;span class="lnt"> 41
&lt;/span>&lt;span class="lnt"> 42
&lt;/span>&lt;span class="lnt"> 43
&lt;/span>&lt;span class="lnt"> 44
&lt;/span>&lt;span class="lnt"> 45
&lt;/span>&lt;span class="lnt"> 46
&lt;/span>&lt;span class="lnt"> 47
&lt;/span>&lt;span class="lnt"> 48
&lt;/span>&lt;span class="lnt"> 49
&lt;/span>&lt;span class="lnt"> 50
&lt;/span>&lt;span class="lnt"> 51
&lt;/span>&lt;span class="lnt"> 52
&lt;/span>&lt;span class="lnt"> 53
&lt;/span>&lt;span class="lnt"> 54
&lt;/span>&lt;span class="lnt"> 55
&lt;/span>&lt;span class="lnt"> 56
&lt;/span>&lt;span class="lnt"> 57
&lt;/span>&lt;span class="lnt"> 58
&lt;/span>&lt;span class="lnt"> 59
&lt;/span>&lt;span class="lnt"> 60
&lt;/span>&lt;span class="lnt"> 61
&lt;/span>&lt;span class="lnt"> 62
&lt;/span>&lt;span class="lnt"> 63
&lt;/span>&lt;span class="lnt"> 64
&lt;/span>&lt;span class="lnt"> 65
&lt;/span>&lt;span class="lnt"> 66
&lt;/span>&lt;span class="lnt"> 67
&lt;/span>&lt;span class="lnt"> 68
&lt;/span>&lt;span class="lnt"> 69
&lt;/span>&lt;span class="lnt"> 70
&lt;/span>&lt;span class="lnt"> 71
&lt;/span>&lt;span class="lnt"> 72
&lt;/span>&lt;span class="lnt"> 73
&lt;/span>&lt;span class="lnt"> 74
&lt;/span>&lt;span class="lnt"> 75
&lt;/span>&lt;span class="lnt"> 76
&lt;/span>&lt;span class="lnt"> 77
&lt;/span>&lt;span class="lnt"> 78
&lt;/span>&lt;span class="lnt"> 79
&lt;/span>&lt;span class="lnt"> 80
&lt;/span>&lt;span class="lnt"> 81
&lt;/span>&lt;span class="lnt"> 82
&lt;/span>&lt;span class="lnt"> 83
&lt;/span>&lt;span class="lnt"> 84
&lt;/span>&lt;span class="lnt"> 85
&lt;/span>&lt;span class="lnt"> 86
&lt;/span>&lt;span class="lnt"> 87
&lt;/span>&lt;span class="lnt"> 88
&lt;/span>&lt;span class="lnt"> 89
&lt;/span>&lt;span class="lnt"> 90
&lt;/span>&lt;span class="lnt"> 91
&lt;/span>&lt;span class="lnt"> 92
&lt;/span>&lt;span class="lnt"> 93
&lt;/span>&lt;span class="lnt"> 94
&lt;/span>&lt;span class="lnt"> 95
&lt;/span>&lt;span class="lnt"> 96
&lt;/span>&lt;span class="lnt"> 97
&lt;/span>&lt;span class="lnt"> 98
&lt;/span>&lt;span class="lnt"> 99
&lt;/span>&lt;span class="lnt">100
&lt;/span>&lt;span class="lnt">101
&lt;/span>&lt;span class="lnt">102
&lt;/span>&lt;span class="lnt">103
&lt;/span>&lt;span class="lnt">104
&lt;/span>&lt;span class="lnt">105
&lt;/span>&lt;span class="lnt">106
&lt;/span>&lt;span class="lnt">107
&lt;/span>&lt;span class="lnt">108
&lt;/span>&lt;span class="lnt">109
&lt;/span>&lt;span class="lnt">110
&lt;/span>&lt;span class="lnt">111
&lt;/span>&lt;span class="lnt">112
&lt;/span>&lt;span class="lnt">113
&lt;/span>&lt;span class="lnt">114
&lt;/span>&lt;span class="lnt">115
&lt;/span>&lt;span class="lnt">116
&lt;/span>&lt;span class="lnt">117
&lt;/span>&lt;span class="lnt">118
&lt;/span>&lt;span class="lnt">119
&lt;/span>&lt;span class="lnt">120
&lt;/span>&lt;span class="lnt">121
&lt;/span>&lt;span class="lnt">122
&lt;/span>&lt;span class="lnt">123
&lt;/span>&lt;span class="lnt">124
&lt;/span>&lt;span class="lnt">125
&lt;/span>&lt;span class="lnt">126
&lt;/span>&lt;span class="lnt">127
&lt;/span>&lt;span class="lnt">128
&lt;/span>&lt;span class="lnt">129
&lt;/span>&lt;span class="lnt">130
&lt;/span>&lt;span class="lnt">131
&lt;/span>&lt;span class="lnt">132
&lt;/span>&lt;span class="lnt">133
&lt;/span>&lt;span class="lnt">134
&lt;/span>&lt;span class="lnt">135
&lt;/span>&lt;span class="lnt">136
&lt;/span>&lt;span class="lnt">137
&lt;/span>&lt;span class="lnt">138
&lt;/span>&lt;span class="lnt">139
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">l2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 5个10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">l3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span> &lt;span class="c1">// 其他容器的迭代器范围初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="n">l4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 拷贝构造
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 尾部插入 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_front&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 头部插入 2 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 3 2 1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop_back&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 尾部删除 3 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop_front&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 头部删除 2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">erase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">());&lt;/span> &lt;span class="c1">//删除迭代器位置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sort&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 必须用成员函数sort，不能用sort(l1.begin(), l1.end())，因为迭代器不支持随机访问
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sort&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">merge&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">l2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 合并两个有序的链表，将l2合并到l1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reverse&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 反转链表
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unique&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 删除链表相邻重复元素，因此需要先排序，否则只删除相邻的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">unique&lt;/span>&lt;span class="p">([](&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="k">return&lt;/span> &lt;span class="nf">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);});&lt;/span> &lt;span class="c1">// 删除相邻绝对值相差小于5的• list和vector
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">```&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="n">list是双向链表&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">vector是数组&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="n">list只能顺序访问&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">vector可以随机访问&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="n">vector插入会导致扩容和迁移&lt;/span>&lt;span class="err">、迭代器失效，&lt;/span>&lt;span class="n">list不会&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="n">vector只有扩容时申请内存&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">list每次插入都需申请内存&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">•&lt;/span> &lt;span class="n">deque双端数组&lt;/span>&lt;span class="err">（队列）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="err">支持快速随机访问，但是没有&lt;/span>&lt;span class="n">vector快&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="err">内部是分段的连续空间，迭代器比&lt;/span>&lt;span class="n">vector复杂&lt;/span>&lt;span class="err">，为了提高效率可以先将内容复制到&lt;/span>&lt;span class="n">vector&lt;/span>&lt;span class="err">，排序后再拷贝回&lt;/span>&lt;span class="n">deque&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="err">底层由多个固定大小的连续内存块组成，通过一个中控数组管理这些缓冲区的指针&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="err">头尾的插入和删除可能涉及到分配新缓冲区，&lt;/span>&lt;span class="n">O1&lt;/span>&lt;span class="err">，中间的插入删除可能涉及缓冲区迁移&lt;/span> &lt;span class="err">，&lt;/span>&lt;span class="n">On&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">```&lt;/span>&lt;span class="n">cpp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">dq&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dq&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_front&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">//也可以emplace，同样原理emplace性能好，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">//push只适合加入现成对象，emplace适合用参数构造
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dq&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dq&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dq&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">back&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dq&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop_front&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dq&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">at&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dq&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">dq2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">dq3&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dq2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">deque&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">dq4&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dq&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">dq&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">```&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">•&lt;/span> &lt;span class="n">stack和queue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="err">是基于&lt;/span>&lt;span class="n">deque的容器适配器&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">push&lt;/span> &lt;span class="err">和&lt;/span> &lt;span class="n">pop&lt;/span> &lt;span class="err">操作均为&lt;/span> &lt;span class="n">O&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">（访问首尾），不能通过迭代器访问&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">```&lt;/span>&lt;span class="n">cpp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;queue&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&lt;/span> &lt;span class="cpf">&amp;lt;stack&amp;gt;&lt;/span>&lt;span class="cp">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="n">stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 入栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 出栈
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">top&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">top&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 获取栈顶元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">bool&lt;/span> &lt;span class="n">isEmpty&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 判断栈是否为空
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">size_t&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 返回元素数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="err">；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 入队元素 10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">emplace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 直接构造元素 20
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 删除队首元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">head&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 获取队首元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">tail&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">back&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="c1">// 获取队尾元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;队列元素数量：&amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 不检查空可能导致未定义行为
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">front&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">q&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;span class="err">```&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">•&lt;/span> &lt;span class="n">heap和priority_queue&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="err">堆是一种完全二叉树，大根堆是每个节点值一定大于子节点，小根堆是每个节点值一定小于子节点。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">◦&lt;/span> &lt;span class="n">heap一般配合vector使用&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">```&lt;/span>&lt;span class="n">cpp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vector&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 默认生成大根堆
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">make_heap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">make_heap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">greater&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">());&lt;/span> &lt;span class="c1">// 小根堆
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 向堆插入元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">push_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">99&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">push_heap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">push_heap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">greater&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">());&lt;/span> &lt;span class="c1">// greater&amp;lt;int&amp;gt;() 需要保持一致
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// 将堆顶元素移动到尾部
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">pop_heap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">pop_back&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 将堆转化为有序序列
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">sort_heap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">```&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="n">priority_queue默认底层容器是vector&lt;/span>&lt;span class="err">，自动维护堆结构（注意不是顺序结构），没有迭代器&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="err">堆的调整算法是&lt;/span>&lt;span class="n">Ologn&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">•&lt;/span> &lt;span class="n">map和set&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="n">map和set底层采用红黑树实现&lt;/span>&lt;span class="err">，红黑树是一种不严格的平衡二叉搜索树，保证最长路径不超过最短路径的两倍，而&lt;/span>&lt;span class="n">AVL是严格的二叉平衡树&lt;/span>&lt;span class="err">。红黑树的旋转操作比较简单，适合有大量插入删除操作的场景，比如&lt;/span>&lt;span class="n">vma的管理&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="err">都是&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="err">的关联容器，只通过接口访问元素，底层都是红黑树实现&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="n">set判断一个元素是否存在&lt;/span>&lt;span class="err">，&lt;/span>&lt;span class="n">mao因是个好&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="err">插入删除查找时间&lt;/span>&lt;span class="n">Ologn&lt;/span>&lt;span class="err">，可以&lt;/span>&lt;span class="n">iter遍历&lt;/span> &lt;span class="n">On&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="n">map不可修改键&lt;/span>&lt;span class="err">，可以修改值；&lt;/span>&lt;span class="n">set不可修改键&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">◦&lt;/span> &lt;span class="err">默认按键升序排列，键唯一&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">```&lt;/span>&lt;span class="n">cpp&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">string&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">make_pair&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s">&amp;#34;Alice&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span> &lt;span class="c1">// 推荐，避免临时对象构造[6](@ref)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">&amp;#34;Bob&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">set&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">auto&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 返回迭代器，未找到返回`end()`[1,6](@ref)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">erase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 按键删除，返回删除元素数量[6](@ref)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">erase&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">());&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">auto&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">cout&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">first&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="s">&amp;#34;: &amp;#34;&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="n">endl&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="k">auto&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="nl">kv&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">m&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">...&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="c1">// 自动解引用为键值对[7](@ref)• unordered_map和unordered_set
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>◦ 哈希表实现，无序关联容器
◦ 插入查找删除复杂度O1&lt;/p>
&lt;h2 id="vector是线程安全的吗">vector是线程安全的吗
&lt;/h2>&lt;p>vector不是线程安全的，多个线程同时修改线程会导致数据竞争。需要锁机制保护。&lt;/p>
&lt;p>线程不安全的情况有：同时修改容器结构，如push_back、insert、erase等；混合读写操作，如一个线程读、另一个线程写同一个元素，或者一个线程读、另一个线程修改容器结构&lt;/p>
&lt;h2 id="泛型编程">泛型编程
&lt;/h2>&lt;p>泛型编程是通过模板机制允许在编写代码时不指定具体的数据类型，而是在编译时根据具体类型生成特定代码，避免重复编程。&lt;/p>
&lt;p>类模板是创建通用类的机制，使用template&lt;T>声明，类内部用T表示通用类型参数，函数模板用于定义通用函数，也是声明然后用T。但是类模板实例化时必须指定类型参数（例如stack&lt;int> s），不能自动推导，函数模板可以根据调用的参数类型自动推导（例如add(3, 5)会生成一个int版本的add）&lt;/p>
&lt;p>全特化是为模板的所有参数指定具体类型，也就是没有用泛型编程，偏特化是部分指定模板参数或者添加类型修饰，如指针和引用。偏特化只适用于类模板，不适合函数模板。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 偏特化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">template&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">typename&lt;/span> &lt;span class="n">T&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Stack&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">*&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 特化为指针类型
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">private&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">T&lt;/span>&lt;span class="o">**&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span>&lt;span class="o">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="n">push&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* 指针特殊处理 */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="类型推导">类型推导
&lt;/h2>&lt;p>auto可以让编译器在编译期推导出变量的类型。必须马上初始化，定义多个变量时不能有二义性，不能用作函数参数，类中不能用作非静态成员变量（非静态成员变量的初始化发生在对象创建时，即构造函数执行阶段，不是编译期。而静态成员需要在类外定义的时候初始化），不能定义数组，可以定义指针，不能推导模板参数。单纯使用auto时推导会忽略引用和cv（const， volatile）限定，也就是推导出对象的原始类型。但是使用auto&amp;amp;或者auto*的时候会保留引用和cv限定&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">crx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">auto&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">crx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// a 是 int（忽略引用和 const）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 合法：a 是普通 int
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// crx = 20; // 非法：crx 是 const 引用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">const&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">crx&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">auto&lt;/span>&lt;span class="o">&amp;amp;&lt;/span> &lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">crx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// b 是 const int&amp;amp;（保留引用和 const）
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// b = 20; // 非法：b 是 const 引用
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>decltype用于推导表达式类型，但是不会计算表达式&lt;/p>
&lt;h2 id="nullptr">nullptr
&lt;/h2>&lt;p>nullptr用来代替NULL，因为NULL就是0。&lt;/p>
&lt;p>void foo(char *c) {}&lt;/p>
&lt;p>void foo(int x) {}参数是指针和整数时重载会有二义性&lt;/p>
&lt;h2 id="ccpp编译流程">C/CPP编译流程
&lt;/h2>&lt;p>编译流程是预处理、编译、汇编、链接&lt;/p>
&lt;p>• 预处理：展开define、包含头文件、条件编译、处理特殊符号等与井号相关的，输出.i文本文件&lt;/p>
&lt;p>• 编译：词法分析、语法分析、语义分析、中间代码生成，并且优化一些处理，如展开循环等。输出.s汇编语言文件&lt;/p>
&lt;p>• 汇编：将汇编代码转换成机器指令，生成符号表记录函数和变量地址等，输出.o可重定位目标文件&lt;/p>
&lt;p>• 链接：通过调整代码和数据的相对位置生成最终的内存布局，将静态链接嵌入可执行文件，动态链接仅记录映射信息，在运行时加载共享库。输出可执行文件&lt;/p>
&lt;h2 id="静态链接-vs-动态链接">静态链接 vs 动态链接
&lt;/h2>&lt;p>静态链接将库文件嵌入可执行文件中，因此每个程序包含副本，占用空间大。动态链接共享库的副本没节省空间。静态链接更新需要重新编译整个程序，但是动态链接只需要替换库文件。静态链接运行更快，动态链接需要运行时加载，静态链接没有外部依赖，动态链接需要保证库文件存在且版本兼容。&lt;/p>
&lt;h2 id="undefined-reference">undefined reference
&lt;/h2>&lt;p>属于链接阶段错误，表示编译器在链接时找不到函数或变量的具体实现。可能是缺少某些库文件或者目标文件，或者库之间有依赖关系而连接顺序错误，或者函数变量声明与定义不一致&lt;/p></description></item><item><title>Linux IO 系统调用专题</title><link>https://realcedriccheng.github.io/p/linuxio/</link><pubDate>Mon, 07 Apr 2025 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/linuxio/</guid><description>&lt;p>&lt;a class="link" href="https://arthurchiao.art/blog/intro-to-io-uring-zh/" target="_blank" rel="noopener"
>https://arthurchiao.art/blog/intro-to-io-uring-zh/&lt;/a>&lt;/p>
&lt;p>• How io_uring and eBPF Will Revolutionize Programming in Linux, ScyllaDB, 2020
• An Introduction to the io_uring Asynchronous I/O Framework, Oracle, 2020&lt;/p>
&lt;p>io_uring 是 2019 年 Linux 5.1 内核首次引入的高性能异步 I/O 框架，能显著加速 I/O 密集型应用的性能。
但如果你的应用已经在使用 传统 Linux AIO 了，并且使用方式恰当，那 io_uring并不会带来太大的性能提升 —— 根据原文测试（以及我们自己的复现），即便打开高级特性，也只有 5%。除非你真的需要这 5% 的额外性能，否则切换成 io_uring代价可能也挺大，因为要重写应用来适配 io_uring（或者让依赖的平台或框架去适配，总之需要改代码）。&lt;/p>
&lt;p>既然性能跟传统 AIO 差不多，那为什么还称 io_uring 为革命性技术呢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>它首先和最大的贡献在于：统一了 Linux 异步 I/O 框架，
◦ Linux AIO 只支持 direct I/O 模式的存储文件（storage file），而且主要用在数据库这一细分领域；
◦ io_uring 支持存储文件和网络文件（network sockets），也支持更多的异步系统调用
（accept/openat/stat/&amp;hellip;），而非仅限于 read/write 系统调用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在设计上是真正的异步 I/O，作为对比，Linux AIO 虽然也是异步的，但仍然可能会阻塞，某些情况下的行为也无法预测；&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>似乎之前 Windows 在这块反而是领先的，更多参考：
◦ 浅析开源项目之 io_uring，“分步试存储”专栏，知乎
◦ Is there really no asynchronous block I/O on Linux?，stackoverflow&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>灵活性和可扩展性非常好，甚至能基于 io_uring 重写所有系统调用，而 Linux AIO 设计时就没考虑扩展性。
eBPF 也算是异步框架（事件驱动），但与 io_uring 没有本质联系，二者属于不同子系统，并且在模型上有一个本质区别：eBPF 对用户是透明的，只需升级内核（到合适的版本），应用程序无需任何改造；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>io_uring 提供了新的系统调用和用户空间 API，因此需要应用程序做改造。
eBPF 作为动态跟踪工具，能够更方便地排查和观测 io_uring 等模块在执行层面的具体问题。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>本文介绍 Linux 异步 I/O 的发展历史，io_uring 的原理和功能，并给出了一些程序示例和性能压测结果（我们在 5.10内核做了类似测试，结论与原文差不多）。&lt;/p>
&lt;p>很多人可能还没意识到，Linux 内核在过去几年已经发生了一场革命。这场革命源于两个激动人心的新接口的引入：eBPF 和 io_uring。&lt;/p>
&lt;p>我们认为，二者将会完全改变应用与内核交互的方式，以及应用开发者思考和看待内核的方式。&lt;/p>
&lt;p>本文介绍 io_uring（我们在 ScyllaDB 中有 io_uring 的深入使用经验），并略微提及一下 eBPF。&lt;/p>
&lt;p>1 Linux I/O 系统调用演进&lt;/p>
&lt;p>1.1 基于 fd 的阻塞式 I/O：read()/write()&lt;/p>
&lt;p>作为大家最熟悉的读写方式，Linux 内核提供了基于文件描述符的系统调用，这些描述符指向的可能是存储文件（storage file），也可能是 network sockets：
ssize_t read(int fd,void* buf,size_t count);
ssize_t write(int fd,const void* buf,size_t count);二者称为阻塞式系统调用（blocking system calls），因为程序调用这些函数时会进入 sleep 状态，然后被调度出去（让出处理器），直到 I/O 操作完成：
• 如果数据在文件中，并且文件内容已经缓存在 page cache 中，调用会立即返回；
• 如果数据在另一台机器上，就需要通过网络（例如 TCP）获取，会阻塞一段时间；
• 如果数据在硬盘上，也会阻塞一段时间。
但很容易想到，随着存储设备越来越快，程序越来越复杂，阻塞式（blocking）已经这种最简单的方式已经不适用了。&lt;/p>
&lt;p>1.2 非阻塞式 I/O：select()/poll()/epoll()
阻塞式之后，出现了一些新的、非阻塞的系统调用，例如 select()、poll() 以及更新的 epoll()。&lt;/p>
&lt;p>应用程序在调用这些函数读写时不会阻塞，而是立即返回，返回的是一个已经 ready 的文件描述符列表。&lt;/p>
&lt;p>但这种方式存在一个致命缺点：只支持 network sockets 和 pipes ——epoll() 甚至连 storage files 都不支持。&lt;/p>
&lt;p>1.3 线程池方式
对于 storage I/O，经典的解决思路是 thread pool：主线程将 I/O 分发给 worker 线程，后者代替主线程进行阻塞式读写，主线程不会阻塞。&lt;/p>
&lt;p>这种方式的问题是线程上下文切换开销可能非常大，后面性能压测会看到。&lt;/p>
&lt;p>1.4 Direct I/O（数据库软件）：绕过 page cache
随后出现了更加灵活和强大的方式：数据库软件（database software）有时 并不想使用操作系统的 page cache，而是希望打开一个文件后，直接从设备读写这个文件（direct access to the device）。这种方式称为直接访问（direct access）或直接 I/O（direct I/O），&lt;/p>
&lt;p>• 需要指定 O_DIRECT flag；
• 需要应用自己管理自己的缓存 —— 这正是数据库软件所希望的；
• 是 zero-copy I/O，因为应用的缓冲数据直接发送到设备，或者直接从设备读取。&lt;/p>
&lt;p>1.5 异步 IO（AIO）
前面提到，随着存储设备越来越快，主线程和 worker 线性之间的上下文切换开销占比越来越高。&lt;/p>
&lt;p>现在市场上的一些设备，例如 Intel Optane，延迟已经低到和上下文切换一个量级（微秒 us）。换个方式描述，更能让我们感受到这种开销：上下文每切换一次，我们就少一次 dispatch I/O 的机会。&lt;/p>
&lt;p>因此，Linux 2.6 内核引入了异步 I/O（asynchronous I/O）接口，&lt;/p>
&lt;p>方便起见，本文简写为 linux-aio。AIO 原理是很简单的：&lt;/p>
&lt;p>• 用户通过 io_submit() 提交 I/O 请求，&lt;/p>
&lt;p>• 过一会再调用 io_getevents() 来检查哪些 events 已经 ready 了。&lt;/p>
&lt;p>• 使程序员能编写完全异步的代码。&lt;/p>
&lt;p>近期，Linux AIO 甚至支持了epoll()：也就是说不仅能提交 storage I/O 请求，还能提交网络 I/O 请求。照这样发展下去，linux-aio似乎能成为一个王者。但由于它糟糕的演进之路，这个愿望几乎不可能实现了。&lt;/p>
&lt;p>Linux AIO 确实问题缠身，&lt;/p>
&lt;ol>
&lt;li>
&lt;p>只支持 O_DIRECT 文件，因此对常规的非数据库应用 （normal, non-database applications）几乎是无用的；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接口在设计时并未考虑扩展性。虽然可以扩展 —— 我们也确实这么做了 —— 但每加一个东西都相当复杂；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>虽然从技术上说接口是非阻塞的，但实际上有 很多可能的原因都会导致它阻塞，而且引发的方式难以预料。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>1.6 小结&lt;/p>
&lt;p>以上可以清晰地看出 Linux I/O 的演进：&lt;/p>
&lt;p>• 最开始是同步（阻塞式）系统调用；&lt;/p>
&lt;p>• 然后随着实际需求和具体场景，不断加入新的异步接口，还要保持与老接口的兼容和协同工作。&lt;/p>
&lt;p>另外也看到，在非阻塞式读写的问题上并没有形成统一方案：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Network socket 领域：添加一个异步接口，然后去轮询（poll）请求是否完成（readiness）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Storage I/O 领域：只针对某一细分领域（数据库）在某一特定时期的需求，添加了一个定制版的异步接口。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这就是 Linux I/O 的演进历史 —— 只着眼当前，出现一个问题就引入一种设计，而并没有多少前瞻性 —— 直到 io_uring 的出现。&lt;/p>
&lt;p>2 io_uring&lt;/p>
&lt;p>io_uring 来自资深内核开发者 Jens Axboe 的想法，他在 Linux I/O stack 领域颇有研究。&lt;/p>
&lt;p>从最早的 patch aio: support for IO polling可以看出，这项工作始于一个很简单的观察：随着设备越来越快，中断驱动（interrupt-driven）模式效率已经低于轮询模式（polling for completions） —— 这也是高性能领域最常见的主题之一。&lt;/p>
&lt;p>• io_uring 的基本逻辑与 linux-aio 是类似的：提供两个接口，一个将I/O 请求提交到内核，一个从内核接收完成事件。&lt;/p>
&lt;p>• 但随着开发深入，它逐渐变成了一个完全不同的接口：设计者开始从源头思考如何支持完全异步的操作。&lt;/p>
&lt;p>2.1 与 Linux AIO 的不同&lt;/p>
&lt;p>io_uring 与 linux-aio 有着本质的不同：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在设计上是真正异步的（truly asynchronous）。只要设置了合适的 flag，它在系统调用上下文中就只是将请求放入队列，不会做其他任何额外的事情，保证了应用永远不会阻塞。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持任何类型的 I/O：cached files、direct-access files 甚至 blocking sockets。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>由于设计上就是异步的（async-by-design nature），因此无需 poll+read/write 来处理 sockets。&lt;/p>
&lt;p>只需提交一个阻塞式读（blocking read），请求完成之后，就会出现在 completion ring。&lt;/p>
&lt;ol start="3">
&lt;li>灵活、可扩展：基于 io_uring 甚至能重写（re-implement）Linux 的每个系统调用。&lt;/li>
&lt;/ol>
&lt;p>2.2 原理及核心数据结构：SQ/CQ/SQE/CQE&lt;/p>
&lt;p>每个 io_uring 实例都有两个环形队列（ring），在内核和应用程序之间共享：&lt;/p>
&lt;p>• 提交队列：submission queue (SQ)&lt;/p>
&lt;p>• 完成队列：completion queue (CQ)&lt;/p>
&lt;p>这两个队列：&lt;/p>
&lt;p>• 都是单生产者、单消费者，size 是 2 的幂次；&lt;/p>
&lt;p>• 提供无锁接口（lock-less access interface），内部使用内存屏障做同步（coordinated with memory barriers）。&lt;/p>
&lt;p>使用方式：&lt;/p>
&lt;p>• 请求&lt;/p>
&lt;pre>&lt;code>◦ 应用创建 SQ entries (SQE)，更新 SQ tail；
◦ 内核消费 SQE，更新 SQ head。
&lt;/code>&lt;/pre>
&lt;p>• 完成&lt;/p>
&lt;pre>&lt;code>◦ 内核为完成的一个或多个请求创建 CQ entries (CQE)，更新 CQ tail；
◦ 应用消费 CQE，更新 CQ head。
◦ 完成事件（completion events）可能以任意顺序到达，到总是与特定的 SQE 相关联的。
◦ 消费 CQE 过程无需切换到内核态。
&lt;/code>&lt;/pre>
&lt;p>2.3 带来的好处&lt;/p>
&lt;p>io_uring 这种请求方式还有一个好处是：原来需要多次系统调用（读或写），现在变成批处理一次提交。&lt;/p>
&lt;p>还记得 Meltdown 漏洞吗？当时我还写了一篇文章解释为什么我们的 Scylla NoSQL 数据库受影响很小：aio 已经将我们的 I/O 系统调用批处理化了。&lt;/p>
&lt;p>io_uring将这种批处理能力带给了 storage I/O 系统调用之外的其他一些系统调用，包括：&lt;/p>
&lt;p>• read&lt;/p>
&lt;p>• write&lt;/p>
&lt;p>• send&lt;/p>
&lt;p>• recv&lt;/p>
&lt;p>• accept&lt;/p>
&lt;p>• openat&lt;/p>
&lt;p>• stat&lt;/p>
&lt;p>• 专用的一些系统调用，例如 fallocate&lt;/p>
&lt;p>此外，io_uring 使异步 I/O 的使用场景也不再仅限于数据库应用，普通的非数据库应用也能用。这一点值得重复一遍：&lt;/p>
&lt;p>虽然 io_uring 与 aio 有一些相似之处，但它的扩展性和架构是革命性的：&lt;/p>
&lt;p>它将异步操作的强大能力带给了所有应用（及其开发者），而不再仅限于是数据库应用这一细分领域。&lt;/p>
&lt;p>我们的 CTO Avi Kivity 在 the Core C++ 2019 event 上 有一次关于 async 的分享。&lt;/p>
&lt;p>核心点包括：从延迟上来说，&lt;/p>
&lt;ol>
&lt;li>
&lt;p>现代多核、多 CPU 设备，其内部本身就是一个基础网络；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU 之间是另一个网络；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU 和磁盘 I/O 之间又是一个网络。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>因此网络编程采用异步是明智的，而现在开发自己的应用也应该考虑异步。&lt;/p>
&lt;p>这从根本上改变了 Linux 应用的设计方式：&lt;/p>
&lt;p>• 之前都是一段顺序代码流，需要系统调用时才执行系统调用，&lt;/p>
&lt;p>• 现在需要思考一个文件是否 ready，因而自然地引入 event-loop，不断通过共享 buffer 提交请求和接收结果。&lt;/p>
&lt;p>2.4 三种工作模式&lt;/p>
&lt;p>io_uring 实例可工作在三种模式：&lt;/p>
&lt;ol>
&lt;li>中断驱动模式（interrupt driven）&lt;/li>
&lt;/ol>
&lt;p>默认模式。可通过 io_uring_enter() 提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。&lt;/p>
&lt;ol start="2">
&lt;li>轮询模式（polled）&lt;/li>
&lt;/ol>
&lt;p>Busy-waiting for an I/O completion，而不是通过异步 IRQ（Interrupt Request）接收通知。&lt;/p>
&lt;p>这种模式需要文件系统（如果有）和块设备（block device）支持轮询功能。&lt;/p>
&lt;p>相比中断驱动方式，这种方式延迟更低（连系统调用都省了）， 但可能会消耗更多 CPU 资源。&lt;/p>
&lt;p>目前，只有指定了 O_DIRECT flag 打开的文件描述符，才能使用这种模式。当一个读或写请求提交给轮询上下文（polled context）之后，应用（application）必须调用 io_uring_enter() 来轮询 CQ 队列，判断请求是否已经完成。&lt;/p>
&lt;p>对一个 io_uring 实例来说，不支持混合使用轮询和非轮询模式。&lt;/p>
&lt;ol start="3">
&lt;li>内核轮询模式（kernel polled）&lt;/li>
&lt;/ol>
&lt;p>这种模式中，会 创建一个内核线程（kernel thread）来执行 SQ 的轮询工作。&lt;/p>
&lt;p>使用这种模式的 io_uring 实例， 应用无需切到到内核态 就能触发（issue）I/O 操作。&lt;/p>
&lt;p>通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I/O（submit and reap I/Os）。&lt;/p>
&lt;p>如果内核线程的空闲时间超过了用户的配置值，它会通知应用，然后进入 idle 状态。&lt;/p>
&lt;p>这种情况下，应用必须调用 io_uring_enter() 来唤醒内核线程。如果 I/O 一直很繁忙，内核线性是不会 sleep 的。&lt;/p>
&lt;p>后面略&lt;/p></description></item><item><title>操作系统理论知识</title><link>https://realcedriccheng.github.io/p/caozuoxitong/</link><pubDate>Mon, 07 Apr 2025 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/caozuoxitong/</guid><description>&lt;h2 id="操作系统结构">操作系统结构
&lt;/h2>&lt;h3 id="操作系统内核">操作系统内核
&lt;/h3>&lt;p>内核负责抽象并管理硬件设备，应用程序只需要直接交互内核，不需要关心硬件的具体实现。&lt;/p>
&lt;p>内核的功能有进程管理、内存管理、硬件设备管理和向应用程序提供服务（系统调用）。&lt;/p>
&lt;h3 id="宏内核和微内核">宏内核和微内核
&lt;/h3>&lt;p>宏内核结构中，内核的所有功能，如进程管理、内存管理、文件系统、硬件管理都在内核态中运行。不过，linux可以动态加载内核模块，比如设备驱动等可以动态加载。&lt;/p>
&lt;p>微内核架构中，内核只保留最基本的能力，如进程调度、进程间通信、内存管理等。将其他功能放到用户空间，因此将不同服务隔离，单个服务出现故障或遭受攻击不会影响其他服务。&lt;/p>
&lt;p>混合类型内核是一种大一些的微内核，将部分开销大的关键服务，如文件系统、网络协议栈放回内核态，以减少用户态和内核态之间的切换开销。是一种折中方案&lt;/p>
&lt;p>宏内核：内核态模块之间交互方便，驱动直接交互硬件延迟低。但是模块耦合度高，单个模块故障或受攻击可能导致系统级故障，且维护更新难度大，不易扩展。&lt;/p>
&lt;p>微内核：一个服务崩溃不会影响其他服务，容易动态加载更新和扩展；但是需要频繁进程间通信和上下文切换（访问硬件时），需要设计复杂的消息传递机制&lt;/p>
&lt;p>混合内核：将图形驱动等系统调用频繁的功能放在内核态减少切换开销。比微内核的通信和切换开销小，比宏内核更灵活。&lt;/p>
&lt;h2 id="硬件结构">硬件结构
&lt;/h2>&lt;h3 id="图灵机和冯诺依曼模型">图灵机和冯诺依曼模型
&lt;/h3>&lt;p>图灵机模型：由纸带和读写头组成。纸带相当于内存，读写头上有计算、存储单元（寄存器）和控制单元。在纸带上写入1、2、+，对于数字，读写头按照顺序读入到存储单元中。读取到+时，控制单元发现是运算符，就按照运算操作计算存储单元中的数字，并将结果放到存储单元中。最后将结果写到纸带上。&lt;/p>
&lt;p>冯诺依曼模型基于图灵机的设计：将计算机分为运算器、控制器、存储器、输入设备、输出设备。其中运算器和控制器在CPU中，存储器、输入输出设备通过总线连接到CPU。&lt;/p>
&lt;p>常见的寄存器有通用寄存器（参与计算的操作数）、程序计数器（指向下一条指令的地址）、指令寄存器（存放当前执行的指令本身）&lt;/p>
&lt;p>总线一般分为数据总线、地址总线和控制总线&lt;/p>
&lt;p>CPU位宽尽量不要小于总线位宽，否则32位CPU计算64为数据，需要分高低位计算，效率低。&lt;/p>
&lt;p>CPU采用4级流水线，4个阶段是取指、译码、执行、回写。统称为指令周期。&lt;/p>
&lt;p>CPU的时钟频率，如1GHz代表1秒产生1G次脉冲信号，倒数是时钟周期。一个时钟周期不一定能执行完一条指令，如乘法指令和加法指令都是一条指令，但乘法比加法慢得多。&lt;/p>
&lt;p>CPU的执行时间=时钟周期数&lt;em>时钟周期时间=指令数&lt;/em>CPI(指令的平均时钟周期数)*时钟周期时间&lt;/p>
&lt;p>优化：编译器优化 - 减少指令数；CPU架构优化 - 流水线 - CPI；超频 - 减少时钟周期时间（散热压力大，容易崩溃）&lt;/p>
&lt;h3 id="32位和64位">32位和64位
&lt;/h3>&lt;p>32位计算机一次只能计算32位数据，超过32位需要分高低位计算，而64位计算机一次可以计算64位数据。32位计算机一般地址总线也是32位，因此只能寻址4G。64位计算机一般可以寻址48位。&lt;/p>
&lt;p>从数据计算的角度，如果需要计算的数据不超过32位，则64位没有优势。&lt;/p>
&lt;p>对于软件，32位和64位是指令格式的区别。32位的软件可以以兼容模式运行在64位电脑上，但64位软件无法运行在32位电脑上。&lt;/p>
&lt;h3 id="缓存命中">缓存命中
&lt;/h3>&lt;p>对于2维数组，按行遍历比按列遍历块，因为一行是连续的，一列不是连续的。连续的可以预读命中。&lt;/p>
&lt;p>计算密集型线程可以绑定到某一个CPU核心上，避免缓存命中率下降，因为不同的核心有不同的缓存。&lt;/p>
&lt;h3 id="缓存一致性">缓存一致性
&lt;/h3>&lt;p>多核心有不同的cache，一个核心修改数据后写到cache，但还未写回。导致不同核心无法读取到最新的数据，这叫缓存不一致。&lt;/p>
&lt;p>解决缓存一致性：写传播+事务串行化&lt;/p>
&lt;p>• 写传播：每个CPU更新缓存后，必须同步到其他cache
• 事务串行化：保证不同核心收到同步的顺序相同，如A、B都修改了某一变量，则所有核心都应该先收到A的修改然后收到B的修改，或者反过来。需要引入锁机制。&lt;/p>
&lt;p>基于总线嗅探的MESI协议：总线嗅探就是每个核心监听总线上是否有核心广播自己修改了cache，从而实现写传播。MESI是4个状态缩写，即已修改、独占、共享、失效。已修改是一种脏标记，表示已经修改缓存项但还未写回内存。失效代表缓存项已经失效，不能读取。独占和共享代表缓存项是干净的，独占是数据指缓存在一个CPU的cache中，因此修改了不需要广播。共享代表缓存项存在多个核心的cache中，修改之前必须先广播一个请求，将其他cache中该项置为无效，然后更新当前缓存，并将当前缓存标记为已修改。读取失效缓存项需要先检查其他核心cache是否有副本，没有则读主存。&lt;/p>
&lt;p>伪共享问题：多个线程看似操作不同变量，但是由于这些变量存储在同一缓存行中，一个变量的修改会影响同一缓存行的其他变量，导致缓存行频繁失效 。因此需要将高频修改的变量与其他变量隔离。&lt;/p>
&lt;h3 id="补码小数">补码、小数
&lt;/h3>&lt;p>负数用补码表示是为了和正数统一加减法操作。十进制转换为二进制用除二取余法，二进制转换为十进制用乘二取整法。&lt;/p>
&lt;p>计算机以浮点数形式存储小数，包含符号位、指数位（小数点在数据中的位置）、尾数位（小数点右侧数字）尾数长度决定数的精度。单精度是32位（尾数23位），双精度是64位（尾数52位）。&lt;/p>
&lt;p>0.1+0.2！=0.3是因为小数无法用完整的二进制表示，必须根据精度舍入。因此浮点数存储的是近似值，不能直接比较，必须使用误差范围比较。金融场景必须用高精度库。&lt;/p>
&lt;h2 id="内存管理">内存管理
&lt;/h2>&lt;h3 id="内存是与cpu直接交换数据的存储器">内存是与CPU直接交换数据的存储器
&lt;/h3>&lt;p>冯诺依曼体系的计算机是存算分离的，也就是数据放置在内存上。计算时加载到CPU的寄存器中，计算结束后把结果输出到内存上。&lt;/p>
&lt;p>与CPU越接近的存储器，读写速度必须越快，否则会导致CPU等待IO时间长，影响CPU效率。然而对于存储器来说，一般越快的存储器，容量越小，价格越高。另一方面，快速存储器常常是易失性的，也就是掉电数据就没有了，比如寄存器，SRAM，DRAM等；而非易失性的存储器往往比较慢，比如磁盘，磁带等。当然，也有非易失性的内存，但是并不常用。&lt;/p>
&lt;p>因此，CPU只操作内存数据，任何外存上的数据都必须先加载进内存，然后才能被CPU加载到寄存器。&lt;/p>
&lt;h3 id="存储的金字塔层次结构">存储的金字塔层次结构
&lt;/h3>&lt;p>因此，现代计算机系统会有一个金字塔型的存储结构，由上到下依次是寄存器（一个CPU时钟周期，纳秒级）、L1、2、3级缓存（SRAM，几十个时钟周期，纳秒级）、内存（DRAM，百纳秒级别）、外存（HDD、SSD、磁带、光盘等，SSD的读延迟在几十微秒，写延迟在几毫秒；HDD的读写延迟在十几毫秒）、远程存储（分布式文件系统、服务器，延迟取决于网络连接）。&lt;/p>
&lt;p>每一层都可以看做是下一层的缓存，根据局部性原理，这样可以使得存储系统在性能上接近金字塔上层，在容量和价格上接近金字塔下层。&lt;/p>
&lt;h3 id="内存需要操作系统管理">内存需要操作系统管理
&lt;/h3>&lt;p>如果操作系统不提供内存的管理，程序员就必须使用绝对物理地址，会出现两个问题：&lt;/p>
&lt;ol>
&lt;li>编写程序低效：程序员必须手动管理内存，保证自己的程序能够独占一段内存。&lt;/li>
&lt;li>不安全：每个进程都有可能访问到其他进程的数据，缺乏隔离性。&lt;/li>
&lt;/ol>
&lt;h3 id="虚拟内存是操作系统给每个进程提供的独立连续地址空间">虚拟内存是操作系统给每个进程提供的独立连续地址空间
&lt;/h3>&lt;p>为了高效安全编写程序，引入虚拟内存的概念。&lt;/p>
&lt;p>操作系统给每个进程都提供一个独立、连续的虚拟地址空间。空间的大小由地址长度决定，例如，32位机器上进程地址空间为4G，用户态3G，内核态1G；64位机器上由于地址空间太大，进程只用其中48位，就是内核态、用户态各128TB。注意内核态的地址空间是各个内核进程共享的，task_struct中的mm_struct用于管理虚拟地址空间，mm_struct中的task_size用于定义内核态与用户态的分界线（地址值）。&lt;/p>
&lt;p>虚拟地址空间可以比真实物理内存更大，这是基于局部性原理，认为每个进程在最近一段时间更可能反复使用一部分页面。多余的页面如果分配了就交换到外存。&lt;/p>
&lt;p>虚拟地址空间按一定的方式映射到物理地址上，有分段、分页、段页式。Linux采用多级页表管理。&lt;/p>
&lt;p>虚拟内存具有隔离性，解决了编程效率和安全性问题：每个进程认为自己独占内存空间，不用担心内存分配的问题，也不用管理页面的物理布局；每个进程只能访问自己的地址空间，不能访问其他地址空间，因此免受恶意进程或故障进程的破坏。&lt;/p>
&lt;p>但是，内核态进程都是共享地址空间的。从高效和安全两个方面来分析：&lt;/p>
&lt;p>• 操作系统内核是操作系统开发人员精心设计的，了解内核地址布局，通过锁和信号量等机制确保了不会产生数据竞争问题。反而隔离内核态进程会导致进程通信的开销，妨碍内核的高效实现。
• 内核态的进程执行的代码是操作系统本身提供的，因此认为不会有恶意。&lt;/p>
&lt;p>缺点在于内核也是有漏洞的，病毒程序可能利用操作系统内核漏洞发起攻击。&lt;/p>
&lt;h3 id="分段机制导致内外碎片需要频繁交换和紧凑">分段机制导致内外碎片，需要频繁交换和紧凑
&lt;/h3>&lt;p>分段机制是一种内存管理机制，原理是将虚拟地址空间分为若干段，例如代码段、数据段等。每个段独立映射到物理内存上的一段空间，通过段基址加偏移量索引段内内容。&lt;/p>
&lt;p>可以实现物理内存的离散分配，但是会导致外碎片，也就是多个段之间的空闲空间是分散的，即使总大小足够分配也无法分配。其次，我认为分段机制也有内碎片问题，比如应用程序不一定需要一个段这么大，并且可能本来是需要的，后来因为某些原因释放了，但是段内的空间又无法分配给别的程序使用。&lt;/p>
&lt;p>因此需要频繁紧凑，也就是挪动段的位置让他们相邻。具体是先将原来段占用的内存写回磁盘，然后再装载回紧跟着另一个段的地方。&lt;/p>
&lt;h3 id="分页机制有内碎片无外碎片交换效率高">分页机制有内碎片无外碎片，交换效率高
&lt;/h3>&lt;p>分页机制是将虚拟地址空间和物理地址空间都划分为一系列大小相同的页，页的大小一般是4K，但是也有大页。操作系统将这些虚拟页映射到物理页上，这些物理页可以是离散的，从而不需要分配连续的物理内存空间。因此没有外碎片问题。&lt;/p>
&lt;p>但是进程可能不需要一个页，例如只需要几百字节，却也必须分配4K。但是页本身是比较小的，因此内碎片总体来看开销小。换出时也仅需要换出部分页，而不是一整个段，交换效率高。&lt;/p>
&lt;p>分页机制还允许进程无需一次性将所有内容加载进内存，只有需要用到的时候再载入。&lt;/p>
&lt;p>单级页表导致页表太大，造成内存开销。Linux采用多级页表机制减少页表大小。原理是如果用不到某个上级页表的表项，就不需要创建下级页表。也就是说不用覆盖整个虚拟地址空间。&lt;/p>
&lt;h3 id="虚拟地址通过mmu映射到物理地址">虚拟地址通过MMU映射到物理地址
&lt;/h3>&lt;p>&lt;a class="link" href="https://blog.csdn.net/lyndon_li/article/details/135392221" target="_blank" rel="noopener"
>https://blog.csdn.net/lyndon_li/article/details/135392221&lt;/a>
&lt;a class="link" href="https://juejin.cn/post/7269276349654155275#heading-15" target="_blank" rel="noopener"
>https://juejin.cn/post/7269276349654155275#heading-15&lt;/a>&lt;/p>
&lt;p>MMU是CPU内部的单元，专门用于虚拟地址到物理地址的翻译。&lt;/p>
&lt;p>在多级页表模式下，页表本身也是放在内存中的，页表中的条目称为页表项，页表项包括该虚拟页的物理页帧号（PPN）、该页是否为脏页、保护权限等信息。查询页表项可以得到虚拟页的物理页框号，和虚拟地址的页内偏移量一起可以组成物理内存的地址。&lt;/p>
&lt;p>虚拟地址分为虚拟页号和页内偏移量两部分。虚拟页号用于定位虚拟页所在页表的页表项，页内偏移量用于和物理页框号组成物理地址。这是因为内存页通常是4KB的，而地址是按字节寻址的。因此某个地址会在所在内存页的某个偏移量处。而物理页和虚拟页的偏移量是相同的。&lt;/p>
&lt;p>在多级页表模式下，虚拟页号也可分为多个部分，如常见的4级页表分为PGD、PUD、PMD和PTE。只要知道PGD的物理内存地址，就可以通过虚拟页号的各部分一直查到物理页框号。&lt;/p>
&lt;p>每个进程的虚拟地址空间是独立的，也就意味着每个进程有自己的页表。在Linux中，页表基地址保存在进程结构体task_struct下用来表示地址空间的mm_struct中的pgd，MMU在翻译某个进程的地址之前，先将该进程的页表基址加载到页表基址寄存器上。&lt;/p>
&lt;p>TLB是CPU中的一种高速缓存，专门用于存放地址转换的映射，命中后就不用逐级查询页表了。因为高速缓存采用SRAM，延迟就是几个时钟周期，但是内存是DRAM，一次访问内存需要几百个时钟周期，更不用说逐级查询了。&lt;/p>
&lt;h3 id="内存大页">内存大页
&lt;/h3>&lt;p>内存大页是指内存页的大小不止4K，有可能是2M甚至更大。&lt;/p>
&lt;p>大页的作用在于减少页表层级和表项数目，更容易在TLB中命中，加快地址转换过程，并且可以减少缺页异常。例如，应用需要2M内存，直接分配一个大页就够了。&lt;/p>
&lt;p>大页的缺点在于存在空间浪费，因为程序未必需要一个大页的大小。其次，对于局部性很好的应用来说并不能改善性能。&lt;/p>
&lt;p>大页需要大段的连续物理内存，由于系统长时间运行后会产生碎片，很难找到连续大段物理内存，因此会在系统启动时分配足够的大页内存，放在大页内存池中。&lt;/p>
&lt;p>大页内存池是锁定的，不能分配给其他虚拟页，也不允许换出。大页内存池耗尽之后无法分配大页。&lt;/p>
&lt;h3 id="linux整个都是一个段">Linux整个都是一个段
&lt;/h3>&lt;p>Linux本来想用分页管理，但是由于英特尔处理器的历史原因必须有段机制，因此就把整个地址空间看成一个大段，相当于没有用段机制。&lt;/p>
&lt;h3 id="mm_struct是进程管理虚拟内存空间的结构体">mm_struct是进程管理虚拟内存空间的结构体
&lt;/h3>&lt;p>每个进程由进程控制块管理，在Linux中进程控制块是task_struct结构体。&lt;/p>
&lt;p>进程控制块中用于管理虚拟内存空间的是mm_struct结构体，由于不同线程共享地址空间，因此线程共享mm_struct结构体。进程和线程都是task_struct，进程和线程的唯一区别是有没有独立的地址空间。&lt;/p>
&lt;p>注意，不同的线程并不共享栈，因此线程的栈指针并不在mm_struct中。与线程有关的资源应该保存在一个叫thread_union的结构体中，里面有线程的栈和寄存器等相关资源。task_struct通过一个宏可以找到thread_union。&lt;/p>
&lt;p>内核栈也不在mm_struct中，而是在task_struct-&amp;gt;stack。&lt;/p>
&lt;h3 id="vma表示一段连续的虚拟地址范围">VMA表示一段连续的虚拟地址范围
&lt;/h3>&lt;p>vm_area_struct（VMA）是用于描述和管理进程虚拟内存空间的结构体，每一个task_struct使用mm_struct结构体管理进程的虚拟地址空间，每个VMA代表一段连续的虚拟地址空间，mm_struct通过VMA链表管理所有用到的虚拟地址空间。&lt;/p>
&lt;p>VMA同时以红黑树的形式组织，mm_struct有指向链表的头指针mmap和红黑树的根节点mm_rb。VMA在链表中顺序串联，在红黑树中可以高效查找。
• 应用可能频繁申请内存空间，有大量的VMA，红黑树方便增删改查，平均时间复杂度为Ologn。
• 链表方便遍历VMA（比如用户通过proc/pid/maps文件查看虚拟内存使用情况时），红黑树则要用栈或者递归，有空间复杂度。&lt;/p>
&lt;p>VMA中包括区域的起始地址、结束地址、上一个和下一个VMA的指针（形成链表）、用于连接到红黑树的成员、所属的mm_struct、访问权限、操作函数集等。&lt;/p>
&lt;h3 id="进程的虚拟地址空间布局">进程的虚拟地址空间布局
&lt;/h3>&lt;p>32位地址按3G/1G划分用户和内核虚拟地址空间&lt;/p>
&lt;p>32位地址的最大寻址范围是4G，按照3：1划分。64位地址则是用户态内核态各占128T，中间还有很大的空洞canonical space，可以根据地址头部快速判断是用户态还是内核态。&lt;/p>
&lt;h4 id="用户态虚拟空间布局">用户态虚拟空间布局
&lt;/h4>&lt;p>进程用户态虚拟地址空间的布局是代码段、数据段、bss段、堆、文件映射与匿名映射区、栈。各区域的起始地址在mm_struct中。&lt;/p>
&lt;h4 id="内核态虚拟空间布局">内核态虚拟空间布局
&lt;/h4>&lt;p>32位内核态虚拟空间只有1G，因此要精打细算使用&lt;/p>
&lt;p>• 直接映射区占用896M：直接映射到0-896M的物理内存空间上
◦ 前16M：DMA区域，以前ISA总线的DMA控制器只能使用物理内存的前16M
◦ 普通区域：内核代码段、数据段、BSS段、进程相关数据结构、内核栈（非常小且固定，溢出危害巨大）
• 高端内存：128M动态映射
◦ vmalloc动态映射区
◦ 永久映射区
◦ 固定映射区
◦ 临时映射区：例如操作page cache时，需要将page cache的物理地址映射到临时映射区操作&lt;/p>
&lt;p>64位内核态虚拟空间有128T
• 8T空洞
• 64T直接映射区
• 32Tvmalloc动态映射区（类似于用户态的堆）
• 1T虚拟内存映射区，存放struct page
• 512M直接映射区，存放代码段、全局变量、BSS等&lt;/p>
&lt;h3 id="库函数malloc通过系统调用brk或mmap为进程分配虚拟内存">库函数malloc通过系统调用brk或mmap为进程分配虚拟内存
&lt;/h3>&lt;p>进程需要使用内存时，就向操作系统申请分配一些虚拟页使用，这叫做分配内存。分配的虚拟内存不一定对应了物理内存，只有访问时才会触发page fault映射到物理内存。
内存可以在创建进程时静态分配，例如代码段、全局变量、静态变量等。也可以在进程运行过程中动态分配，比如通过brk在堆中分配或通过mmap在文件映射区分配。&lt;/p>
&lt;p>一般通过brk分配小块内存，通过mmap分配大块内存。&lt;/p>
&lt;h4 id="malloc会分配更大的空间">malloc会分配更大的空间
&lt;/h4>&lt;p>malloc在分配虚拟地址空间时，会预分配更大的空间作为内存池，这是为了避免频繁系统调用，并且减少内存碎片。&lt;/p>
&lt;h4 id="brk在堆上分配内存">brk在堆上分配内存
&lt;/h4>&lt;p>brk系统调用的原型只有一个参数，就是堆顶的地址。如果高于当前堆顶就是分配了新的地址空间，如果低于当前堆顶就是回收地址空间。还有一个更方便的系统调用sbrk，参数是堆顶偏移量，也就是只需要指定堆顶指针移动的偏移量。&lt;/p>
&lt;p>brk是堆不是栈，因此可能堆顶的还没释放，堆里面的已经释放了。但是堆顶这时还不能往下移动，因此free并不会马上归还，而是会留在堆里面分配给新的请求。只有进程终止或者堆顶释放的时候才会归还。&lt;/p>
&lt;p>堆的分配方式会导致碎片化，因此只适合分配小块内存。&lt;/p>
&lt;h4 id="mmap在文件映射区分配虚拟内存">mmap在文件映射区分配虚拟内存
&lt;/h4>&lt;p>&lt;a class="link" href="https://www.cnblogs.com/Courage129/p/14232306.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/Courage129/p/14232306.html&lt;/a>&lt;/p>
&lt;p>mmap允许将文件或设备的内容从内核的page cache映射到进程的地址空间中，这样进程可以像直接访问内存一样访问文件，而不是通过read/write系统调用接口访问。&lt;/p>
&lt;p>如果没有mmap，进程要访问文件就要先用read系统调用把文件内容先复制到用户态的缓冲区中，修改缓冲区再写回page cache。有了mmap就可以直接操作page cache，减少了一次复制。&lt;/p>
&lt;p>除了映射文件之外，mmap还可以映射匿名页，以达到动态分配内存空间的目的。&lt;/p>
&lt;p>mmap的参数有起始地址、分配长度、一些标志位比如访问权限，可读可写等，是私有还是共享映射，文件描述符和文件内偏移量等。
• 起始地址只是一个暗示，如果可以分配就分配，如果不可以就由操作系统自己找一个（一般进程可以指定NULL）
• 分配长度是必提供
• 只有文件页需要文件描述符，匿名页指定-1，偏移量为0&lt;/p>
&lt;p>每次调用mmap都会产生一个VMA，返回值就是指向起始地址的指针。&lt;/p>
&lt;p>free会归还mmap分配的空间。&lt;/p>
&lt;h3 id="mmap的文件通过munmap和msync刷盘">mmap的文件通过munmap和msync刷盘
&lt;/h3>&lt;p>mmap将page cache映射到用户空间，默认情况下操作系统会有线程异步刷盘（根据脏页比例或者时间阈值）。&lt;/p>
&lt;p>msync函数可以将内存中的修改强制同步到磁盘文件，确保数据持久性
• MS_SYNC同步刷盘，意思是mync函数阻塞直到数据落盘
• MS_ASYNC异步刷盘，意思是只是通知内核调度刷盘，不等待完成&lt;/p>
&lt;p>munmap解除映射或者close关闭文件描述符时会触发脏页刷盘，但不是立刻的，依赖于内核的调度。&lt;/p>
&lt;p>注意：msync同步指定内存范围的脏页，默认不同步文件的元数据，适合局部数据更新场景。fsync以文件为单位强制下刷文件所有的脏页和元数据&lt;/p>
&lt;h3 id="匿名页和文件页">匿名页和文件页
&lt;/h3>&lt;p>内存中的页有两种：匿名页和文件页。&lt;/p>
&lt;p>匿名页是没有关联到文件系统，不需要持久化的页。这些页通常保存进程运行过程中的临时变量、和动态分配的堆等数据，理论上是不需要落盘的。但是实际上有可能在内存紧张的时候被换出到磁盘上。&lt;/p>
&lt;p>匿名页通过映射机制映射到虚拟地址空间的某页。&lt;/p>
&lt;p>文件页是与磁盘存在映射关系的某页。一般来说应当是先从磁盘上将文件读入内存中的page cache，然后再映射到进程的文件映射区。&lt;/p>
&lt;p>区别：文件页是持久化到磁盘上的数据，而匿名页仅仅存在于内存。内存紧张时匿名页需要交换到磁盘上的交换分区或者创建一个交换文件，而文件页则写回脏页或者不脏就直接丢弃。&lt;/p>
&lt;p>联系：匿名页和文件页都使用struct page结构体，只是文件页的mapping指向page cache，而匿名页的mapping指向anon_vma结构用来追踪对应的VMA。并且匿名页不会是脏页。通过检查page结构mapping的最低位判断是否是匿名页（1：匿名，0：文件）&lt;/p>
&lt;p>注意，匿名页在换入换出时会暂时使用page cache，但是正常使用的时候不涉及page cache&lt;/p>
&lt;h3 id="私有映射和共享映射">私有映射和共享映射
&lt;/h3>&lt;p>私有映射是隔离性的一部分，意思是映射的地址空间不能被其他进程访问。例如，一个文件可以通过私有文件映射映射到了多个进程的文件映射区，但是多个进程可以独立读写映射而不会相互影响。这是依赖于写时拷贝。而共享映射是一种进程间通信的方式，例如一个文件通过共享映射被多个进程映射，则需要锁或信号量机制避免数据竞争的问题。&lt;/p>
&lt;p>私有映射的文件是不会写回盘的，而共享映射会。&lt;/p>
&lt;h3 id="库函数mmap和系统调用mmap">库函数mmap和系统调用mmap
&lt;/h3>&lt;p>库函数mmap实际上是对系统调用的封装，方便用户编程。&lt;/p>
&lt;p>mmap的使用：首先用open打开一个文件，获得文件描述符；然后用stat或fstat获取文件大小，从而知道需要映射空间的大小；接着调用mmap指定起始地址（通常为NULL）、长度、保护标志、文件描述符、偏移量；mmap会返回映射区域的指针；用完后使用munmap解除映射；最后使用close关闭文件。&lt;/p>
&lt;p>stat和fstat用于获取文件的状态信息，包括文件大小、访问时间等元数据。两者区别在于前者使用路径名，后者使用文件描述符。&lt;/p>
&lt;h3 id="分配和映射的虚拟内存不会立刻访问">分配和映射的虚拟内存不会立刻访问
&lt;/h3>&lt;p>分配和映射内存后，不会立刻将虚拟内存与物理内存关联，也不会立刻将文件读上来。意思是PTE表项是空的。只有在访问虚拟页时，才会触发page fault为虚拟内存页分配并映射物理内存页。&lt;/p>
&lt;h3 id="私有文件映射">私有文件映射
&lt;/h3>&lt;p>进程的task_struct结构体通过file_struct管理打开的文件，file_struct中有文件描述符数组，文件描述符就是这个数组的下标，数组的每一项都是struct file结构。通过file可以获取文件的索引，如果进程想read/write有这个就够了。但是如果要映射到虚拟内存区域，还需要把文件从page cache映射过来。&lt;/p>
&lt;p>映射的本质就是使用PTE表项，将文件映射区的虚拟地址空间翻译成page cache对应的物理地址空间，因此操作映射就是直接操作page cache。优势在于用户态进程本来不能直接访问内核态的page cache，而映射后就可以直接在用户态访问，不需要拷贝。&lt;/p>
&lt;p>私有文件映射采用写时拷贝技术避免数据竞争。私有文件映射的PTE表项设置为只读的，当进程写入的时候会产生写保护类型的缺页中断。这时会分配一个新的物理页并且写入修改后的数据，并且将PTE映射到新页。&lt;/p>
&lt;p>私有文件映射中，脏页不会回写，其他进程看不到。&lt;/p>
&lt;p>私有文件映射避免了拷贝，主要用于进程加载数据，比如代码段、数据段等。&lt;/p>
&lt;h3 id="共享文件映射">共享文件映射
&lt;/h3>&lt;p>共享文件映射和私有文件映射的唯一区别在于不采用写时拷贝技术，PTE表项直接就是可写的。因此一个进程修改文件后另一个进程也可以看到。因此需要锁或信号量等机制避免数据竞争。&lt;/p>
&lt;p>共享文件映射可以写回脏数据，对文件做真正的修改。&lt;/p>
&lt;p>共享文件映射是一种进程间通信的机制。&lt;/p>
&lt;h3 id="私有和共享匿名映射">私有和共享匿名映射
&lt;/h3>&lt;p>匿名页不对应磁盘上的文件，也没有page cache。&lt;/p>
&lt;p>对于私有匿名映射来说，使用mmap分配一段虚拟内存空间之后，真正使用到这段空间时，没有相应的PTE表项，因此MMU会触发缺页中断。分配一个物理页后再更新页表。&lt;/p>
&lt;p>对于共享匿名映射，由于另一个进程不知道本进程将虚拟地址映射到了哪一个物理页，因此共享匿名映射是借助文件实现的。&lt;/p>
&lt;p>内核有一个tmpfs虚拟文件系统，内核在tmp方式中创建一个匿名文件。因此进程通过匿名文件仿照共享文件映射完成共享匿名映射。&lt;/p>
&lt;p>共享匿名映射只适合父子进程之间的通信，这是因为其他进程无法看到本进程创建的匿名文件，只有子进程可以共享虚拟内存空间和页表。&lt;/p>
&lt;h3 id="direct-io不能使用文件映射">direct io不能使用文件映射
&lt;/h3>&lt;p>文件映射mmap是将page cache中的内存页映射到用户空间，而direct io没有page cache，一般是应用程序自己实现了一个缓存，所以不会使用mmap机制。&lt;/p>
&lt;h3 id="rcu机制允许读者无锁访问">RCU机制允许读者无锁访问
&lt;/h3>&lt;p>传统的读写锁中，写者持有写锁时读者不能读取。&lt;/p>
&lt;p>在RCU机制中，读者总是可以读取数据，如果写者要写入数据，则先拷贝一份副本去修改副本，修改完后将指向旧数据的指针指向新副本&lt;/p>
&lt;p>适用于读远大于写的场景。&lt;/p>
&lt;h3 id="3种物理内存模型">3种物理内存模型
&lt;/h3>&lt;h4 id="flatmem平坦内存模型">FLATMEM平坦内存模型
&lt;/h4>&lt;p>将物理内存空间看作一块连续的大数组，数组的每一项是page结构，下标就是物理页号&lt;/p>
&lt;h4 id="discontigmem非连续内存模型">DISCONTIGMEM非连续内存模型
&lt;/h4>&lt;p>没必要为没用到的物理页分配page结构，经常要管理小片不连续的物理内存。&lt;/p>
&lt;p>用node表示一小段连续的物理内存，node内部用page数组管理这段连续物理内存页。&lt;/p>
&lt;h4 id="sparsemem稀疏内存模型">SPARSEMEM稀疏内存模型
&lt;/h4>&lt;p>node粒度大，node内部可能不连续。node多了开销大。&lt;/p>
&lt;p>将物理内存空间划分为一系列section，每个section内部有page数组。section自身构成一个连续数组。&lt;/p>
&lt;p>每个section可以上线或下线从而支持内存的热插拔。&lt;/p>
&lt;p>当section下线之前，内核会将这部分地址隔离开，并将该section的内容迁移至其他section。包括复制和重新映射。迁移成功后将section标记为不可用并拔掉内存模块。而上线则仅需要初始化section并标记为可用。&lt;/p>
&lt;p>对于用户态地址空间，所有的虚拟内存地址都可以重新映射。对于内核态地址空间，直接映射区对应的物理地址不能改变，因此这段物理内存是不可迁移的，也就是不可拔出的。&lt;/p>
&lt;h3 id="多核cpu的内存访问架构一致性和非一致性">多核CPU的内存访问架构：一致性和非一致性
&lt;/h3>&lt;p>对称多处理器架构SMP&lt;/p>
&lt;p>所有CPU访问内存的距离是一样的。内存和所有的核心在总线两侧。因此是一致性内存访问UMA&lt;/p>
&lt;p>缺点：总线成为性能瓶颈。&lt;/p>
&lt;h4 id="非一致性内存访问numa架构">非一致性内存访问NUMA架构
&lt;/h4>&lt;p>将内存划分为多个内存结点，每个CPU有自己的本地内存。CPU访问本地内存更近并且不用竞争总线。CPU也可以通过QPI跨节点访问其他内存但是比较慢。因此每个CPU最好优先使用自己的物理内存，也就是执行映射到自己物理内存的进程。（处理器亲和性）&lt;/p>
&lt;p>每个numa节点用pglist_data结构体管理，pglist_data放在全局数组node_data中，通过nodeid索引。&lt;/p>
&lt;p>每个pglist_data主要包括：numaid，指向物理页page的数组，第一个页的pfn，可用物理页总数等。还有一个自旋锁用于数据竞争。&lt;/p>
&lt;p>物理页的PFN是全局唯一的。&lt;/p>
&lt;p>NUMA节点的状态用位图表示，包括上线、有高端内存、有普通内存等&lt;/p>
&lt;h3 id="物理内存的回收">物理内存的回收
&lt;/h3>&lt;p>虚拟内存没有映射到物理页上，访问的时候就会触发缺页中断。缺页中断如果没有足够的物理内存，就会触发内存回收。&lt;/p>
&lt;p>物理内存紧张时，会唤醒内核线程kswapd来后台异步回收。如果仍不够就会同步直接回收。&lt;/p>
&lt;p>如果kswapd和同步回收都不够，就会触发OOM机制杀死一些高占用进程。&lt;/p>
&lt;p>回收内存的步骤：文件页和匿名页是可以回收的，对于文件页，可以写回或丢弃。对于匿名页，需要swap换出。文件页和匿名页的回收基于LRU算法。有active和inactive两个双向链表，可以优先回收不活跃的页。&lt;/p>
&lt;p>优先回收文件页而不是回收匿名页：干净文件页可以直接丢弃，藏文件页写回只有一次磁盘写入。匿名页的换入换出均为随机IO，无法合并也无法预读，而文件页通常对应磁盘的连续逻辑块，写回时可以合并IO实现顺序访问&lt;/p>
&lt;p>只有直接丢弃文件页不会影响性能，写回和swap都是会影响性能的。&lt;/p>
&lt;p>为了减少性能影响，可以调整更倾向回收文件页，也可以尽早触发kswapd来避免触发直接同步回收。&lt;/p>
&lt;p>内存水位（阈值）用来触发后台回收线程，分为页高阈值、页低阈值和页最小阈值。
高于页高阈值：内存充足
页低阈值-页高阈值：有一定压力
页最小阈值-页低阈值：触发kswapd线程后台回收，直到高于页高阈值
小于页最小阈值：触发主动同步回收&lt;/p>
&lt;p>页高阈值和页低阈值根据页最小阈值计算，可以调整页最小阈值。调高了：早触发回收，预留过多空闲内存导致频繁换入换出甚至OOM。预留少了则会影响内存分配性能。&lt;/p>
&lt;p>在NUMA架构下，本地内存不足时除了回收本地内存，还可以使用其他node的内存。可以设置倾向。默认设置为先找远端内存，因为访问远端内存（内存IO）的开销比回收内存（磁盘IO）的影响要小。&lt;/p>
&lt;h3 id="oom根据算法选择victim">OOM根据算法选择victim
&lt;/h3>&lt;p>OOM选择算法为可用页面数*当前进程校准值除以1000+当前进程已用物理页数&lt;/p>
&lt;p>也就是和校准值、已用页面数正相关。因此可以调低校准值保护某个进程不被杀死。但是假如某个进程发生了内存泄漏而不能被杀死，会导致逐渐占满物理空间。&lt;/p>
&lt;p>在4G物理内存机器上申请8G虚拟内存空间
• 在32位机器上直接申请失败，因为用户态进程最多可以申请3G。
• 在64位机器上，理论上可以分配128T
◦ 如果设置了overcommit_memory参数，则会检查请求分配的合理性，有可能分配失败
◦ 由于虚拟内存的VMA等管理资源也是占用空间的，因此8G应该可以申请，但没办法申请到128T。会在某个时刻触发OOM杀死当前进程。
◦ 如果开启了swap机制，内核可以将部分没有用到的管理资源换出，因此可以申请到127T。但是进程本身的运行也会占用一定地址空间，因此不可能正好申请完128T。&lt;/p>
&lt;h3 id="预读失效和缓存污染">预读失效和缓存污染
&lt;/h3>&lt;p>每一级存储都是下一级的缓存。缓存基于局部性原理。当数据的访问模式不符合局部性原理时，会导致缓存失效。&lt;/p>
&lt;p>缓存的逐出通常采用FIFO、LRU、时钟或者LFU算法。&lt;/p>
&lt;p>FIFO算法并不考虑数据最近使用情况，因此性能不佳。&lt;/p>
&lt;p>LRU、LFU和时钟算法等考虑到了数据最近使用情况，基于局部性原理。&lt;/p>
&lt;p>LRU：活跃/非活跃&lt;/p>
&lt;p>LRU算法将最近最少使用的数据逐出，基于最近访问时间。当缓存命中时就提升到首部，当加载新缓存时逐出尾部。使用双向链表和unordered_map实现。
• 预读失效：对于随机IO，基于空间局部性的预读就失效了，因此效果不佳
• 缓存污染：对于大规模顺序IO，每个页面虽然最近访问过，但不会再次访问，因此时间局部性失效，效果不佳。&lt;/p>
&lt;p>改进方法：在Linux中，page cache实现了两个链表：活跃LRU和非活跃LRU。第一次访问数据时会将数据放在非活跃链表中，第二次访问才会将其提升到活跃LRU链表中。因此提高了进入活跃LRU的门槛，不会污染活跃LRU链表。逐出时会优先逐出非活跃LRU链表中的数据页。&lt;/p>
&lt;p>LFU：年龄老化&lt;/p>
&lt;p>LFU算法根据页面的最近访问次数，逐出最近最少访问的页面。问题在于工作集切换时，会导致新工作集的页面频繁逐出。因此可以给每个页面记录年龄，年龄越高排序越低。或者对于所有的页面，每隔一段时间将访问次数减半。&lt;/p>
&lt;h3 id="linux采用4kb作为内存页的默认大小">Linux采用4KB作为内存页的默认大小
&lt;/h3>&lt;p>页面大小必须是2的整数幂，为了方便计算(1. 通过左移右移的方法得到各级页表地址和页内偏移量2. 如果不是2的幂次会产生地址浪费，如5B页面，用2位2进制表示页内偏移量会有1KB无法访问，用3位会浪费3个地址)。&lt;/p>
&lt;p>如果页太小，则页表等管理开销大。&lt;/p>
&lt;p>如果页太大，会浪费内存页的空间。&lt;/p>
&lt;h3 id="struct-folio用于表示大页和复合页">struct folio用于表示大页和复合页
&lt;/h3>&lt;p>Linux中的默认内存页大小是4K，但是可以创建更大的页面来减少缺页次数、减少页表条目，提高分配效率。&lt;/p>
&lt;p>复合页是连续的小页组合成的，但仍是小页的组合。&lt;/p>
&lt;p>Linux引入folio用来表示大页和复合页，能够简化代码逻辑，比如不用每次都检查一个page是不是大页的第一个页。并且释放的时候只需要一次调用就可以。&lt;/p>
&lt;h3 id="内核分配物理页的结构">内核分配物理页的结构
&lt;/h3>&lt;p>alloc_pages用于分配2的order次幂个物理内存页。返回的是物理地址。由于进程只能直接使用虚拟地址，所以提供了另一个__get_free_pages函数直接返回虚拟内存地址供进程使用。由于物理页中可能还有原来的数据，因此get_zeroed_page能够返回填充0的物理页，更安全。&lt;/p>
&lt;p>释放物理页时，free_pages传入虚拟地址和阶。转换物理地址之后调用__free_pages释放。&lt;/p>
&lt;p>内存分配根据gfp掩码指定内存分配行为，比如高优先级、允许swap、必须原子等。&lt;/p>
&lt;h4 id="alloc_pages底层使用伙伴系统分配物理内存">alloc_pages底层使用伙伴系统分配物理内存。
&lt;/h4>&lt;p>伙伴系统将内存划分为多个块，每个块都是2的幂次大小。进程请求一定量页面时，伙伴系统会优先分配所需阶数的连续块，如果该阶没有就把更大阶数的伙伴块平分成低阶，直到分到所需的大小。&lt;/p>
&lt;p>释放内存的时候检查相邻伙伴块是否空闲，如果空闲就合并成更高阶。&lt;/p>
&lt;p>通过合并伙伴块能够减少外部碎片，快速分配2的幂次大小连续物理空间。&lt;/p>
&lt;p>但是会有内碎片，因为所需的大小不一定是2的幂次，会浪费。并且不适合小内存块分配，因为会频繁划分小的伙伴块。并且伙伴系统最少分配一个物理页，如果只是new一个对象，可能根本用不到4K。&lt;/p>
&lt;h4 id="小内存块结合slab分配器使用">小内存块结合slab分配器使用
&lt;/h4>&lt;p>针对小内存块的分配，内核采用slab内存池。&lt;/p>
&lt;p>slab分配器首先会向伙伴系统一次性申请多个物理内存页面组成slab内存池。并将这些连续物理空间划分为多个相同大小的小内存块，内核会针对多种尺寸预先创建多个slab内存池。比如会对task_struct、page等常用结构体建立slab内存池。这是为了方便频繁分配和释放这些结构体。&lt;/p>
&lt;h4 id="内核使用kmalloc接口分配小块内存">内核使用kmalloc接口分配小块内存
&lt;/h4>&lt;p>kmalloc基于slab分配器实现，kmalloc会创建一系列大小的内存池，根据用户指定选择一个最合适的内存池slab cache。也可以用户自己通过kmem_cache_create创建一个合适的内存池。
内核通过vmalloc接口分配大块连续虚拟内存&lt;/p>
&lt;p>vmalloc不保证内存在物理上连续，只是虚拟地址连续。&lt;/p>
&lt;p>内核通过get_free_pages函数获得大量连续物理内存&lt;/p>
&lt;p>get_free_pages通过伙伴系统分配大量连续物理内存。&lt;/p>
&lt;h2 id="文件系统">文件系统
&lt;/h2>&lt;h3 id="文件及文件系统的概念">文件及文件系统的概念
&lt;/h3>&lt;p>文件是一系列数据和元数据的集合。其中，元数据定义了文件的属性信息，数据则是文件存储的实际内容。&lt;/p>
&lt;p>文件的元数据一般包括所有者，访问权限，访问模式，创建时间，修改时间，大小等属性，还包括文件数据块的索引，即文件中某个数据块的逻辑地址。&lt;/p>
&lt;p>文件最重要的元数据是inode。inode是文件系统中的一个结构，唯一标识了一个文件。inode通过inode号相互区别。在同一个文件系统中，inode号是唯一的。不同的文件系统可能不唯一。进程打开文件后，可以通过struct file结构中的vfsmount成员确定文件系统。&lt;/p>
&lt;p>inode号一般从3开始分配，2号是根目录，1号在ext中是lost+found（恢复无主文件的目录），0号保留（比如删除一个文件之后可以将文件名映射到0）&lt;/p>
&lt;p>注意：在Linux中，文件名并不属于inode，因为不同的硬链接可以有不同的文件名，但是他们共享一个inode。文件名与inode的映射关系存储在目录文件的目录项中。目录文件就由该目录下目录或文件的目录项组成，目录项在目录文件中组织成哈希表从而便于查询。为了避免逐级从目录文件中查询，操作系统会将最近读取到的目录项缓存在dentry中。dentry是内存中的结构，用于缓存文件名到inode之间的映射，避免逐级查找。&lt;/p>
&lt;p>文件的数据是文件存储的实际内容，数据可以是有结构的，也可以是无结构的。结构化数据是具有某种标准格式的数据，例如数据库中的某个表格。结构化数据便于计算机处理和分析。非结构化数据是指没有标准格式的数据，比如文本文件，二进制文件等。非结构化数据通常占数据量的绝大多数。半结构化数据一般是一些自描述文件，数据的结构和内容混在一起，需要解析标签。例如json文件，html文件等。&lt;/p>
&lt;p>文件可以进行一系列操作，比如创建，打开，读取，写入，删除，截断等。不同的文件系统实现操作的方式不同，Linux中除了具体的文件系统，还有对文件系统的抽象也就是虚拟文件系统VFS。VFS可以给应用提供统一的操作接口，便于用户编程。&lt;/p>
&lt;p>文件系统是操作系统中用于组织和管理文件的部分。文件系统一方面提供了对文件的操作管理方法，另一方面是对底层磁盘的抽象，使得用户无需关心数据在盘上是如何放置的，而将存储空间的管理交给文件系统完成。&lt;/p>
&lt;p>文件系统的主要功能包括提供对文件的操作，提供目录结构，管理文件的数据块在磁盘上的放置。保护文件的一致性和崩溃恢复等。&lt;/p>
&lt;h3 id="文件的操作">文件的操作
&lt;/h3>&lt;p>文件的操作包括创建，打开，读取，写入，删除和截断等。&lt;/p>
&lt;p>要打开或者创建一个文件，可以使用open系统调用。open系统调用有3个参数。第一个是文件的路径和文件名，第二个是文件的访问模式和操作，第三个是在创建文件时，定义文件的访问权限。&lt;/p>
&lt;p>首先，内核需要解析路径名。解析路径名的方式就是从根目录开始，逐级读取目录文件，并确定下一级目录文件的位置。如果目录较长，这个过程可能会很慢。为了加速，可以为深层目录文件创建一个软链接。另外，文件系统提供dentry缓存机制加快解析。如果最近访问过某个文件或目录，就会把该文件对应的目录项缓存在内存中，不会逐目录查找。&lt;/p>
&lt;p>其次，open第二个参数需要指定文件打开以后的访问模式，包括只读，只写和读写。如果文件不存在，可以用O_CREAT指定创建一个文件，还可以指定是否要追加写、截断等。O_EXCL和O_CREAT合用，表示如果文件本身存在就返回创建失败。O_TRUNC表示如果文件存在就把长度截断到0。O_APPEND表示文件打开后总是往尾部追加写。&lt;/p>
&lt;p>创建一个文件的流程包括：路径解析（已经提到），检查该目录是否有权限创建文件，为文件分配inode结构，将文件的名字和inode号更新到目录中。如果需要写入还要分配数据块并更新元数据索引。如果是direct io或者同步写还需要将数据块落盘。&lt;/p>
&lt;p>open第三个参数代表权限。在创建文件的模式下，第三个参数指定了文件的访问权限，包括文件创建者，所在组和其他成员的读取，写入，执行权限。&lt;/p>
&lt;p>read和write系统调用负责文件的读写。均有三个参数。第一个参数是文件描述符，第二个是缓冲区指针，第三个是读或写的字节数。&lt;/p>
&lt;p>read和write都从文件的读写指针开始，可以通过lseek修改读写指针。lessk的三个参数是文件描述符，偏移量和偏移起始地址。偏移起始地址可以是文件开头，末尾或者当前读写指针。&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/weixin_44698673/article/details/125729055" target="_blank" rel="noopener"
>https://blog.csdn.net/weixin_44698673/article/details/125729055&lt;/a>&lt;/p>
&lt;p>删除文件用unlink系统调用，参数是文件路径。之所以参数是文件路径，是因为不同的文件可能对应同一个inode，也就是硬链接。如果通过文件描述符找到文件，就不知道具体想要删除哪一个硬链接。当删除最后一个硬链接的时候，文件的空间才会真正释放。删除文件的过程包括从目录中删除该文件的表项，减少硬链接计数。如果是最后一个硬链接，就调用具体文件系统的删除操作。&lt;/p>
&lt;p>删除目录用rmdir系统调用，参数是目录路径，因为打开目录不会返回一个整数形式的描述符。只能删除空目录，目录不空就要递归删除。&lt;/p>
&lt;p>截断文件是指定一个长度，如果文件超过这个长度就把多余部分删除，如果不足这个长度就用\0填充到这个长度。truncate和ftruncate系统调用可以截断。前者的参数是路径名和长度，后者的参数是文件描述符和长度。&lt;/p>
&lt;p>区别：truncate之前无需先打开文件，ftruncate需要在打开文件的情况下截断。truncate可能会收到符号链接攻击，意思是高权限的文件被链接到低权限的链接，如果文件系统不完善，那么低权限的用户可能可以操作高权限的文件。&lt;/p>
&lt;h3 id="文件在进程中的形式">文件在进程中的形式
&lt;/h3>&lt;p>进程通过open可以打开一个文件，打开以后通过文件描述符操作这个文件。&lt;/p>
&lt;p>在linux中，进程是task_struct结构体表示的，其中file_struct成员存放了进程打开文件的信息。&lt;/p>
&lt;p>file_struct中的主要成员有：引用计数、读写锁，文件描述符表。&lt;/p>
&lt;p>引用计数是说，子进程会共享父进程的file_struct，不同线程也会共享file_struct。因此还需要读写锁来避免数据竞争。&lt;/p>
&lt;p>文件描述符表有两种形式，一种是fd_array数组，还有一种是fdt链表。当打开的文件不太多时，用数组（可以随机访问）。打开比较多时用链表。文件描述符实际上就是数组下标或链表中的索引。每一项指向一个struct file结构体，保存了文件在当前进程中的使用情况。主要成员有文件的inode指针，page cache指针（叫做address_space），vfsmount指针，dentry指针，操作函数集指针。这些是打开这一个文件的所有file结构共享的。此外还有文件的读写指针f_pos，访问模式（只读只写还是读写），权限等。&lt;/p>
&lt;h3 id="文件的存储">文件的存储
&lt;/h3>&lt;p>文件在盘上的占用形式：连续存放和非连续存放&lt;/p>
&lt;p>对于HDD来说，最好连续访问数据以减少寻道时间。因此数据在盘上最好是连续存放的。&lt;/p>
&lt;p>连续存放方式是指文件在磁盘上连续存放，这样只需要在inode中指定文件的起始地址和长度就可以表示文件的存放。优点在于访问效率高，并且不需要索引。缺点在于不方便扩展和存在碎片。
不方便扩展：如果文件的末尾以后已经被占用，则没有办法继续申请连续的空间，必须要将文件整个搬移到新的更大的连续空间。
碎片：文件中的某些块不再使用，或者文件被删除，就会在磁盘上留下空缺。那么有可能磁盘本来有足够的空间，但是放不下大于空缺的数据。因此需要频繁整理紧凑空间
因此需要引入非连续存放方式。&lt;/p>
&lt;p>• 链表方式
采用链表的方式就可以充分利用空间，不会产生碎片，还可以动态扩展文件大小。分为隐式链接和显式链接。缺点：只要某个数据块损坏或者链接表损坏，就会导致文件丢失
◦ 隐式链接：inode保存第一个数据块和最后一个数据块的地址，每一个数据块保存下一个数据块的地址。优点：没有链接表开销；缺点：一个数据块损坏以后整个文件丢失，必须按照顺序读取目标数据块之前的每一个数据块
◦ 显式链接：inode保存首位数据块的地址，同时将每个数据块中的指针放在一个全局链接表中。链接表放在内存中，查询快速。缺点：链接表占用内存开销大，显式链接也要顺序扫描表
• 索引方式
◦ 为每个文件创建索引数据，存放每个数据块的位置。inode指向索引数据块。
▪ 优点：没有碎片，也可以扩展文件，还可以快速定位数据块而不是顺序读取。
▪ 缺点：索引额外占用空间，索引块的大小限制了整个文件的大小，索引块损坏导致文件丢失
◦ 链式索引
▪ 允许存在多个索引块，以链表组织
• 优点：不限制文件大小
• 缺点：指针损坏导致文件丢失
◦ 多级索引块
▪ 索引块存放二级索引的地址，甚至可以有更多级别索引。&lt;/p>
&lt;p>ext2/3中结合了直接索引和间接索引：inode中直接存放一些数据块的索引，多余的采用间接索引，更多的采用二级或高级索引。因此对于小文件可以直接查找，大文件可以多级索引。&lt;/p>
&lt;p>ext4引入了extent机制，一个extent表示连续的数据块的集合而不是单独的地址。利用extent可以减少索引条目。如果一个大文件完全是顺序的，只需要一个extent就可以表示。&lt;/p>
&lt;p>ext4中extent组织成树形结构。文件更倾向于连续存储合并extent。&lt;/p>
&lt;h3 id="空闲空间的管理">空闲空间的管理
&lt;/h3>&lt;p>在为文件分配地址时需要快速找到可用的空闲空间。常用的方法有空闲表，空闲链表和位图&lt;/p>
&lt;p>• 空闲表
◦ 建立一张全局空闲表，每一个条目包括空闲空间的起始位置和空闲块数量，通过顺序扫描找到足够的空闲空间，适合分配连续空间
◦ 如果有很多细碎的空闲空间，性能会变差，表也会变大。
• 空闲链表
◦ 每一个空闲块指向下一个空闲块，需要分配时从链头上取下足够数量的块
◦ 不适合连续分配，大型文件系统中链表会很大
• 位图
◦ 用位图表示每一个块的使用情况。
◦ linux中用位图管理数据空闲块和inode空闲块
• 成组链接
◦ 将空闲块分成若干个组，每一组指向下一组的头部，这样可以减少链接表的大小。并且可以在组内分配连续空间，类似于ext4里面的extent。本来文件系统管理数据需要记录所有数据块的索引，但是如果数据块是连续的就只需要记录起始位置和长度，那么就减少了索引量。&lt;/p>
&lt;h3 id="符号链接软链接和硬链接">符号链接（软链接）和硬链接
&lt;/h3>&lt;p>符号链接（软链接）类似于快捷方式，有自己的inode，其中内联地存放链接指向文件的路径。软链接可以对文件或目录创建，可以跨文件系统创建。&lt;/p>
&lt;p>硬链接没有自己的inode，或者说所有的硬链接共享一个inode，只是路径和文件名不一样。也就是说硬链接实际上是所在目录中的一个条目。inode中保存硬链接计数，只有删除最后一个硬链接的时候才真正删除文件。&lt;/p>
&lt;p>不能跨文件系统建立硬链接，因为不同文件系统的inode号是冲突的。&lt;/p>
&lt;p>每个目录本身包含自己的硬链接. 和父目录的硬链接..，从而方便用户引用当前目录和导航到上一级。但是不能人为对目录建立硬链接，为了避免循环引用导致目录无法删除。&lt;/p>
&lt;h3 id="文件系统的结构">文件系统的结构
&lt;/h3>&lt;h4 id="ext系列文件系统">EXT系列文件系统
&lt;/h4>&lt;p>&lt;a class="link" href="https://www.cnblogs.com/f-ck-need-u/p/7016077.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/f-ck-need-u/p/7016077.html&lt;/a>&lt;/p>
&lt;p>ext系列文件系统将盘上逻辑地址空间划分为多个块组。&lt;/p>
&lt;p>为了在块组中分配数据块，每个块组有自己的数据块位图，用于表示数据块是否空闲&lt;/p>
&lt;p>为了索引一个文件，文件的inode会存放每个数据块的地址。这是直接索引，此外还会有间接索引&lt;/p>
&lt;p>一个inode的大小比块小。因此一个块可以存多个inode。&lt;/p>
&lt;p>每个块组会管理一定序号的inode，inode的位置存放在该块组的inode表中。&lt;/p>
&lt;p>为了分配inode号，每个块组还有inode位图，用于记录该块组中的空闲inode号。&lt;/p>
&lt;p>之所以要划分块组，是因为如果不划分块组，就会导致块位图、inode位图和inode表过大，不方便查询。&lt;/p>
&lt;p>块组的元数据保存在块组描述符GD中，包括一个块组管理块的范围、块位图、inode位图、inode表的地址、空闲块和inode数量。&lt;/p>
&lt;p>每个块组的GD组织成一个全局的块组描述符表GDT。还有一个保留GDT为了防止扩容以后块组描述符放不下。&lt;/p>
&lt;p>文件系统的全局元数据除了块组描述符以外，还有超级块，包含inode总数、块总数、块组总数等。&lt;/p>
&lt;p>全局元数据非常重要，损坏会导致全盘数据丢失。早期存放在每个块组中，后来采用稀疏技术，就是只写入0、1和其他序号为3，5，7的幂次的块组中。只有前面的元数据无法访问才会读取后面的副本。&lt;/p>
&lt;p>inode结构中没有文件名和inode号。要查询一个inode，实际上是先从目录文件或者dentry中通过文件名查询到对应的inode号，每个块组管理哪些inode号在格式化的时候就已经确定，可以直接计算出所在块组。根据块组中inode表查询到inode位置。&lt;/p>
&lt;p>有一些文件比较特殊，如软链接（符号链接）、套接字、设备文件等只需要inode本身就可以内联地存放，所以不占用数据块。&lt;/p>
&lt;p>ext4文件系统引入了extent机制，一个extent是地址连续的数据块集合，索引这些数据块时只需要所以extent起始地址和偏移量。减少了元数据中索引的大小。&lt;/p>
&lt;h4 id="文件系统的崩溃一致性">文件系统的崩溃一致性
&lt;/h4>&lt;p>ext3中引入了日志机制，将盘划分为数据区，元数据区和日志区。每次存储数据时，将数据块落盘后，再将元数据写入日志区并提交，最后再将元数据转写到盘上。
断电时机：写数据时断电 - 根本没有更新元数据，相当于没有写入
写日志时断电 - 没有提交，因此不会恢复
日志提交后断电 - 可以重放日志恢复&lt;/p>
&lt;h4 id="ext系列文件系统中文件的操作">EXT系列文件系统中文件的操作
&lt;/h4>&lt;p>读取：读取某个文件之前需要确定inode号。如果内存中有相应的dentry缓存，就会从dentry缓存中查询，否则就要通过读取目录文件逐级查询。&lt;/p>
&lt;p>读取目录文件：找到块组描述符表（开机时已经加载到内存中），找到inode表并查询根目录的inode（inode号为2）所在的数据块。从数据块中取出根目录的inode并查询下一级目录的inode号，并再查表。直到查到文件所在目录，就从inode表中找到文件inode，并定位数据块，再将数据块复制到用户空间。当然，每次查询的时候都会检查inode中的权限，看是否有权限读取。&lt;/p>
&lt;p>删除：&lt;/p>
&lt;p>删除普通文件：找到文件所在inode和数据块，如果硬链接计数大于1就减少硬链接计数，否则才真正删除文件。接下来从inode表中将inode的表项删除，并且更新inode map，再从所在目录数据块中删除该文件条目，最后在块位图bmap中更新该文件数据块所在位，设置为可用。&lt;/p>
&lt;p>删除目录文件：需要首先递归删除目录下所有文件和目录，目录空后再删除该目录。首先在inode表中删除目录文件的inode条目，然后更新imap和bmap将目录占用的inode和数据块设置为可用，最后在该目录所在目录文件中删除目录条目。&lt;/p>
&lt;p>重命名：不会更改inode号&lt;/p>
&lt;p>同目录内重命名（仅修改文件名）：找到所在目录的数据块并更新条目。如果有冲突，会让用户选择是否覆盖，覆盖的过程就是先删除冲突项，然后重命名。&lt;/p>
&lt;p>非同目录内重命名（修改路径）：修改目标目录的数据块，添加该文件记录，然后从源目录删除文件记录。&lt;/p>
&lt;p>将文件移动到不同文件系统则需要先复制再删除。&lt;/p>
&lt;p>存储文件：&lt;/p>
&lt;p>读取GDT，找到有空闲inode号的块组，并且查imap分配一个inode号，在bmap中查空闲块并位文件的inode分配，再把空闲块地址写入inode表中。最后查bmap表分配数据块并填充数据块、更新inode中索引。只能按4K粒度分配&lt;/p>
&lt;h4 id="ext系列文件系统的缺点">EXT系列文件系统的缺点
&lt;/h4>&lt;p>ext系列文件系统本身经过很多年，已经非常可靠和稳定了，只是说相比于一些新的文件系统，他缺少一些更新的功能，比如数据去重，数据压缩、加密和快照等。&lt;/p>
&lt;h4 id="f2fs文件系统">F2FS文件系统
&lt;/h4>&lt;p>&lt;a class="link" href="https://www.cnblogs.com/Linux-tech/p/12961293.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/Linux-tech/p/12961293.html&lt;/a>&lt;/p>
&lt;p>F2FS文件系统的优缺点&lt;/p>
&lt;p>缺点：作为一种日志结构文件系统，必须要经常垃圾回收，这样带来写放大。&lt;/p>
&lt;p>冷热温机制比较简单，是静态定义的。比如对于冷数据，就是通过后缀名来判断，或者是GC以后的数据就是冷数据。那么可以尝试设计一些更准确的冷热区分算法。另外，也可以让用户区指定一个冷热参数。&lt;/p>
&lt;h3 id="linux的存储软件栈">Linux的存储软件栈
&lt;/h3>&lt;p>应用程序 - VFS - 文件系统 - 块层 - 设备驱动 - HDD/SSD&lt;/p>
&lt;h3 id="page-cache">Page Cache
&lt;/h3>&lt;p>Linux上会将文件先读入内存，作为page cache映射到进程的虚拟地址空间。page cache就是struct page中的address_space结构体。每个文件会在内核中只有一份page cache。但是可以有多个进程中的struct file指向。&lt;/p>
&lt;p>page cache不仅是缓存基于文件的数据页，还用于元数据的缓存。不同的page有不同的操作函数，定义在address_space_operations操作集中。&lt;/p>
&lt;p>page cache的数据结构是基数树，用于快速定位某些状态，如脏的页。基数树是一种利用前缀索引快速检索的数据结构，检索复杂度是Ok，k是所有字符串最大长度&lt;/p>
&lt;p>使用page cache和不使用page cache有什么区别&lt;/p>
&lt;p>使用page cache的就是buffer io，不使用page cache的是direct io。他们之间的区别有几点。第一是buffer io的读写性能更好，因为可以在内存中命中，而direct io每次都要访存。第二是buffer io需要占用一定内存存放page cache，但是direct io不需要。第三个是buffer io 不用管理一致性问题和崩溃恢复问题，因为page cache已经实现了这个机制，但是direct io需要自己管理。buffer io适合大多数场景，但是数据库等需要精细控制IO或者是已经实现了自己的缓存的应用就可以跳过page cache。&lt;/p>
&lt;h3 id="使用direct-io需要注意什么">使用direct IO需要注意什么
&lt;/h3>&lt;p>首先需要手动管理数据的一致性，因为direct io只是保证数据落盘，但不会保证元数据都落盘，需要频繁调用fsync保证所有的元数据都落盘。其次还需要自己实现崩溃恢复，出错重发等机制，然后为了保证性能还需要自己实现批量写入和预读的策略，自己实现读写缓冲区。最后还需要把写入数据块的大小和文件系统数据块的大小对齐。&lt;/p>
&lt;p>使用direct io需要在打开文件的时候设置O_DIRECT标志。&lt;/p>
&lt;h3 id="page-cache的一致性与可靠性">Page Cache的一致性与可靠性
&lt;/h3>&lt;p>更新page cache上的页就成了脏页。一方面操作系统内核线程定期写回脏页，另一方面用户可以主动调用fsync和sync同步某个文件和整个文件系统的数据。最后内存压力大时会导致回收文件页（丢弃或回写）&lt;/p>
&lt;p>3个系统调用：fsync：将fd文件的所有脏数据和脏元数据写回磁盘；fdatasync：将fd文件所有的脏数据和必要的元数据写回磁盘。必要的元数据是对访问文件有关键作用的元数据，比如文件大小。但是文件修改时间就不写回。sync：将整个文件系统的脏数据和脏元数据写回磁盘。&lt;/p>
&lt;h3 id="写回和写穿">写回和写穿
&lt;/h3>&lt;p>page cache就是写回模式，direct io就是写穿模式。上面比较过优缺点&lt;/p>
&lt;p>写回实现机制&lt;/p>
&lt;p>每个存储设备会有一个脏文件链表，需要回写时会遍历这个链表确定需要回写的文件。文件的struct page中有脏页标志。&lt;/p>
&lt;p>当write等系统调用修改文件的内容后，内核会调用set_page_dirty将对应脏页置脏。&lt;/p>
&lt;h3 id="目录的存储">目录的存储
&lt;/h3>&lt;p>文件名与inode的映射关系存储在目录文件的目录项中。目录文件就由该目录下目录或文件的目录项组成，目录项在目录文件中组织成哈希表从而便于查询。为了避免逐级从目录文件中查询，操作系统会将最近读取到的目录项缓存在dentry中。dentry是内存中的结构，用于缓存文件名到inode之间的映射，避免逐级查找。&lt;/p>
&lt;h3 id="文件io">文件IO
&lt;/h3>&lt;h4 id="缓冲和非缓冲io">缓冲和非缓冲IO
&lt;/h4>&lt;p>缓冲IO是指利用标准库的缓冲区加速文件访问并累积写回，为了减少系统调用次数。适合大量小规模的数据传输，可以累积写回减少系统调用次数。
非缓冲IO是每次都用系统调用访问文件，可以及时更新。适合数据库等一致性较高的场景。&lt;/p>
&lt;h4 id="buffer-io和direct-io">buffer io和direct io
&lt;/h4>&lt;p>已经说过&lt;/p>
&lt;h4 id="阻塞非阻塞同步异步">阻塞、非阻塞、同步、异步
&lt;/h4>&lt;p>阻塞io是指一个进程发起IO请求后就挂起等待，直到IO请求返回。&lt;/p>
&lt;p>非阻塞IO是指一个进程发起IO请求后，如果不能立刻得到IO结果，就返回错误或提示，并执行其他任务。择机重新发起IO。&lt;/p>
&lt;p>同步io是指进程发起IO后必须等待IO操作完成才能执行后续代码，阻塞和非阻塞IO都可以是同步的。阻塞的同步IO就是等待，非阻塞的同步IO就是轮询或者其他IO多路复用技术。关键在于进程是否需要等待IO的结果。&lt;/p>
&lt;p>异步io就是允许进程发起io后立即执行其他任务，而不用等待IO结果。IO完成后内核会通过回调函数或者信号机制通知进程。&lt;/p>
&lt;p>无论是阻塞、非阻塞轮询还是非阻塞多路复用都是同步的，因为他们接下来的操作依赖于IO的结果，在数据从内核拷贝到用户态的过程中都要等待。&lt;/p>
&lt;p>真正的异步io是内核数据准备好之后从内核态拷贝到用户态，都不用等待。到了用户态以后再通知进程。&lt;/p>
&lt;h2 id="网络系统">网络系统
&lt;/h2>&lt;p>网络系统是操作系统中负责管理网络通信、协议处理和资源共享的模块，通过分层架构实现对物理网络设备的抽象化，并为上层提供统一的接口。&lt;/p>
&lt;h3 id="零拷贝技术">零拷贝技术
&lt;/h3>&lt;p>传统的网络工作方式：硬盘读取数据 - （DMA）- 内核缓冲区 - 用户缓冲区 - 内核socket缓冲区 - （DMA）- 网卡&lt;/p>
&lt;p>2次系统调用（read、write），4次用户态内核态切换（1个系统调用2次），4次数据拷贝（硬盘到内核读缓冲区，读缓冲区到用户缓冲区，用户缓冲区到socket缓冲区，socket缓冲区到网卡）。&lt;/p>
&lt;p>通过零拷贝技术优化：减少系统调用次数 - 减少内核态切换和不使用用户缓冲区 - 减少内存拷贝次数。&lt;/p>
&lt;h3 id="mmapwrite实现三次拷贝">mmap+write实现三次拷贝
&lt;/h3>&lt;p>mmap将内核缓冲区数据映射到用户空间，不需要拷贝，应用程序将数据从内核缓冲区拷贝到socket缓冲区，然后再拷贝到网卡缓冲区。&lt;/p>
&lt;p>4次内核态切换（一次mmap一次write），拷贝三次（硬盘 - 内核缓冲区 - socket缓冲区 - 网卡）&lt;/p>
&lt;h3 id="sendfile">sendfile
&lt;/h3>&lt;p>一次系统调用，直接将内核缓冲区复制到socket缓冲区。&lt;/p>
&lt;p>2次内核态切换（一次sendfile），拷贝三次&lt;/p>
&lt;h3 id="sg-dma零拷贝">SG-DMA零拷贝
&lt;/h3>&lt;p>如果网卡支持聚散DMA技术，可以直接用DMA将磁盘数据复制到内核缓冲区，再用SGDMA将内核缓冲区数据拷贝到网卡。0拷贝是指不需要CPU来拷贝，实际上发生了2次数据拷贝。&lt;/p>
&lt;h3 id="page-cache也有预读失效和缓存污染的问题">Page Cache也有预读失效和缓存污染的问题
&lt;/h3>&lt;p>凡是cache就有预读失效和缓存污染，因此page cache不适合大文件的传输，而只适合热点小文件。&lt;/p>
&lt;p>高并发大文件传输应该使用异步IO+直接IO。工作模式为：前半部分，内核向磁盘发起读请求，但是不等待数据就位就返回。后半部分，当内核将磁盘中的数据拷贝到进程用户缓冲区中，通知进程处理。&lt;/p>
&lt;p>直接IO的应用场景有：应用程序自己实现了缓存、大文件传输（无法命中，还会挤占缓存空间）。&lt;/p>
&lt;p>直接IO无法享受page cache的优化：需要自己调度合并IO请求以减少磁盘寻道&lt;/p>
&lt;p>总之，传输小文件应该使用零拷贝技术、大文件用异步IO+直接IO&lt;/p>
&lt;h3 id="io多路复用">IO多路复用
&lt;/h3>&lt;p>基本socket模型&lt;/p>
&lt;p>网络通信实际上是进程通信中的跨主机进程通信。&lt;/p>
&lt;p>对于TCP socket，服务端需要先调用socket函数创建一个IPv4以及TCP协议的socket，再调用bind函数将器绑定到IP地址和端口号上。&lt;/p>
&lt;p>绑定IP地址：一台机器可能有多个网卡，每个网卡都有对应IP地址。内核收到指定网卡的数据包才会转发给进程，绑定端口：指定通信进程&lt;/p>
&lt;p>绑定IP地址和端口后，调用listen监听。因此可以使用netstat命令查看指定端口有无监听判断网络服务是否启动。&lt;/p>
&lt;p>服务端调用accept获取客户端连接，并从全连接队列中拿出一个已经完成三次握手的socket用于应用程序的网络传输。注意，监听的socket和已连接socket是不同的。&lt;/p>
&lt;p>socket文件的inode指向内核中的socket结构，结构体中有两个队列：发送队列和接收队列。队列中保存的是struct sk_buff，用链表的形式串起来。&lt;/p>
&lt;p>为了减少数据拷贝，网络栈各层次都用一个sk_buff结构描述数据包。通过调整结构体中data的指针剥离和增加各级协议的首部。&lt;/p>
&lt;h3 id="多进程模型">多进程模型
&lt;/h3>&lt;p>服务器连接数受文件描述符数量和系统内存的限制。&lt;/p>
&lt;p>如果服务器为每个客户端都分配一个进程处理请求，则进程数量越多，占用资源也越多，并且切换进程开销大。&lt;/p>
&lt;p>多线程模型&lt;/p>
&lt;p>为每个连接分配一个线程服务请求。线程的频繁创建和销毁占用系统开销，虽然可以采用线程池的方法避免频繁创建和销毁线程，但创建线程数量过多，服务器仍然服务不过来。&lt;/p>
&lt;p>IO多路复用&lt;/p>
&lt;p>用一个进程监控多个IO事件（网络套接字、文件描述符等），从而以更低的资源消耗实现高并发处理。&lt;/p>
&lt;p>select/poll&lt;/p>
&lt;p>select实现多路复用的方式是将需要监听的文件描述符放在一个集合中，调用select函数将集合拷贝入内核，内核每次扫描所有文件描述符，当某个文件描述符上有IO事件则标记该描述符。扫描完后将文件描述符集合拷贝回用户态，用户态接着遍历文件描述符集合找出有标记的并处理。&lt;/p>
&lt;p>因此，select需要2次遍历，2次拷贝文件描述符集合。&lt;/p>
&lt;p>select使用固定长度位图表示文件描述符集合，因此受到位图长度限制。&lt;/p>
&lt;p>poll采用链表形式的动态数组表示文件描述符集合，能存更多文件描述符，但是还收到系统文件描述符个数限制。&lt;/p>
&lt;p>但poll和select的原理几乎相同，因此开销还是很大。&lt;/p>
&lt;p>epoll&lt;/p>
&lt;p>epoll在内核中维护了一颗红黑树，用来跟踪进程所有待检测的文件描述符。进程新增监控socket时只需要传入这一个socket，而不需要复制整个集合。&lt;/p>
&lt;p>epoll使用事件驱动机制，维护了一个记录就绪IO链表。当某个socket或文件描述符上有IO事件发生时，通过回调函数将其加入就绪事件链表中。用户调用epoll_wait时只会返回有IO事件的文件描述符，而不需要遍历。&lt;/p>
&lt;p>使用epoll：epoll_create创建epoll对象，epoll_ctl将待检测的socket传入红黑树，epoll_wait得到有IO事件的文件描述符。&lt;/p>
&lt;p>因此epoll可以解决c10k问题，因为监听socket数量增加时不会大幅降低性能。&lt;/p>
&lt;p>边缘触发和水平触发&lt;/p>
&lt;p>边缘触发是指当监控的文件描述符上有IO事件时，epoll_wait只会返回fd一次，因此需要保证一次性处理完IO事件，例如将数据从内核缓冲区读取完。&lt;/p>
&lt;p>水平触发是指监控的文件描述符上有IO事件时，每次epoll_wait都会返回该fd，直到处理完IO事件。&lt;/p>
&lt;p>边缘触发适用于高并发、高性能系统，能够减少重复通知，但是开发时需要小心事件丢失。并且边缘触发只能用于非阻塞IO，以避免没有一次性处理完数据导致事件丢失。&lt;/p>
&lt;p>例如使用阻塞IO读取数据，　&lt;/p>
&lt;ol>
&lt;li>客户端发送 2000 字节数据，触发一次 EPOLLIN 事件。&lt;/li>
&lt;li>服务端调用 read 读取 1024 字节（缓冲区剩余 1024 字节）。&lt;/li>
&lt;li>由于未处理完数据且使用阻塞 I/O，线程将阻塞在下一个 read 调用上。&lt;/li>
&lt;/ol>
&lt;p>后果：　
• 剩余字节数据滞留在内核缓冲区，但 ET 模式不会再次触发 EPOLLIN 事件。当前线程阻塞，但其他的线程也无法感知该fd。
如果循环调用read，可能会使得缓冲区读完后read卡在空缓冲区上。&lt;/p>
&lt;p>水平触发适用于并发量较低，需要快速调试，容错性强的应用，容易实现。但是性能不如边缘触发，因为存在不必要的事件通知、每次通知都存在上下文切换开销。&lt;/p>
&lt;h3 id="reactor模式">Reactor模式
&lt;/h3>&lt;p>reactor模式是对IO多路复用的封装，是一种高性能网络模式。&lt;/p>
&lt;p>reactor模式包含3种组件：reactor，acceptor和handler&lt;/p>
&lt;p>reactor负责监听IO事件（epoll监控文件描述符）并分发给对应处理器&lt;/p>
&lt;p>acceptor负责接收新连接并注册到reactor的监控列表中&lt;/p>
&lt;p>handler负责处理具体业务逻辑&lt;/p>
&lt;p>工作流程是应用程序将感兴趣的事件，如某些文件描述符上的读、写等注册到reactor；reactor监听事件；事件触发后reactor根据事件类型分发给响应handler，handler通过非阻塞IO执行业务逻辑，或者委派给某个线程池中线程执行，完成后重新注册事件（边缘触发：如有剩余数据则可以下一次事件到来时继续处理；水平出发：可以明确事件监听范围，如从读切换到写，减少无效事件通知）&lt;/p>
&lt;p>单线程reactor模型：三种组件的功能在一个线程中执行，因此没有多线程竞争问题，避免线程切换。但是无法利用多核CPU，并且线程崩溃会导致服务不可用。适合客户端数量少，业务快速的场景。&lt;/p>
&lt;p>多线程reactor模型：主线程负责事件的监听与分发，业务逻辑由线程池中线程异步处理。可以利用多核CPU处理计算密集型任务，使用线程池可以减少创建销毁线程的开销。但是主线程可能成为瓶颈，多线程存在数据竞争。适用客户端数量适中，业务处理较长的场景。&lt;/p>
&lt;p>主从reactor模型：引入负责连接的主reactor和多个负责IO的子reactor，主reactor将连接分配到子reactor中由子reactor负责后续IO事件。可以减少单点压力，并且可以动态调整子reactor数量以适应负载。但是复杂度高，适用于高并发系统。&lt;/p>
&lt;h3 id="proreact模式">Proreact模式
&lt;/h3>&lt;p>reactor是非阻塞同步网络模式，每次感知到由IO事件就需要应用主动调用read读取，因此是同步的，基于待完成的IO事件&lt;/p>
&lt;p>proreact是异步网络模式，发起异步读写请求时需要传入数据缓冲区的地址，内核会处理IO事件并将结果通知给应用。是异步的，基于已完成的IO事件。&lt;/p>
&lt;p>linux不支持真正的异步io，windows支持。&lt;/p>
&lt;h3 id="负载均衡问题">负载均衡问题
&lt;/h3>&lt;p>多个节点如何分配客户端请求。&lt;/p>
&lt;p>引入一个中间的负载均衡层，负责分配请求。&lt;/p>
&lt;p>对于每个节点存储数据相同的情况，可以使用加权轮询算法，即根据节点的硬件配置设置权值，将请求轮流转发给各节点。&lt;/p>
&lt;p>对于分布式系统，每个节点存储的数据不同。使用哈希算法则可以根据key定位到数据所在节点。但是不便于系统扩容和节点故障的情况，因为会破坏哈希映射至，导致大量数据迁移。&lt;/p>
&lt;p>一致性哈希算法将数据与节点映射到同一个哈希环上，数据根据哈希值定位到环上位置后，沿顺时针找到最近的节点作为归属，则增加节点只影响顺时针相邻的后继节点，从而减少数据迁移量。&lt;/p>
&lt;p>但是一致性哈希算法不能保证节点在哈希环上均匀分布。可以引入虚拟节点机制将物理节点映射成多个虚拟节点分散到哈希环的不同位置。因为物理节点直接计算出的哈希值可能是很集中的，但可以对每个物理节点计算多个虚拟哈希值。&lt;/p>
&lt;p>虚拟节点优点在于：1. 解决物理节点分布不均2. 高性能节点可以分配更多虚拟节点3.移除某个物理节点时数据均匀迁移到不同其他节点，避免单一节点承受过多压力，分散影响。&lt;/p>
&lt;h2 id="进程管理">进程管理
&lt;/h2>&lt;h3 id="进程线程协程">进程，线程，协程
&lt;/h3>&lt;p>进程是操作系统资源调度的基本单位，拥有自己的资源，包括内存地址空间，堆和栈。优点：拥有自己的地址空间，稳定性和安全性（无法访问其他进程的地址空间和堆栈资源）较高。缺点：切换进程的开销较大，需要保存上下文，进程之间通信比较复杂&lt;/p>
&lt;p>线程是CPU调度的基本单位，和同一进程中的其他线程共享资源。优点：创建线程资源开销小，线程之间通信方便（可以直接共享内存），切换线程方便（只需要保存线程级别的上下文，不需要保存进程状态）。缺点：线程之间存在数据竞争的问题，需要同步和互斥机制解决。&lt;/p>
&lt;p>协程是一种轻量级的用户态线程，调度由用户程序控制，不需要内核参与。因此没有上下文切换开销，适合大量并发任务。缺点就是实现比较复杂。&lt;/p>
&lt;h3 id="linux用task_struct管理进程">Linux用task_struct管理进程
&lt;/h3>&lt;p>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/457403125" target="_blank" rel="noopener"
>https://zhuanlan.zhihu.com/p/457403125&lt;/a>&lt;/p>
&lt;p>每个进程由进程控制块管理，在Linux中进程控制块是task_struct结构体。&lt;/p>
&lt;p>其中有一个指针叫做stack，指向内核栈。&lt;/p>
&lt;p>与线程有关的资源在thread_struct中，比如寄存器状态等，具体和硬件架构有关。&lt;/p>
&lt;h3 id="一个进程崩溃不会影响其他进程">一个进程崩溃不会影响其他进程
&lt;/h3>&lt;p>进程之间具有隔离性，一个进程崩溃不会影响其他进程的地址空间、网络连接等资源。&lt;/p>
&lt;h3 id="什么是分配给进程的资源">什么是分配给进程的资源
&lt;/h3>&lt;p>包括虚拟内存，比如代码段，全局变量静态变量区域，堆文件描述符，还有信号量，网络套接字等。&lt;/p>
&lt;h3 id="为什么要在进程之下设计线程">为什么要在进程之下设计线程
&lt;/h3>&lt;p>当一个软件的功能比较复杂的时候，需要一种程序运行的实体，既能并发执行，又能够方便的相互通信。如果单独采用进程的话，一个进程只能同步执行一系列操作，没办法并发。采用多个进程的话，进程之间通信不方便，并且消耗系统资源多。因此在一个进程下面设计线程，能够满足并发执行和通信方便的需要。&lt;/p>
&lt;h3 id="多线程和单线程的比较">多线程和单线程的比较
&lt;/h3>&lt;p>多线程可以并发或者并行处理多个任务，提高执行效率，充分利用CPU计算能力。但是可能导致数据竞争和死锁，并且会占用更多CPU和内存资源。
如果线程过多，总体上占用的系统资源（栈，程序计数器，寄存器状态，线程控制块等）也会上升。并且C++中一个线程崩溃还会导致所属的进程崩溃。&lt;/p>
&lt;h3 id="c中线程崩溃导致进程崩溃">C++中线程崩溃导致进程崩溃
&lt;/h3>&lt;p>如果某个线程非法访问了地址，例如访问了只读内存、不存在的地址或者没有权限的地址（内核地址空间），那么会产生segmentation fault，导致进程崩溃。这是因为线程共享地址空间，出现非法访问可能会导致内存的不确定性，进而影响其他线程，因此会将进程崩溃。&lt;/p>
&lt;p>具体是发现非法访问内存后，内核会给进程发送kill信号&lt;/p>
&lt;h3 id="进程切换和线程切换">进程切换和线程切换
&lt;/h3>&lt;p>进程切换的开销比线程切换要大。进程切换时需要保存虚拟地址空间里的信息，比如全局变量，堆，栈，文件描述符，等等用户空间的资源，还要保存内核态的栈，寄存器(CPU寄存器、程序计数器)。这些信息保存在进程控制块内。然后我们取出另一个进程的进程控制块，并且恢复这个进程的上下文。取出PCB的过程可能涉及缺页。&lt;/p>
&lt;p>如果两个线程是同一个进程的，那线程切换比进程切换简单，只需要保存上一个线程的栈，程序计数器还有其他寄存器。地址空间是共享的。如果属于不同进程那就和进程切换一样。&lt;/p>
&lt;h3 id="进程的状态">进程的状态
&lt;/h3>&lt;p>运行态，就绪态，阻塞态，创建态和结束态。如果大量进程处于阻塞状态就会交换到外存，那么就是挂起态。挂起有阻塞挂起和就绪挂起。&lt;/p>
&lt;h3 id="进程的控制">进程的控制
&lt;/h3>&lt;p>进程的控制信息保存在PCB结构里，包括进程的id，用户的id，进程的状态，进程的资源比如地址空间mmstruct，文件描述符等，还有CPU寄存器的值（切换上下文的时候保存）。&lt;/p>
&lt;p>相同状态的PCB组织成链表。形成各种队列，比如就绪队列，阻塞队列&lt;/p>
&lt;p>创建进程：首先创建一个PCB结构，并且填入进程相关信息，比如pid，用户和组。然后分配必须资源，如地址空间。最后插入到就绪队列等待调度&lt;/p>
&lt;p>阻塞进程：首先从运行队列中找到PCB，然后保存上下文，并且修改状态为阻塞，最后插入阻塞队列&lt;/p>
&lt;p>唤醒进程：首先从阻塞队列找到PCB，然后修改状态为就绪，最后插入就绪队列&lt;/p>
&lt;p>终止进程：首先从队列中找到PCB，如果正在运行就停止运行并调度其他的进程。然后检查是否有子进程并将子进程转移给1号进程收养，再释放进程的资源，最后删除PCB。&lt;/p>
&lt;p>进程的终止有自己正常终止（比如main函数返回，或者调用exit），也可能异常终止（如被kill掉。有可能是程序逻辑错误或者访问非法内存，也可能是被手动kill掉）。&lt;/p>
&lt;p>父进程终止：子进程变成孤儿进程，被1号进程收养。子进程终止：将资源归还给父进程。&lt;/p>
&lt;p>进程阻塞一般是去等待某些IO事件，或者等待锁和子进程终止。注意时间片耗尽不会导致阻塞，而是导致进入就绪队列。&lt;/p>
&lt;h3 id="进程的用户态和内核态">进程的用户态和内核态
&lt;/h3>&lt;p>用户态：是CPU运行用户程序的一种模式，权限较低，不能直接访问硬件资源。用户态负责运行用户应用程序。&lt;/p>
&lt;p>内核态：是CPU运行操作系统内核的一种模式，拥有最高权限，可以直接访问硬件资源。内核态负责管理系统的核心功能，如进程调度、内存管理、驱动等。&lt;/p>
&lt;p>之所以要区分内核态和用户态，是为了保证操作系统的隔离性。一方面，恶意的用户应用可能攻击操作系统，正常的应用也可能会故障。如果这些应用能够执行特权指令可能会导致整个系统的崩溃。另一方面，把内核态和应用态区分开也可以方便用户编程，不用考虑底层的实现和不同硬件的差异。只需要使用操作系统提供的抽象。&lt;/p>
&lt;p>用户态切换到内核态的方式有系统调用、中断、异常。只有系统调用是用户主动陷入内核的。&lt;/p>
&lt;p>系统调用：注意系统调用中不涉及进程切换，始终是同一个进程，只是状态变了。系统调用属于一种陷阱&lt;/p>
&lt;p>进程的上下文包括CPU中寄存器的值，进程的状态以及栈的内容。linux中进程的上下文保存在task struct结构体中。但是在特权模式切换的时候只需要保存寄存器级别的上下文，比如程序计数器，寄存器状态和栈指针，因为系统调用以后还是同一个进程，并没有切换进程。&lt;/p>
&lt;ol>
&lt;li>用户态进程调用某个系统调用函数&lt;/li>
&lt;li>系统调用函数将参数和对应的系统调用号写入特定的寄存器，并执行syscall指令触发CPU状态切换，跳转到内核入口函数&lt;/li>
&lt;li>把用户态的上下文压入内核栈中保存，比如pt regs结构体&lt;/li>
&lt;li>设置内核栈指针，并从寄存器取得系统调用号并调用相应的系统调用处理函数，并将参数从寄存器传递给该函数&lt;/li>
&lt;li>内核态任务执行完后将返回结果存入寄存器中并通过sysret指令回到用户态。这个过程中还会恢复用户态的上下文。&lt;/li>
&lt;/ol>
&lt;p>系统调用由应用程序主动触发，完成服务后返回原执行流。&lt;/p>
&lt;h3 id="异常和中断由程序错误或外部事件强制触发可能终止原执行流">异常和中断由程序错误或外部事件强制触发，可能终止原执行流
&lt;/h3>&lt;p>异常：异常是程序运行中出现的非预期情况或错误。比如程序要执行一个非法操作（除以0），或者访问的页面不在内存中。异常发生后会被操作系统捕获，并执行异常处理函数。&lt;/p>
&lt;p>发生异常同样会切换到内核态。对于page fault会从外存中调入页面，对于除以0等错误，会直接杀死进程或重启进程。&lt;/p>
&lt;p>中断就是CPU停止执行当前任务，去处理其他的事情，处理完再返回当前任务。&lt;/p>
&lt;p>中断分为硬中断和软中断。硬中断是由于外部硬件设备的变化导致的中断，分为可屏蔽和不可屏蔽的。可屏蔽的中断通常是一些设备的IO事件，比如敲键盘，点鼠标，还有可能是打印机缺页等。这些中断不处理不会导致操作系统崩溃，所以可以屏蔽。不可屏蔽中断一般是一些致命错误，比如突然断电等。&lt;/p>
&lt;p>软中断是软件触发的中断机制，不直接由硬件产生。主要用于延迟处理，将不需要立即执行的任务安排到稍后执行。&lt;/p>
&lt;p>为了避免中断处理程序过长，将中断分为上半部和下半部。上半部一般是硬件触发的硬中断，用来快速处理和硬件紧密相关或者时间敏感的请求，下半部一般是内核触发的软中断，以内核线程的方式延迟处理上半部未完成的工作。除了下半部外，一些内核自定义事件也属于软中断，比如内核调度、RCU锁等&lt;/p>
&lt;p>硬中断是外部硬件设备触发的，是异步随机发生的，可以设置优先级，有些可以屏蔽，要求尽快响应完成，支持中断嵌套，在中断上下文中执行。&lt;/p>
&lt;p>软中断是内部软件指令触发的，是同步触发的，没有优先级，不可以屏蔽，可以延迟执行，可重入（允许被硬中断抢占），在进程上下文或内核线程中执行。&lt;/p>
&lt;p>软中断的调度时机一般是某个硬中断退出时，或在cpu负载较低时唤醒ksoftirqd线程处理软中断。&lt;/p>
&lt;p>中断通常是异步的，陷阱通常是同步的。意思是中断通常是CPU执行某些任务时被打断。而陷阱是CPU主动在已知的地方发生&lt;/p>
&lt;p>中断的过程首先是接收到中断信号，如果没有屏蔽该中断，就保存当前现场，包括寄存器和栈指针，程序计数器等。接着根据中断向量号找到对应的中断处理函数，并切换到内核态执行中断处理函数。中断处理结束后再恢复上下文，并切换回用户态接着执行之前的指令。&lt;/p>
&lt;p>正常状态下中断处理并不切换进程。&lt;/p>
&lt;h3 id="用户线程和内核线程">用户线程和内核线程
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.cnblogs.com/FengZeng666/p/14219477.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/FengZeng666/p/14219477.html&lt;/a>&lt;/p>
&lt;p>用户线程就是有用户态应用程序或者函数库管理的线程，这类线程只运行在用户态，操作系统是看不见的。优点：不需要切换内核模式，节省开销；允许应用自行调度，更加灵活；缺点：操作系统只能看到进程，所以一个用户线程阻塞会导致进程阻塞；一个进程中的用户线程也没办法利用不同的CPU并行执行；一个线程不可能抢占另一个线程，因为没有这个特权；时间片是分配给进程的，所以用户线程需要共享时间片，一个线程得到的时间片较少。&lt;/p>
&lt;p>内核线程是操作系统直接支持管理的，优点：一个线程阻塞了，还可以调度别的线程运行；同一个进程的不同线程可以在不同CPU并行执行；得到的时间片比较多。缺点：线程调度需要切换内核态；&lt;/p>
&lt;p>线程的映射：用户态线程在系统调用等与内核有关的操作需要内核线程协助。用户线程和内核线程的映射有多对一，一对一，多对多。&lt;/p>
&lt;p>多对一就是用一个内核线程服务多个用户线程，那么其他想进入内核态的用户线程就被堵塞了。一对一是每个用户态线程都可以映射到一个内核线程。但是创建内核线程会有一定开销。Linux和windows都是一对一的。&lt;/p>
&lt;p>多对多就是用少量的内核线程服务大量的用户线程，可以减轻阻塞其他用户线程，也可以减少占用资源。但是管理复杂。&lt;/p>
&lt;h3 id="进程间通信">进程间通信
&lt;/h3>&lt;p>进程通过虚拟地址空间实现了隔离性，因此进程之间的协作需要专门的通信机制。&lt;/p>
&lt;p>宏内核进程间通信有管道、消息队列、共享内存、信号量、信号和socket机制。
• 管道：字节流、两个进程、单向、匿名和命名
• 消息队列：消息体、多个进程、单向或双向
• 共享内存：内存区间、多进程、单向或双向
• 信号量：计数器、多进程、单向或双向、同步和互斥
• 信号：事件编号、多进程、单向
• 套接字：数据报文、两个进程、单向或双向、网络栈&lt;/p>
&lt;h4 id="管道">管道
&lt;/h4>&lt;p>管道就是一个单向队列，一端发送一端接收。&lt;/p>
&lt;p>有匿名管道和命名管道。
• 匿名管道就是bash命令中的竖线，只允许临时将前面的输出传递给后面的输入。
• 命名管道需要用mkfifo创建，将数据写入命名管道后终端会阻塞，直到另一端被读出。
• 管道通信效率低，不适合进程之间频繁交换数据&lt;/p>
&lt;p>匿名管道通过系统调用pipe，在内核中开辟了一块内存缓冲区，并返回两个文件描述符。文件描述符用于读和写缓冲区。&lt;/p>
&lt;p>匿名管道只能用于父子进程和子进程之间的通信，这是因为子进程会继承父进程的文件描述符表，从而找到内核缓冲区。&lt;/p>
&lt;p>命名管道通过函数mkfifo创建，可以用于不相关进程之间的通信。因为命名管道有一个具体的路径名，可以像文件一样打开。不过实际上并不存在于磁盘，而是一个内存缓冲区。&lt;/p>
&lt;p>由于匿名管道和命名管道文件都是先进先出的，所以不支持lseek操作。&lt;/p>
&lt;p>管道传递的是无格式的字节流。&lt;/p>
&lt;h4 id="消息队列">消息队列
&lt;/h4>&lt;p>消息队列是一个保存在内核的消息链表，链表的每一个节点都是一个消息体。消息的发送方和接收方约定好消息体的格式，发送方将数据放在消息队列中就返回，接收方需要时去队列中取得数据，因此是非阻塞的。&lt;/p>
&lt;p>消息队列的生命周期随内核，如果不释放消息队列或关闭操作系统，则消息队列一直存在。但是管道的生命周期随进程，引用管道的进程终止则管道消失。&lt;/p>
&lt;p>消息队列适合频繁交换数据，因为是非阻塞的。但缺点是不适合大量数据传输，因为消息体有大小限制，并且消息队列在内核，因此有用户态和内核态之间的数据拷贝开销。管道比消息队列更快，因为不需要消息体的封装与解封装。&lt;/p>
&lt;h4 id="共享内存">共享内存
&lt;/h4>&lt;p>管道和消息队列都要利用内核缓冲区，因此会有拷贝开销。&lt;/p>
&lt;p>共享内存机制是将不同进程的虚拟地址空间映射到相同的物理地址空间。优点是不需要用户态和内核态之间的拷贝，缺点是产生数据竞争。&lt;/p>
&lt;h4 id="信号量">信号量
&lt;/h4>&lt;p>为了解决数据竞争引入信号量实现进程之间的互斥与同步。&lt;/p>
&lt;p>信号量就是一个整形计数器，因此并不能缓存数据，而是表示能进入临界区的进程数量。&lt;/p>
&lt;p>信号量有两个原子操作：P是信号量-1，V是信号量+1.P时信号量&amp;lt;0则P阻塞，V后信号量&amp;lt;=0则表示有进程需要唤醒。P和V必须成对使用。&lt;/p>
&lt;p>信号量初始化为1则为互斥锁。信号量初始化为0可以实现进程同步：另一个进程执行完后再V，这是当前进程就可以P然后执行。&lt;/p>
&lt;h4 id="信号">信号
&lt;/h4>&lt;p>信号用于单向的事件通知而不是数据传输。信号量也可以通知，但是需要进程主动查询信号量。信号则可以随时通知另一个进程，并且另一个进程不需要阻塞等待，内核会切换到处理函数。&lt;/p>
&lt;p>Linux内核为sigint等信号提供了默认处理函数，也可以自己定义信号处理函数。还可以屏蔽信号。但是sigkill等有些信号是不能屏蔽的，因为用于终止一个进程。&lt;/p>
&lt;p>信号处理并不是中断处理。因为处理信号的时机一般是进程从内核态返回用户态之前。信号处理函数一般在用户态执行，上下文会保存在用户栈上。如果信号处理函数中有系统调用则再次进入内核态。&lt;/p>
&lt;p>信号与中断的联系与区别：
• 联系：1. 都是异步通信机制；2. 处理完毕时返回原来的断点；3. 有些中断或信号可以屏蔽
• 区别：1.中断有优先级，信号没有优先级；2.信号处理程序在用户态运行，中断处理程序在内核态运行；3. 中断响应是即时的，而信号响应有一定延迟。&lt;/p>
&lt;h4 id="socket">socket
&lt;/h4>&lt;p>不同主机进程之间通信需要跨网络。&lt;/p>
&lt;p>socket创建参数有协议、报文类型。可以实现TCP、UDP和本地进程间通信。&lt;/p>
&lt;p>• TCP通信过程
◦ 服务端通过socket创建套接字，并使用bind将套接字绑定到特定的IP地址和端口上。接着调用listen监听客户端的连接请求。
◦ 客户端通过socket创建套接字后，调用connect向服务端指定IP地址和端口发起连接请求
◦ 服务端正在监听该端口并不超过最大连接数，则完成三次握手并建立连接。调用accept返回一个文件描述符代表与客户端的连接并开始数据交换。
◦ 客户端断开连接则调用close，服务端读取数据时读到EOF，处理完数据后调用close表示连接关闭。
◦ 注意：监听的socket和建立连接的socket并不一样。建立连接后双方通过read write或send recv向建立连接的socket读写数据。
• UDP通信过程
◦ 服务端和客户端分别使用socket创建套接字并绑定到某个端口。
◦ 通信时通过sendto和recvfrom。
◦ 通信完成后调用close关闭套接字
• 本地socket
◦ 可以是有连接的，也可以是无连接的
◦ 区别是在socket绑定时绑定一个本地文件系统中的路径作为地址。&lt;/p>
&lt;h3 id="线程的互斥同步和锁信号量">线程的互斥、同步和锁、信号量
&lt;/h3>&lt;p>多线程同时操作竞争变量时，非原子操作和并发会导致不可预期的结果。含有竞争变量的代码是临界区，我们希望同一时间只有一个线程进入临界区。这叫做线程的互斥。&lt;/p>
&lt;p>多个线程协作时，有些线程需要等待另一些线程的执行结果。因此需要保证线程之间的执行顺序，这叫做线程的同步。&lt;/p>
&lt;p>主要采用锁和信号量机制实现线程之间的互斥与同步。&lt;/p>
&lt;h3 id="锁">锁
&lt;/h3>&lt;p>任何进入临界区的线程必须先获得锁，然后进入。如果一个线程持有锁，其他请求锁的线程需要等待。&lt;/p>
&lt;p>• 自旋锁
◦ 属于一种互斥锁，但被锁住的线程会一直请求锁而不会阻塞，避免线程切换开销
◦ 只能适用于非常轻量的临界区
• 无等待锁
◦ 当线程获取不到锁的时候就阻塞，进入锁的等待队列&lt;/p>
&lt;h3 id="操作系统中常见的锁">操作系统中常见的锁
&lt;/h3>&lt;p>• 互斥锁
◦ 只有获得锁的线程能访问资源，其他线程必须等待锁的释放
◦ 依赖于硬件的test and set原子操作实现。一个线程获取互斥锁时检查状态，如果空闲则设置上锁，如果已锁则被阻塞
• 读写锁
◦ 支持并发读取，但只允许一个线程写入。
◦ 有读锁时可以获取读锁，但是写者阻塞；有写锁时读写均阻塞
◦ 两个计数器实现，一个记录读者数量，另一个记录是否有写者
• 条件变量
◦ 多线程之间传递信号和状态信息
◦ 用于实现阻塞互斥锁。允许线程在得不到锁的时候阻塞而不是自旋，当锁释放后可以通过条件变量唤醒一个或所有阻塞的线程。
• 信号量
◦ 通用的同步互斥原语
◦ 用于实现互斥：信号量代表可以同时访问临界区的线程数量，小于0时阻塞
◦ 用于实现同步：上一个线程获取信号量并置为0，下一个线程需要等上一个线程V之后才能执行。
• 乐观锁
◦ 并不实际加锁，认为数据冲突不常见。通过在执行临界区后检查数据版本号或者时间戳查看是否发生了数据竞争。如果发生了就回滚
◦ 例如在线文档、git等。git就是允许用户各自修改，只有提交时冲突了才要求各自修改后提交。
◦ 不适合经常冲突的场景，因为回滚的成本高
• 悲观锁
◦ 通过严格的锁或信号量机制保证某一时刻只有一个线程访问临界区&lt;/p>
&lt;h3 id="生产者-消费者问题">生产者-消费者问题
&lt;/h3>&lt;p>问题描述：生产者生成数据后放在一个缓冲区，消费者从缓冲区取出数据处理，任意时刻只能有一个生产者或消费者可以访问缓冲区。&lt;/p>
&lt;p>需要3个信号量：互斥信号量用于所有进程互斥进入临界区、资源信号量用于消费者进程等待生产者进程生产、空槽信号量用于生产者进程等待消费者产生空槽。&lt;/p>
&lt;p>生产者进程和消费者进程都是死循环，生产者先P空槽、再P互斥、进入临界区、V互斥、V资源。消费者P资源、P互斥、进入临界区、V互斥、V空槽。&lt;/p>
&lt;h3 id="哲学家就餐问题">哲学家就餐问题
&lt;/h3>&lt;p>问题描述：5个哲学家围成圆圈，每人中间有一把叉子。哲学家必须拿起两把叉子吃饭，吃完后会放回两把叉子。不能死锁&lt;/p>
&lt;p>如果只有叉子信号量，则有可能每个哲学家都拿起左手的叉子。&lt;/p>
&lt;p>可以增加互斥信号量，认为拿叉子是临界操作，同一时刻只有一个哲学家拿叉子。但是并发性低。改进：为哲学家定义状态：饥饿、进餐、思考。只有两个邻居都没有进餐的时候才能进餐。因此在获取互斥量之前检查两边哲学家状态。如果不是都饥饿就阻塞。吃完后通知其他哲学家。实际上将这个互斥信号量用于同步。
还可以为哲学家编号，让偶数哲学家先拿左边叉子，奇数哲学家先拿右边叉子。&lt;/p>
&lt;h3 id="读者写者问题">读者写者问题
&lt;/h3>&lt;p>问题描述：允许同时读、没有写者才能读、没有读者才能写、没有其他写者才能写。&lt;/p>
&lt;p>读者优先策略：采用一个临界区互斥信号量、读者计数器和一个读者互斥信号量，临界区互斥信号量用于控制进入临界区、读者计数器用于记录当前读者数量，读者互斥信号量用于控制读者计数器的修改。
读计数代表了一个读者等待队列，当队列中有读进程时，就可以到达更多的读进程，而写进程被则阻塞在写等待信号量上，因此会导致写者饥饿。&lt;/p>
&lt;p>写者优先策略：对读写进程分别计数，并对计数变量分别用mutex保护。增加写互斥信号量用于写者之间互斥，增加读等待信号量用于读者等待写者。这种方案中写者来后不允许读者进入，读者来后却允许写者堵塞读者。因此对写者有利
读写计数分别代表了两个读写等待队列。当读队列中有读进程时，可以来更多的读进程。但是来了一个写进程就会导致更多的读进程被阻塞在读等待信号量上，因此读队列会慢慢减少。反之，写队列中有写进程，则允许更多的写进程进入写队列排队，但来读进程并不能阻塞更多的写进程进入写队列。所以会导致读进程饥饿。&lt;/p>
&lt;p>读写公平策略：在读者优先策略上增加一个初始为1的flag信号量。读者和写者必须先获取flag信号量再进入逻辑。这是为了写者来后可以阻塞后来的所有进程，读者来后也可以阻塞后来的写进程。
flag信号量可以让写进程阻止更多的读进程进入读队列，而读进程也可以将写进程阻塞在写等待信号量上。&lt;/p>
&lt;p>伪代码：
• 读者优先&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 读者优先采用临界区互斥、读计数器和读计数器互斥
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">rCount&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">mutex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">rCMutex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">writer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">write&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">reader&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 第一个读者，阻塞后来所有的写者
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">++&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">read&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 最后一个读者
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">--&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>• 写者优先&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 读计数器、写计数器、计数器信号量、读等待信号量、写等待信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">rCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">wCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">rCMutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">wCMutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">rWMutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">wWMutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">writer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">wCount&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 第一个写者阻塞所有读者
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rWMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">++&lt;/span>&lt;span class="n">wCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wWMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">write&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wWMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">wCount&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rWMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">--&lt;/span>&lt;span class="n">wCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">reader&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rWMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wWMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">++&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rWMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">read&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">wWMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">--&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCMutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>• 读写公平&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-C++" data-lang="C++">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 增加一个flag信号量，使得读写双方公平竞争flag信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">rCount&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">mutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">rCMutex&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">writer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">write&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">reader&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">++&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">read&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">--&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rCount&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="避免死锁">避免死锁
&lt;/h3>&lt;p>死锁就是多个线程相互等待对方释放锁。&lt;/p>
&lt;h4 id="死锁产生条件">死锁产生条件
&lt;/h4>&lt;p>互斥、持有等待、不可剥夺、环路等待。&lt;/p>
&lt;p>互斥：多个线程不能同时访问资源&lt;/p>
&lt;p>持有等待：线程在请求锁时不会释放自己的锁&lt;/p>
&lt;p>不可剥夺：线程的锁在主动释放之前不能被其他线程获取&lt;/p>
&lt;p>环路等待：多个线程获取资源的顺序构成环形图&lt;/p>
&lt;h4 id="排查死锁问题">排查死锁问题
&lt;/h4>&lt;p>Linux下可以使用pstack和gdb定位死锁。pstack可以显示每个线程的栈跟踪信息：pstack pid。查看进程下线程的函数调用过程，对比结果查看哪几个线程一直没有变化，并且被锁住的线程一般会卡在某某lock wait函数处。还可以通过gdb工具查看线程等待的互斥锁对象信息，看看是不是被对方持有。&lt;/p>
&lt;h4 id="避免发生死锁问题">避免发生死锁问题
&lt;/h4>&lt;p>破坏互斥、持有等待、不可剥夺或环路等待之一。&lt;/p>
&lt;p>资源有序分配法破坏环路等待。资源有序分配是给会产生竞争的资源编号，每个线程总是按序号从小到大申请资源，这样不会导致先申请大号资源再申请小号资源带来的环路问题。&lt;/p>
&lt;p>破坏互斥就是乐观锁或者将所有资源都拷贝，比如RCU机制，破坏持有等待就是要求线程一次性申请所有需要的资源，不太实际。破坏不可剥夺条件是抢占式分配，就是释放低优先级进程资源并分配给高优先级线程，要求低优先级线程稍后重新申请。&lt;/p>
&lt;p>银行家算法:一个进程申请使用资源时，先试探分配所需资源，检查分配后的系统是否处于安全状态。若是则分配，否则不分配。
其中，安全状态是指系统可以通过调整进程执行顺序，即存在安全序列，使得所有进程都能获得所需资源并顺序完成。
银行家算法的缺点在于，需要事先直到进程所需的最大资源总数，但是进程的需求是变化的。并且实现复杂，需要用到很多数据结构。算法倾向保持一定余量放置不安全状态，因此会产生浪费。安全性检查耗时影响性能。不适合实时系统，因为进程会被阻塞直到找到安全序列。&lt;/p>
&lt;h3 id="进程可以创建多少个线程">进程可以创建多少个线程
&lt;/h3>&lt;p>进程在虚拟地址空间上创建线程，在32位系统下，因为用户态空间只有3G，所以线程的上限与线程的栈空间大小有关（线程的资源就是栈和一些寄存器）。理论上3G除以栈大小。
64位系统下，虚拟地址空间非常大，因此主要受操作系统参数或性能限制，有参数控制整个系统的最大线程个数。&lt;/p>
&lt;h2 id="设备管理">设备管理
&lt;/h2>&lt;h3 id="cpu通过设备控制器操作设备">CPU通过设备控制器操作设备
&lt;/h3>&lt;p>每个设备都有对应的设备控制器，其中有自己的芯片、寄存器等，可以自行执行逻辑。&lt;/p>
&lt;p>设备控制器有三类寄存器：数据寄存器、命令寄存器和状态寄存器。&lt;/p>
&lt;p>操作系统通过写入命令寄存器，向设备发送命令；写入数据寄存器向设备输出数据；设备完成命令后将状态写入状态寄存器，CPU读取状态寄存器了解命令执行情况；CPU读取数据寄存器输入数据。&lt;/p>
&lt;h3 id="io设备分为块设备和字符设备">IO设备分为块设备和字符设备
&lt;/h3>&lt;p>块设备以数据块为数据处理单位，每个块有自己的地址。如硬盘、闪存等。&lt;/p>
&lt;p>字符设备以字符为单位发送或接收字节流，字符设备不可寻址。如鼠标等。&lt;/p>
&lt;p>块设备的数据传输量大，在控制器中存在数据缓冲区。读写数据时会累积读写提升性能。&lt;/p>
&lt;p>CPU通过端口和内存映射与设备控制器通信。端口IO（Port IO）：每个寄存器分配一个IO端口，通过汇编指令操作。内存映射IO（MMIO）：所有的寄存器映射到内存空间中，像读写内存一样控制数据缓冲区。&lt;/p>
&lt;p>端口IO：不占用内存地址空间，通信相对简单。但是需要专门指令访问。端口与处理器架构相关&lt;/p>
&lt;p>MMIO：可以利用内存管理机制，更通用。但消耗一部分内存地址空间，不适合资源受限的嵌入式环境。可能导致内存与IO访问之间的冲突。&lt;/p>
&lt;h3 id="io控制方式轮询中断dma">IO控制方式：轮询、中断、DMA
&lt;/h3>&lt;p>CPU向设备控制器发送命令后，设备将完成状态放入状态寄存器。&lt;/p>
&lt;p>轮询：CPU一直查询状态寄存器，直到IO完成。简单，效率低&lt;/p>
&lt;p>中断：设备完成任务后触发中断控制器，中断控制器通知CPU。不适合大量数据传输，因为频繁打断CPU。&lt;/p>
&lt;p>DMA：DMA控制器在CPU不参与的情况下，自行将数据写入内存。CPU只负责一开始的指令。效率高、适合大量数据传输，但成本高，实现复杂。
◦ CPU向DMA控制器发送指令，将某些数据读取到内存什么地方或写到某个设备的什么地方
◦ DMA控制器将磁盘控制器发送指令，将数据从磁盘控制器的缓冲区或主机缓冲区读取到自己的缓冲区，再写入内存指定地址或设备缓冲区
◦ DMA完成后，DMA控制器通过中断通知主机&lt;/p>
&lt;h3 id="设备驱动程序屏蔽设备控制器差异">设备驱动程序屏蔽设备控制器差异
&lt;/h3>&lt;p>每种设备的控制器使用模式不同，需要厂商配套驱动程序向操作系统提供统一的接口&lt;/p>
&lt;h3 id="通用块层管理不同的块设备">通用块层管理不同的块设备
&lt;/h3>&lt;p>通用块层向上为文件系统提供访问块设备的标准接口，向下将不同的磁盘抽象成统一的块设备，提供一个管理驱动程序的框架。其次将发送给块设备的IO请求合并、重排、调度从而提高磁盘IO的效率。&lt;/p>
&lt;p>块层调度算法有：
• 无调度：即不对IO做任何处理，主要用于虚拟机IO，将调度交给物理机做
• FIFO
• 完全公平调度
• 优先级调度
• deadline调度&lt;/p>
&lt;h3 id="缓存机制提高io效率">缓存机制提高IO效率
&lt;/h3>&lt;p>为了提高文件访问效率，使用page cache、dentry缓存等机制减少访问磁盘。对于块设备还会使用数据缓冲区实现累积读写。&lt;/p>
&lt;h3 id="从键盘输入一个字符">从键盘输入一个字符
&lt;/h3>&lt;p>从键盘输入一个字符，则键盘控制器会产生扫描码数据，并将其缓冲在键盘控制器的数据缓冲区中，键盘控制器向CPU发送中断请求。CPU收到中断请求后保存进程上下文，然后调用键盘的中断处理程序。键盘的中断处理程序是在安装键盘驱动程序时注册的，中断处理函数的功能是从键盘控制器的缓冲区读取扫描码，并根据扫描码找到键盘输入的字符。&lt;/p>
&lt;p>如果输入的是显示字符，就将其翻译成ASCII码，并将其写入读缓冲区队列（存储从输入设备接收到的数据，因为输入可能快于处理），显示器的驱动程序定期从读缓冲区队列读取到写缓冲区队列（存储准备发送给输出设备的数据队列），将写缓冲区队列的数据写入显示器数据缓冲区，显示到屏幕上。最后恢复中断上下文，返回进程。&lt;/p>
&lt;h3 id="调度算法">调度算法
&lt;/h3>&lt;p>操作系统中的调度主要有三类：进程调度，页面置换和磁盘调度&lt;/p>
&lt;h4 id="进程调度">进程调度
&lt;/h4>&lt;p>作业类型&lt;/p>
&lt;p>进程调度的目的是让不同的作业都能及时快速得到响应。作业可以分为长作业和短作业，CPU密集型作业和IO密集型作业。&lt;/p>
&lt;p>长作业和短作业：需要CPU服务时间较长的和较短的作业。&lt;/p>
&lt;p>CPU密集型作业：需大量CPU计算的作业，等待IO的情况少。&lt;/p>
&lt;p>IO密集型作业：需要大量等待IO的作业，会频繁阻塞。&lt;/p>
&lt;h4 id="进程调度算法">进程调度算法
&lt;/h4>&lt;p>进程调度算法类型&lt;/p>
&lt;p>抢占式调度算法：可以在当前作业没有执行完的时候迫使其挂起，然后执行另一个作业&lt;/p>
&lt;p>非抢占式调度算法：必须等待当前作业执行完再调度下一个作业&lt;/p>
&lt;p>对于实时操作系统来说，为了保证有些高优先级任务及时得到响应，必须要抢占式调度。&lt;/p>
&lt;p>凡是基于优先级的调度算法，都可以实现程抢占式的。但是基于优先级的算法都有可能导致饥饿。&lt;/p>
&lt;h4 id="常见进程调度算法">常见进程调度算法
&lt;/h4>&lt;p>先来先服务：最简单的算法，按照先来后到的顺序将作业加入一个队列，每次从队列中取出一个作业执行。优点是实现简单，缺点是对长作业有利，对短作业不利。因为短作业会被堵在长作业之后，响应时间长。对CPU密集型的作业有利，对IO密集型的作业不利，因为IO密集型的作业堵塞后需要重新排队。&lt;/p>
&lt;p>短作业优先算法：每次调度时都选择需要时间最短的作业。优点：保证短作业及时得到响应；缺点：长作业可能饥饿。&lt;/p>
&lt;p>高响应比优先算法：定义一个响应比来平衡长短作业，响应比是服务时间加等待时间除以服务时间。对于长作业来说，等待时间越长会提升优先级，对于短作业来说，除了等待时间以外，服务时间越短也会提升优先级。优点：兼顾长短作业；缺点：实现较为复杂，计算有开销，需要准确预测进程的服务时间，这是有难度的。如果短作业不断到达，还是有可能导致长作业饥饿，没有考虑实时性。&lt;/p>
&lt;p>时间片轮转：给每个作业分配一定时间片，时间片用完就切换下一个作业。优点：实现简单，公平。缺点：没有考虑到不同作业的优先级，时间片大小难设置（太长退化成FCFS，太短频繁切换开销大），不利于IO密集，因为时间片可能没用完就睡眠了。&lt;/p>
&lt;p>高优先级作业优先：给每个作业静态分配优先级，或者基于其他指标动态分配优先级，每次调度优先级高的作业。优点：即时响应高优先级请求。缺点：低优先级请求饥饿&lt;/p>
&lt;p>多级反馈队列：设置多个不同优先级的服务队列，优先级越低的队列时间片越长。每次作业加入优先级最高的队列，如果时间片用完就加入低一级队列。高级队列执行完再调度低优先级。优点：兼顾高低优先级，低优先级的服务时间也更长。缺点：低优先级还是有可能饥饿，可以定期重新加回高优先级，不利于IO密集型，因为即使时间长也可能睡眠，缺乏实时性&lt;/p>
&lt;p>deadline：给每个作业分配截止时间，优先调度接近截止时间的。缺点是有可能再多个截止时间接近的作业中频繁切换，那么都超时&lt;/p>
&lt;h4 id="linux中的进程调度器">Linux中的进程调度器
&lt;/h4>&lt;p>普通任务：CFS完全公平调度器，为调度器队列中的每个进程设置一个虚拟时钟vruntime，表示进程使用了多少虚拟时间，虚拟时间与实际时间成比例，但是会根据进程的权重调整。优先级越高的进程vruntime增长越慢。每次选择vruntime最小的进程执行。使用红黑树存储队列，每次选择红黑树最左边节点（vruntime最小）&lt;/p>
&lt;p>实时任务：deadline调度器、RT实时调度器，deadline调度器选择当前待处理任务中离截止期限最近的任务，红黑树管理（有序），RT调度器由两种模式，一种是先入先出队列，但是支持高优先级随时抢占。另一种是时间片先入先出，优先级相同的任务按时间片轮转。&lt;/p>
&lt;h3 id="页面替换">页面替换
&lt;/h3>&lt;p>虚拟内存机制使得每个进程可以使用比真实内存更大的虚拟内存空间。当内存空间不够时需要将一些内存页替换到外存释放空间。&lt;/p>
&lt;p>选择哪些内存页调度？&lt;/p>
&lt;p>常见页面替换算法&lt;/p>
&lt;p>最优替换：最好的选择就是选择最远时间内不会使用的页面替换出去，但是这是不可能实现的，因为我们不知道内存页将来的访问情况。所以这是作为一个基准衡量其他算法的性能。&lt;/p>
&lt;p>先入先出：将所有内存页面按照创建时间加入队列，每次从队列尾部取出一个内存页替换出去。优点：实现简单，缺点：没有考虑到页面的最近使用情况，效果差。&lt;/p>
&lt;p>LRU：最近最少使用考虑将内存页面组织成一个双向链表，将最近访问过的页面提升到链表头部，这样链表尾部就是最近没有使用过的页面。基于局部性原理，认为最近访问过的页面将来也可能再次访问。优点：考虑使用情况，命中率更高。缺点：实现复杂（需要双向链表和映射），如果IO模式不符合局部性原理就会失效（1. 预读失效：对于随机IO来说，预读加载进链表的页面不会访问2. 缓存污染：对于大文件的顺序读来说，读上来的页面看起来都是最近使用过的，但是实际上不会再次访问，并且又把缓存填满了）优化：可以和FIFO配合使用，第一次访问某个页面的时候先加入FIFO队列，用来避免一次性页面污染缓存。第二次访问再加入LRU队列。同理可以设计更多级。&lt;/p>
&lt;p>时钟算法：将所有页面组织成一个环形链表，指针指向某个节点。每个节点都有一个标志位，标志最近是否访问过。需要替换的时候，指针就扫描链表中的节点，如果标志位是1就置为0，如果标志位是0就换出。优点：考虑到了最近使用情况，实现比LRU简单，因为不用双向链表只用单向，还不需要映射，并且不需要频繁的移动节点。缺点：还是有一定实现成本，并且只用一个位表示最近访问频率不精确。总体来说比较好&lt;/p>
&lt;p>LFU：记录每个页面最近被访问的频率，每次替换访问频率最低的页面。优点：考虑到最近访问的次数，不会被一次性数据污染。缺点：实现还是比较复杂，和LRU差不多，并且对工作集切换的情况不友好。因为上一个工作集之前经常访问，但是现在又不访问了，就占着缓存。当前工作集的页面因为访问次数不多所以频繁替换。改进：可以随着时间推移减少每个页面的访问次数，比如除以2.这样兼顾时间局部性。&lt;/p>
&lt;h3 id="磁盘调度">磁盘调度
&lt;/h3>&lt;p>目的是为了尽量减少磁头的移动，减少寻道时间&lt;/p>
&lt;h4 id="常见磁盘调度算法">常见磁盘调度算法
&lt;/h4>&lt;p>先来先服务：按照IO时间顺序服务。优点：实现简单，缺点：可能导致频繁移动，性能差&lt;/p>
&lt;p>最短寻道时间优先：下一次优先服务离当前磁道最近的IO。优点：性能比FCFS好，并且实现比较简单。缺点：导致远的IO饥饿&lt;/p>
&lt;p>电梯调度和循环电梯调度：电梯调度就是类似于汽车的雨刮器，每次从一个方向的起点扫描到终点再回头。优点：不会导致远处饥饿，缺点：中间的比较有利。循环电梯调度：到一个方向的终点以后回到起点，返程不服务。优点：更加公平，缺点：一个方向上可能后续没有IO，但是还是要扫描到终点。&lt;/p>
&lt;p>LOOK和CLOOK：就是对电梯和循环电梯的改进，一个方向没有了就立刻掉头。优点：减少扫描终点的开销。缺点：一个方向上一直来IO会导致背后的IO饥饿。&lt;/p>
&lt;p>deadline：也可以deadline，但是可能导致频繁来回移动，多个请求都超时。&lt;/p>
&lt;p>缓存逐出算法&lt;/p>
&lt;p>一般有LRU，FIFO，LFU，TTL等。&lt;/p>
&lt;p>• LRU：最近最少使用。将所有的缓存项组织成一个双向链表，并且用一个映射管理链表节点，目的是让查找，更新，删除的时间复杂度都是O1.当缓存命中时，就将节点移动到表头。当缓存更新后，也移动到表头这样就可以保证表尾的数据是最近使用最少的。如果缓存没有命中，就将数据读出来并安放在表头，同时逐出表尾的节点。基于局部性原理假设&lt;/p>
&lt;p>• FIFO：将缓存项目按照时间顺序放入队列，每次逐出队列尾部&lt;/p>
&lt;p>• LFU：记录过去一段时间内缓存项目的使用情况，每次逐出最近访问次数最少的&lt;/p>
&lt;p>• TTL：给每个项目设置一个存活时间，超过存活时间就逐出&lt;/p>
&lt;p>优缺点：&lt;/p>
&lt;p>• LRU：实现复杂，预读失效，缓存污染
◦ 随机IO不符合局部性原理，导致预读页面无法命中
◦ 大文件的顺序读是最近访问过但之后又不会访问的，这种一次性数据会污染缓存
◦ 解决：可以和FIFO结合使用，每个缓存项先进入FIFO，第二次访问再进入LRU链表，可以避免一次性数据的污染&lt;/p>
&lt;p>• FIFO：实现简单，性能差&lt;/p>
&lt;p>• LFU：实现复杂，存在工作集切换时的颠簸
◦ 工作集突然切换的时候，旧工作集内容不会再访问，但占着缓存，导致新工作集被频繁逐出
◦ 解决：可以每隔一段时间就将最近访问次数减少或者除以二，或者给每一项安排一个生存时间，从而将数据的访问时间纳入考量&lt;/p>
&lt;p>• TTL：优点，可以保证缓存的新鲜度，利用时间局部性，但是可能导致大量缓存同时失效，并且生存时间不易确定&lt;/p></description></item><item><title>面经总结</title><link>https://realcedriccheng.github.io/p/mianjingzongjie/</link><pubDate>Mon, 07 Apr 2025 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/mianjingzongjie/</guid><description>&lt;h2 id="操作系统">操作系统
&lt;/h2>&lt;h3 id="比较管道共享内存和消息队列">比较管道，共享内存和消息队列
&lt;/h3>&lt;p>管道和共享内存是两种进程间通信方式。管道是通过在内核空间开辟一块缓冲区，写进程向缓冲区写入数据而读进程从缓冲区读出数据实现通信的，共享内存是开辟一块内核空间，让两个不同进程各自映射到用户空间实现进程通信的。&lt;/p>
&lt;p>管道是单向通信的，而共享内存是双向通信的。&lt;/p>
&lt;p>管道只适合少量数据传输，因为缓冲区较小。共享内存分配的空间较大，因此适合较多数据传输。&lt;/p>
&lt;p>管道的拷贝开销大，需要进程拷贝将待写的数据拷贝到内核管道，另一个进程从内核管道中拷贝出来。而共享内存通过映射的方式避免陷入内核态，因此只需要由写进程将写入共享内存区，读进程不需要复制就可以从共享内存区读出。&lt;/p>
&lt;p>共享内存需要锁机制避免数据竞争。&lt;/p>
&lt;p>消息队列是不同进程间约定好消息体格式，发送方将消息体写入内核的消息链表中就返回。接收方将消息体复制出来。由于管道是阻塞的，消息队列是非阻塞的，所以消息队列传输效率更高，适合频繁传输。&lt;/p>
&lt;h3 id="mmap文件有哪些刷盘方式">mmap文件有哪些刷盘方式
&lt;/h3>&lt;p>mmap将文件映射到用户的文件映射区，当进程修改文件映射区内容后会产生脏页。一方面，内核会有线程定期写回脏页。另一方面可以主动调用msync刷回指定虚拟内存区域的脏页（可以是同步等待的，也可以是异步即只是通知内核刷盘，而不阻塞的），也可以调用fsync以文件为单位刷回文件所有脏数据和元数据。最后，使用munmap解除映射时内核会将未同步的脏页刷回。&lt;/p>
&lt;h3 id="mmap的文件会马上放到物理内存吗什么时候会放到物理内存">mmap的文件会马上放到物理内存吗，什么时候会放到物理内存
&lt;/h3>&lt;p>mmap仅分配虚拟空间，但是不会马上将文件复制进内存。只有访问虚拟地址时触发缺页中断才会将文件读入页缓存中，并将虚拟地址映射到页缓存的物理地址上。&lt;/p>
&lt;p>如果文件已经在page cache中，因为缺失PTE表项，所以mmap仍需要触发一次page fault。在异常处理流程中先检查page cache然后绑定相应物理地址。&lt;/p>
&lt;h3 id="openreadwriteunlinkrmdirtruncate函数执行过程">open，read，write，unlink，rmdir，truncate函数执行过程
&lt;/h3>&lt;p>要打开或者创建一个文件，可以使用open系统调用。open系统调用有3个参数。第一个是文件的路径和文件名，第二个是文件的访问模式和操作，第三个是在创建文件时，定义文件的访问权限。&lt;/p>
&lt;p>首先，内核需要解析路径名。解析路径名的方式就是从根目录开始，逐级读取目录文件，并确定下一级目录文件的位置。如果目录较长，这个过程可能会很慢。另外，文件系统提供dentry缓存机制加快解析。如果最近访问过某个文件或目录，就会把该文件对应的目录项缓存在内存中，不会逐目录查找。&lt;/p>
&lt;p>其次，open第二个参数需要指定文件打开以后的访问模式，包括只读，只写和读写。如果文件不存在，可以用O_CREAT指定创建一个文件，还可以指定是否要追加写、截断等。O_EXCL和O_CREAT合用，表示如果文件本身存在就返回创建失败。O_TRUNC表示如果文件存在就把长度截断到0。O_APPEND表示文件打开后总是往尾部追加写。&lt;/p>
&lt;p>创建一个文件的流程包括：路径解析（已经提到），检查该目录是否有权限创建文件，为文件分配inode结构，将文件的名字和inode号更新到目录中。如果需要写入还要分配数据块并更新元数据索引。如果是direct io或者同步写还需要将数据块落盘。&lt;/p>
&lt;p>open第三个参数代表权限。在创建文件的模式下，第三个参数指定了文件的访问权限，包括文件创建者，所在组和其他成员的读取，写入，执行权限。&lt;/p>
&lt;p>read和write系统调用负责文件的读写。均有三个参数。第一个参数是文件描述符，第二个是缓冲区指针，第三个是读或写的字节数。&lt;/p>
&lt;p>read和write都从文件的读写指针开始，可以通过lseek修改读写指针。lessk的三个参数是文件描述符，偏移量和偏移起始地址。偏移起始地址可以是文件开头，末尾或者当前读写指针。&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/weixin_44698673/article/details/125729055" target="_blank" rel="noopener"
>https://blog.csdn.net/weixin_44698673/article/details/125729055&lt;/a>&lt;/p>
&lt;p>删除文件用unlink系统调用，参数是文件路径。之所以参数是文件路径，是因为不同的文件可能对应同一个inode，也就是硬链接。如果通过文件描述符找到文件，就不知道具体想要删除哪一个硬链接。当删除最后一个硬链接的时候，文件的空间才会真正释放。删除文件的过程包括从目录中删除该文件的表项，减少硬链接计数。如果是最后一个硬链接，就调用具体文件系统的删除操作。&lt;/p>
&lt;p>删除目录用rmdir系统调用，参数是目录路径，因为打开目录不会返回一个整数形式的描述符。只能删除空目录，目录不空就要递归删除。&lt;/p>
&lt;p>截断文件是指定一个长度，如果文件超过这个长度就把多余部分删除，如果不足这个长度就用\0填充到这个长度。truncate和ftruncate系统调用可以截断。前者的参数是路径名和长度，后者的参数是文件描述符和长度。&lt;/p>
&lt;p>区别：truncate之前无需先打开文件，ftruncate需要在打开文件的情况下截断。truncate可能会收到符号链接攻击，意思是高权限的文件被链接到低权限的链接，如果文件系统不完善，那么低权限的用户可能可以操作高权限的文件。&lt;/p>
&lt;h3 id="dentry详细介绍">dentry详细介绍
&lt;/h3>&lt;p>dentry主要包括文件名和路径到inode的映射。同时dentry在内核中以哈希表和LRU链表的方式存放，从而快速定位到目录项。&lt;/p>
&lt;h3 id="page-cache加速原理">page cache加速原理
&lt;/h3>&lt;p>Linux上会将文件先读入内存，作为page cache映射到进程的虚拟地址空间。page cache就是struct page中的address_space结构体。每个文件会在内核中只有一份page cache。但是可以有多个进程中的struct file指向。&lt;/p>
&lt;p>page cache不仅是缓存基于文件的数据页，还用于元数据的缓存。不同的page有不同的操作函数，定义在address_space_operations操作集中。&lt;/p>
&lt;p>page cache的数据结构是基数树，用于快速定位某些状态，如脏的页。基数树是一种利用前缀索引快速检索的数据结构，检索复杂度是Ok，k是所有字符串最大长度。page cache的键是页偏移量，使用分层编码压缩的方式减少长度&lt;/p>
&lt;h3 id="使用page-cache和不使用page-cache有什么区别">使用page cache和不使用page cache有什么区别
&lt;/h3>&lt;p>使用page cache的就是buffer io，不使用page cache的是direct io。他们之间的区别有几点。第一是buffer io的读写性能更好，因为可以在内存中命中，而direct io每次都要访存。第二是buffer io需要占用一定内存存放page cache，但是direct io不需要。第三个是buffer io 不用管理一致性问题和崩溃恢复问题，因为page cache已经实现了这个机制，但是direct io需要自己管理。buffer io适合大多数场景，但是数据库等需要精细控制IO或者是已经实现了自己的缓存的应用就可以跳过page cache。&lt;/p>
&lt;h3 id="使用direct-io需要注意什么">使用direct IO需要注意什么
&lt;/h3>&lt;p>首先需要手动管理数据的一致性，因为direct io只是保证数据落盘，但不会保证元数据都落盘，需要频繁调用fsync保证所有的元数据都落盘。其次还需要自己实现崩溃恢复，出错重发等机制，然后为了保证性能还需要自己实现批量写入和预读的策略，自己实现读写缓冲区。最后还需要把写入数据块的大小和文件系统数据块的大小对齐。
使用direct io需要在打开文件的时候设置O_DIRECT标志。&lt;/p>
&lt;h3 id="page-cache的一致性与可靠性">Page Cache的一致性与可靠性
&lt;/h3>&lt;p>更新page cache上的页就成了脏页。一方面操作系统内核线程定期写回脏页，另一方面用户可以主动调用fsync和sync同步某个文件和整个文件系统的数据。最后内存压力大时会导致回收文件页（丢弃或回写）&lt;/p>
&lt;p>3个系统调用：fsync：将fd文件的所有脏数据和脏元数据写回磁盘；fdatasync：将fd文件所有的脏数据和必要的元数据写回磁盘。必要的元数据是对访问文件有关键作用的元数据，比如文件大小。但是文件修改时间就不写回。sync：将整个文件系统的脏数据和脏元数据写回磁盘。&lt;/p>
&lt;h3 id="page-fault-的过程">page fault 的过程
&lt;/h3>&lt;p>page fault主要包括缺页异常和权限异常。缺页异常是页表项不存在，权限异常是页表项存在但是没有操作权限。&lt;/p>
&lt;p>触发page fault时，首先这是一个中断，因此要保存用户态上下文，进入内核态，并根据中断向量表找到中断处理函数。然后检查虚拟内存地址属于哪一个vma，如果不属于任何一个vma说明还没有分配，因此终止进程。
根据vma的类型决定缺页处理逻辑：新匿名页缺页则分配零页或新物理页，文件映射缺页则从磁盘加载到page cache。swap页缺页则从swap分区换入被换出的物理页。&lt;/p>
&lt;p>对于匿名页的首次读访问，且表项为空，会映射到一个内容全为0的全局只读零页，后续发生写操作会再次触发page fault权限异常，进入写时拷贝流程。这是为了延迟分配物理页，等到要写入才真正分配。&lt;/p>
&lt;p>对于匿名页的首次写访问，会分配新物理页并更新表项。&lt;/p>
&lt;p>对于文件页的读访问，会从磁盘上读取文件页，并且会用预读机制优化&lt;/p>
&lt;p>对于文件页的写访问，如果是私有文件映射，会写时拷贝避免影响其他进程。如果是共享文件映射，会直接修改物理页。&lt;/p>
&lt;h3 id="page-fault-的预读机制">page fault 的预读机制
&lt;/h3>&lt;p>预读机制是触发文件页的缺页中断时，会从磁盘上读取该文件页以及后续若干文件页。预读窗口的大小与访问模式有关，检测到顺序访问会增加窗口，检测到随机访问会缩小窗口。&lt;/p>
&lt;h3 id="一个进程open的文件进程异常退出了脏数据会落盘吗">一个进程open的文件，进程异常退出了，脏数据会落盘吗
&lt;/h3>&lt;p>会，因为文件的page cache在内核中独立于进程，进程崩溃了，page cache依然会回写脏数据。但是如果系统也崩溃，如掉电等，则不能保证。&lt;/p>
&lt;p>如果脏数据在用户态缓冲区还没有写入内存page cache，则也会丢失。&lt;/p>
&lt;h3 id="一个进程在写文件另一个进程删除该文件删除会不会成功为什么写文件的进程能不能继续写">一个进程在写文件，另一个进程删除该文件，删除会不会成功，为什么，写文件的进程能不能继续写
&lt;/h3>&lt;p>会成功，可以继续写。&lt;/p>
&lt;p>因为每个文件有硬链接计数和进程引用计数。删除文件只是减少硬链接计数，并且从目录中删除该文件的项。只要有进程打开文件，则进程引用计数不为零，数据块仍保留在磁盘中。&lt;/p>
&lt;p>写进程可以继续写，因为进程通过文件描述符操作文件，即使没有文件目录也可以写。并且可以正常落盘。只有最后一个进程关闭文件后才会删除。&lt;/p>
&lt;h3 id="进程线程协程协程的实现优缺点">进程线程协程，协程的实现，优缺点
&lt;/h3>&lt;p>进程是操作系统资源分配的基本单位，线程是CPU调度的基本单位，协程是用户态的轻量级线程。&lt;/p>
&lt;p>进程拥有独立的资源，包括地址空间、文件描述符等。进程之间具有隔离性，不同进程需要进程间通信机制交换数据。进程切换的开销大。&lt;/p>
&lt;p>同一进程内的不同线程共享地址空间，不需要专门的通信机制，但是需要锁和信号量机制防止数据竞争。线程切换的开销比进程小。&lt;/p>
&lt;p>协程是用户态实现的更轻量的执行单位，由用户态的函数库管理，操作系统不知道协程的存在。协程栈只有KB级别，线程栈有MB级别，所以协程可以实现高并发，切换非常快速，而且不需要进入内核态。协程只在等待IO时主动让出CPU而不是被抢占，这是因为内核不能介入协程的执行过程，无法打断协程执行流，并且如果允许抢占则需在任意位置保存全部状态，开销大。协程在线程内串行执行不需要加锁。&lt;/p>
&lt;p>但是协程无法利用多核CPU，因为内核不知道协程的存在，所以无法调度。而且协程的使用和调试复杂，需要函数库支持。&lt;/p>
&lt;p>进程适合需要隔离多个任务的场景，线程适合需要共享数据、并发的场景，协程适合高并发的场景。&lt;/p>
&lt;h3 id="创建进程线程的函数">创建进程线程的函数
&lt;/h3>&lt;h4 id="创建进程">创建进程：
&lt;/h4>&lt;p>使用fork可以创建一个进程，具体是根据父进程复制一个子进程，创建时不为子进程分配资源，而是采用写时拷贝技术，其页表项设置为只读，只有写入时触发page fault分配新页面并复制。&lt;/p>
&lt;p>exec系列函数用于替换当前进程的代码和数据，加载并执行新程序，覆盖原进程的代码段和数据段。经常和fork连用，因为fork的写时拷贝技术避免了复制父进程的无用数据。但是保留文件描述符等。&lt;/p>
&lt;h4 id="创建线程">创建线程：
&lt;/h4>&lt;p>c语言有基于posix接口的pthread库，pthread_create创建线程，pthread_join等待线程结束并回收资源。线程函数调用pthread_exit主动退出。pthread库中还有互斥锁和条件变量。
C++11中有thread库，是基于pthread实现的，用法更简单，创建一个thread对象的时候就启动线程，主线程中调用线程对象的join方法等待线程返回或者调用detach使子线程脱离主线程。有互斥锁和条件变量，C++14提供读写锁。&lt;/p>
&lt;h3 id="怎么排查死锁">怎么排查死锁
&lt;/h3>&lt;p>用户态死锁：&lt;/p>
&lt;p>pstack/gdb（C/C++）&lt;/p>
&lt;p>对进程执行 pstack &lt;pid> 或 gdb -p &lt;pid>，查看各线程的调用栈和锁状态。&lt;/p>
&lt;p>top/htop&lt;/p>
&lt;p>观察CPU占用率异常的进程，死锁线程可能处于高CPU或持续等待状态&lt;/p>
&lt;p>strace&lt;/p>
&lt;p>跟踪进程系统调用，发现卡在 futex 或 pthread_mutex_lock 等锁操作&lt;/p>
&lt;p>内核态死锁&lt;/p>
&lt;p>内核日志：通过 dmesg 查看 WARNING 或 deadlock 关键字&lt;/p>
&lt;p>coredump分析：利用 gdb 分析转储文件中的线程堆栈和锁状态&lt;/p>
&lt;p>使用Ftrace分析锁竞争路径&lt;/p>
&lt;h3 id="操作系统如何保持进程隔离性">操作系统如何保持进程隔离性
&lt;/h3>&lt;p>操作系统通过虚拟内存机制隔离不同内存，虚拟内存机制使得每个进程只能看到属于自己的连续独占虚拟地址空间，看不到其他进程的虚拟地址空间，所以保证了隔离性。&lt;/p>
&lt;h3 id="mmap是否影响进程隔离性">mmap是否影响进程隔离性
&lt;/h3>&lt;p>不影响。mmap可以有共享和私有映射。私有映射仍然是隔离的，共享映射是进程间通信方式。&lt;/p>
&lt;h3 id="进程线程之间哪些资源共享哪些不共享线程独有的资源有哪些为什么独有">进程线程之间哪些资源共享哪些不共享，线程独有的资源有哪些，为什么独有
&lt;/h3>&lt;p>线程可以共享地址空间，文件描述符，代码段，数据段、堆、环境变量和用户身份等。&lt;/p>
&lt;p>但是每个线程有自己独立的线程id，栈和寄存器。因为线程在并行或并发执行不同任务时用到的局部变量和函数不同，如果栈不独立会导致栈帧被覆盖。&lt;/p>
&lt;p>例如，某个线程在栈上分配了局部变量，另一个线程分配了另一个局部变量，假如第一个线程想要释放局部变量，就会导致另一个线程的也释放，因为栈时后进先出的。而堆不会，堆释放了不会立刻归还内存。&lt;/p>
&lt;p>不同的线程会嵌套执行多个函数，函数的返回地址需要按顺序压入栈，如果栈不独立会导致函数返回错乱。&lt;/p>
&lt;h3 id="vfs四个关键结构体">vfs四个关键结构体
&lt;/h3>&lt;p>要使用某种文件系统，必须先将其注册到 VFS 核心。注册文件系统就是将该文件系统类型插入一个 file_systems 单链表中。目的是向 VFS 提供 get_sb 和 kill_sb 回调函数，从而装载或卸载该类型的文件系统。
VFS中的对象都是仅存在于内存的。具体文件系统的对象会落盘，有盘上结构&lt;/p>
&lt;ol>
&lt;li>超级块super block存放了已挂载文件系统的元数据和控制信息，主要用来指向 fs 超级块（s_fs_info）以及 fs 提供的超级块操作表(s_op)。因为不同文件系统的操作时不同的，这个VFS超级块就是为了向上层提供统一的接口。文件系统层面的操作一般有分配、删除、写回inode、将超级块写入盘上、锁住文件系统和解锁文件系统（比如文件系统要sync）等。&lt;/li>
&lt;li>inode唯一表示文件，通过inode编号管理，包括操作函数表等。VFS的inode只存在内存中，具体文件系统的inode会落盘。&lt;/li>
&lt;li>目录项用来避免重复解析文件路径，加快路径解析速度。&lt;/li>
&lt;li>file文件对象表示进程打开的文件示例，包括访问模式、偏移量和操作函数表。&lt;/li>
&lt;/ol>
&lt;h3 id="比较lru和fifo">比较LRU和FIFO
&lt;/h3>&lt;p>LRU和FIFO是两种常见的缓存替换算法。&lt;/p>
&lt;p>LRU优先淘汰最久未被使用的数据，基于时间局部性原理，通常使用哈希表和双向链表实现，可以在O1内完成插入查找和删除。数据局部性较好的时候缓存命中率高。&lt;/p>
&lt;p>LRU的缺点第一是实现比较复杂，需要跟踪页面的访问情况，第二是对突然切换工作集的情况不适用，因为可能频繁逐出新工作集中的数据（这是LFU）。第三是不适合随机IO，因为会预读失效，第四是不适合顺序扫描大文件，因为这种模式缺乏时间局部性，每个块看起来都是最近使用的，会污染缓存，也就是缓存被新加载但是不会再被使用的数据填满。&lt;/p>
&lt;p>FIFO按照进入队列的顺序，淘汰最先进入队列的数据，使用队列实现，O1。实现简单，但是性能比较差，尤其是不符合先入先出假设的时候。并且还有belady异常，也就是队列增大，命中率反而下降。原因是队列深度可能不足以覆盖整个工作集（工作集就是一段时间内频繁访问的页面集合）&lt;/p>
&lt;p>LRU适合对性能要求较高的系统，FIFO适合对性能要求不高，资源有限的系统，或者数据访问本身就比较随机的场景。&lt;/p>
&lt;h3 id="如何设计lru">如何设计LRU
&lt;/h3>&lt;p>采用数据结构为双向链表和映射unordered_map。需要保存的信息有LRU队列的容量capacity，当前元素数量size和链表的头尾节点。实现的操作有，一是插入，如果待插入的节点已经存在于链表中就更新值并移动到头部。如果没有就在头部新增一个节点。同时如果size大于capacity就需要把尾部逐出。二是访问，如果数据在LRU中就读出来并且移动到头部，如果不在可能就要从别处读取，比如从磁盘中读取。&lt;/p>
&lt;h3 id="如何改善lru">如何改善LRU
&lt;/h3>&lt;ol>
&lt;li>LRU只记录最近一次访问的时间，可以改成记录最近K次访问情况，比如最近k次访问中至少访问一次。&lt;/li>
&lt;li>双队列LRU：将缓存分为两个部分，一个是短期的FIFO队列，另一个是长期的LRU。数据第一次进入短期队列，第二次再进入LRU。可以解决一次性数据带来的预读失效和缓存污染&lt;/li>
&lt;li>多级缓冲队列：设置多个优先级不同的队列，每个队列都是LRU的，数据被访问多次后可提升到优先级更高的队列。&lt;/li>
&lt;/ol>
&lt;h3 id="操作系统有哪些进程和线程的调度算法">操作系统有哪些进程和线程的调度算法
&lt;/h3>&lt;p>先来先服务、短作业优先、高响应比优先、时间片轮转、高优先级、多级反馈队列&lt;/p>
&lt;p>先来先服务：先来先服务是最简单的调度算法，原理就是将作业按照提交的顺序假如队列，每次从队列的头部取出作业执行。优点：实现简单；缺点：对长作业有利，导致短作业被长作业卡住，响应慢。适合CPU密集型的任务，因为可以不被干扰一直运行，不适合IO密集型的任务，因为IO经常要等待，就要重新排队。&lt;/p>
&lt;p>短作业优先算法：短作业优先是指每次尽量选择执行时间较短的作业。优点：对短作业友好，不会被长作业卡住；缺点：可能导致长作业饥饿&lt;/p>
&lt;p>高响应比优先算法：根据服务时间和等待时间综合计算优先级，服务时间加等待时间除以服务时间。优点：兼顾长短作业，对于两种作业来说，都是等待时间越长优先级越高，对于短作业来说服务时间短，所以优先级略高于长作业。这种基于优先级的算法都可以是抢占式也可以是非抢占式。随着运行可能出现优先级更高的其他作业。&lt;/p>
&lt;p>时间片轮转算法：给每个作业分配时间片，每个作业只能运行一定时间片，然后要重新排队。优点：实现简单，公平；缺点：时间片不好选择，时间片太短导致频繁切换，时间片太长退化成先来先服务。&lt;/p>
&lt;p>高优先级算法：给每个作业分配优先级，每次执行高优先级的作业。优先级可以是静态的也可以是动态的。优点：保证高优先级的作业及时响应；缺点：导致低优先级作业饥饿。&lt;/p>
&lt;p>多级反馈队列算法：设置多个优先级队列，优先级越低的队列时间片越长。将第一次调度的作业放到最高优先级的尾部，如果时间片用完了，就移动到下一级队列。每次只有上一个优先级的队列空才会执行下一个队列的作业。优点：兼顾长短作业，长作业虽然优先级低，但是时间片也长；缺点：仍然可能导致长作业饥饿。并且实现复杂。改进：定期将低优先级队列的内容加回高优先级队列。&lt;/p>
&lt;h3 id="linux块层如何调度io请求">Linux块层如何调度IO请求
&lt;/h3>&lt;p>上层应用调用read或者write发送IO请求，在文件系统中会封装成bio的形式发给块层。块层会将bio合并转化为一个或多个request，并将request插入对应块设备的请求队列中。每个块设备都有自己的请求队列。请求队列会采用一定调度算法进行排序。比如可以先来先服务，也就是不做调度，还可以用deadline机制，也就是排队时间越长优先级越高。&lt;/p>
&lt;p>多队列机制：暂时说不上来&lt;/p>
&lt;h3 id="linux的io栈">Linux的IO栈
&lt;/h3>&lt;p>首先是一个用户态的程序调用read write等涉及IO的系统调用，然后是进入内核态，由虚拟文件系统VFS将请求交给具体的文件系统处理。文件系统将请求封装成bio发给块层，块层经过调度之后发给设备驱动，设备驱动
再发给设备。&lt;/p>
&lt;p>不同的线程在不同的时间通过page cache去写文件，而这两个IO离得比较近，怎样去做调度&lt;/p>
&lt;p>没看懂，应该是要做磁盘调度算法&lt;/p>
&lt;h3 id="磁盘调度算法">磁盘调度算法
&lt;/h3>&lt;p>磁盘调度算法的目的是尽量减少磁头移动的距离，减少寻道时间。&lt;/p>
&lt;p>先来先服务：这种算法按照IO请求的到来顺序访问磁盘块。当大量进程IO到来的时候可能会导致访问的磁道很分散，寻道时间长。&lt;/p>
&lt;p>最短寻道时间优先：先选择离当前磁头最近的位置。问题在于可能导致位置较远的IO饥饿。&lt;/p>
&lt;p>扫描算法或者电梯算法：磁头在一个方向上移动，直到到达这个方向上磁道的末尾，然后再换方向。优点是性能较好，不会饥饿，但是缺点是中间的磁道被扫描的频率比两边高。&lt;/p>
&lt;p>循环扫描算法：就是单向的电梯算法，只有一个方向是扫描方向，当一次扫描到头以后就回到起点重新扫描。回来的过程不处理IO。优点：每个磁道被访问的机会比较平均；缺点：请求扫描完不会立刻停止，而是扫描到最后一个磁道。&lt;/p>
&lt;p>LOOK算法和CLOOK算法：就是针对扫描算法和循环扫描算法的优化，扫描到一个方向的最远请求就回头。CLOOK的缺点：如果一个方向一直到达请求，那么就一直无法回头，导致另一个方向饥饿&lt;/p>
&lt;p>deadline算法：为每个请求设置截止时间，优先服务快到截止时间的请求。优点：可以防止饥饿。缺点：需要额外的资源管理请求的截止时间和更新状态。&lt;/p>
&lt;p>对于SSD来说没必要做磁盘调度优化，因为SSD不需要寻道。&lt;/p>
&lt;h3 id="在文件系统中创建一个文件的流程如果创建的目录比较长会有什么问题">在文件系统中创建一个文件的流程，如果创建的目录比较长会有什么问题
&lt;/h3>&lt;p>首先是解析路径，内核需要逐层解析路径的每一个目录，直到找到目标目录。&lt;/p>
&lt;p>然后是检查是否有在该目录下创建文件的权限&lt;/p>
&lt;p>再分配文件的inode&lt;/p>
&lt;p>再将文件的名称和inode编号更新到目录文件中&lt;/p>
&lt;p>如果文件需要写入，还需要为文件分配实际的数据块。把数据块先放在page cache中，然后异步刷新到磁盘。&lt;/p>
&lt;p>如果目录比较大，可能路径解析的过程比较长。因为需要遍历更多的目录条目。我们可以用符号链接只想较深层次的目录，方便快速访问&lt;/p>
&lt;h3 id="怎样保证文件系统写入数据的一致性和原子性">怎样保证文件系统写入数据的一致性和原子性
&lt;/h3>&lt;p>文件系统写入的一致性是指文件系统在任何时候都应该保证逻辑上的一致状态，比如文件的创建时间应该早于修改时间，文件的索引应该是正确的。我们一般讨论的是文件系统的崩溃一致性，比如断电的情况下，有可能导致文件系统的不一致。&lt;/p>
&lt;p>为了保证文件系统的一致性，我们可以采用日志的方式。比如在ext4文件系统中有独立的日志区域。文件系统在执行操作之前，会先将要执行的操作提交到日志去，然后再去完成这些操作，最后清除日志。如果文件系统崩溃，那么在重新挂载以后就扫描日志区域，看有没有未完成的事务。&lt;/p>
&lt;p>如果文件系统在写日志的时候崩溃，那么数据是否能恢复取决于日志的状态，如果日志中的某个事务没有提交，那么这个事务就不重新应用。只有提交的事务才能重新应用。&lt;/p>
&lt;p>ext4提供了几种日志机制，可以保证不同的一致性等级。最差的是writeback机制，这种机制只把元数据的更新写到日志里。那么在上电之后可能会导致元数据指向的数据还没来得及落盘。第二个是ordered机制，他也只把元数据的更新写到日志里，但是必须保证先把数据落盘，然后再写元数据的日志。这样就不会导致元数据指向不存在的数据。第三种是journal机制，就是把数据和元数据都写入journal。这种机制会造成严重的写放大。&lt;/p>
&lt;p>除了日志机制以外，还有写时拷贝技术。在文件系统中就是在修改数据的时候，不在原始的地方修改，而是把数据复制到一个新的区域修改，修改完成后再将元数据指向新的位置。比如btrfs和zfs都支持COW。优点是不用重放日志，上电以后就是最新的状态。缺点是导致写放大，因为复制会有开销，并且带来了额外的元数据更新。还会导致磁盘碎片化。&lt;/p>
&lt;p>然后还有日志结构文件系统的机制。日志结构文件系统是把整个盘当作一个大日志，在写入的时候也是先写入数据再写入元数据。上电之后再扫描写过的区域重建文件。这种文件系统会定期做检查点来保证一致性。&lt;/p>
&lt;h3 id="基于hdd的文件系统和基于ssd的文件系统的区别">基于HDD的文件系统和基于SSD的文件系统的区别
&lt;/h3>&lt;p>基于HDD的文件系统可能采用连续分配来优化大文件的顺序读取。因为HDD更适合顺序IO。连续分配就是尽量给数据块分配连续的地址，这样可以减少寻道时间。但是容易产生外碎片，需要定期做磁盘整理。还可以通过设置预读来减少磁头移动。&lt;/p>
&lt;p>然而SSD不用寻道，所以顺序和随机IO都擅长。但是SSD的闪存有读写寿命，所以针对SSD的文件系统需要减少写放大。比如采用日志结构的F2FS文件系统。此外TRIM命令对SSD非常重要，可以告诉SSD哪些数据块不再使用，可以擦除，这样就不用等到写入之前再做GC。&lt;/p>
&lt;h3 id="cpu密集型和io密集型应用特点">CPU密集型和IO密集型应用特点
&lt;/h3>&lt;p>CPU密集型应用是指执行流程中大部分时间用于CPU运算（如大规模矩阵计算），IO密集型应用是指执行流程大部分时间用于IO等待（如磁盘寻道或网络传输）&lt;/p>
&lt;p>CPU密集型应用的优化可以：采用多核CPU或者GPU并行计算&lt;/p>
&lt;p>IO密集型的应用可以采用IO多路复用机制减少IO的监控开销，还可以采用缓存机制减少IO次数。还可以通过协程加速。因为协程的切换开销小，并发性高。&lt;/p>
&lt;h3 id="什么是vfork">什么是vfork
&lt;/h3>&lt;p>vfork也是创建一个子进程，但是允许子进程和父进程共享虚拟地址空间，所以可能会导致数据竞争问题。vfork的初衷是避免创建进程时复制地址空间以减少开销，但是现在fork采用写时拷贝技术，不会弄直接复制。因此vfork很少用到。&lt;/p>
&lt;h3 id="进程间通信方式">进程间通信方式
&lt;/h3>&lt;p>进程通过虚拟地址空间实现了隔离性，因此进程之间的协作需要专门的通信机制。&lt;/p>
&lt;p>宏内核进程间通信有管道、消息队列、共享内存、信号量、信号和socket机制。
• 管道：字节流、两个进程、单向、匿名和命名
• 消息队列：消息体、多个进程、单向或双向
• 共享内存：内存区间、多进程、单向或双向
• 信号量：计数器、多进程、单向或双向、同步和互斥
• 信号：事件编号、多进程、单向
• 套接字：数据报文、两个进程、单向或双向、网络栈&lt;/p>
&lt;h4 id="管道">管道
&lt;/h4>&lt;p>管道就是一个单向队列，一端发送一端接收。&lt;/p>
&lt;p>有匿名管道和命名管道。
• 匿名管道就是bash命令中的竖线，只允许临时将前面的输出传递给后面的输入。
• 命名管道需要用mkfifo创建，将数据写入命名管道后终端会阻塞，直到另一端被读出。
• 管道通信效率低，不适合进程之间频繁交换数据&lt;/p>
&lt;p>匿名管道通过系统调用pipe，在内核中开辟了一块内存缓冲区，并返回两个文件描述符。文件描述符用于读和写缓冲区。&lt;/p>
&lt;p>匿名管道只能用于父子进程和子进程之间的通信，这是因为子进程会继承父进程的文件描述符表，从而找到内核缓冲区。&lt;/p>
&lt;p>命名管道通过函数mkfifo创建，可以用于不相关进程之间的通信。因为命名管道有一个具体的路径名，可以像文件一样打开。不过实际上并不存在于磁盘，而是一个内存缓冲区。&lt;/p>
&lt;p>由于匿名管道和命名管道文件都是先进先出的，所以不支持lseek操作。&lt;/p>
&lt;p>管道传递的是无格式的字节流。&lt;/p>
&lt;h4 id="消息队列">消息队列
&lt;/h4>&lt;p>消息队列是一个保存在内核的消息链表，链表的每一个节点都是一个消息体。消息的发送方和接收方约定好消息体的格式，发送方将数据放在消息队列中就返回，接收方需要时去队列中取得数据，因此是非阻塞的。&lt;/p>
&lt;p>消息队列的生命周期随内核，如果不释放消息队列或关闭操作系统，则消息队列一直存在。但是管道的生命周期随进程，引用管道的进程终止则管道消失。&lt;/p>
&lt;p>消息队列适合频繁交换数据，因为是非阻塞的。但缺点是不适合大量数据传输，因为消息体有大小限制，并且消息队列在内核，因此有用户态和内核态之间的数据拷贝开销。管道比消息队列更快，因为不需要消息体的封装与解封装。&lt;/p>
&lt;h4 id="共享内存">共享内存
&lt;/h4>&lt;p>管道和消息队列都要利用内核缓冲区，因此会有拷贝开销。&lt;/p>
&lt;p>共享内存机制是将不同进程的虚拟地址空间映射到相同的物理地址空间。优点是不需要用户态和内核态之间的拷贝，缺点是产生数据竞争。&lt;/p>
&lt;h4 id="信号量">信号量
&lt;/h4>&lt;p>为了解决数据竞争引入信号量实现进程之间的互斥与同步。&lt;/p>
&lt;p>信号量就是一个整形计数器，因此并不能缓存数据，而是表示能进入临界区的进程数量。&lt;/p>
&lt;p>信号量有两个原子操作：P是信号量-1，V是信号量+1.P时信号量&amp;lt;0则P阻塞，V后信号量&amp;lt;=0则表示有进程需要唤醒。P和V必须成对使用。&lt;/p>
&lt;p>信号量初始化为1则为互斥锁。信号量初始化为0可以实现进程同步：另一个进程执行完后再V，这是当前进程就可以P然后执行。&lt;/p>
&lt;h4 id="信号">信号
&lt;/h4>&lt;p>信号用于单向的事件通知而不是数据传输。信号量也可以通知，但是需要进程主动查询信号量。信号则可以随时通知另一个进程，并且另一个进程不需要阻塞等待，内核会切换到处理函数。&lt;/p>
&lt;p>Linux内核为sigint等信号提供了默认处理函数，也可以自己定义信号处理函数。还可以屏蔽信号。但是sigkill等有些信号是不能屏蔽的，因为用于终止一个进程。&lt;/p>
&lt;p>信号处理并不是中断处理。因为处理信号的时机一般是进程从内核态返回用户态之前。信号处理函数一般在用户态执行，上下文会保存在用户栈上。如果信号处理函数中有系统调用则再次进入内核态。&lt;/p>
&lt;p>信号与中断的联系与区别：
• 联系：1. 都是异步通信机制；2. 处理完毕时返回原来的断点；3. 有些中断或信号可以屏蔽
• 区别：1.中断有优先级，信号没有优先级；2.信号处理程序在用户态运行，中断处理程序在内核态运行；3. 中断响应是即时的，而信号响应有一定延迟。&lt;/p>
&lt;h4 id="socket">socket
&lt;/h4>&lt;p>不同主机进程之间通信需要跨网络。&lt;/p>
&lt;p>socket创建参数有协议、报文类型。可以实现TCP、UDP和本地进程间通信。
• TCP通信过程
◦ 服务端通过socket创建套接字，并使用bind将套接字绑定到特定的IP地址和端口上。接着调用listen监听客户端的连接请求。
◦ 客户端通过socket创建套接字后，调用connect向服务端指定IP地址和端口发起连接请求
◦ 服务端正在监听该端口并不超过最大连接数，则完成三次握手并建立连接。调用accept返回一个文件描述符代表与客户端的连接并开始数据交换。
◦ 客户端断开连接则调用close，服务端读取数据时读到EOF，处理完数据后调用close表示连接关闭。
◦ 注意：监听的socket和建立连接的socket并不一样。建立连接后双方通过read write或send recv向建立连接的socket读写数据。
• UDP通信过程
◦ 服务端和客户端分别使用socket创建套接字并绑定到某个端口。
◦ 通信时通过sendto和recvfrom。
◦ 通信完成后调用close关闭套接字
• 本地socket
◦ 可以是有连接的，也可以是无连接的
◦ 区别是在socket绑定时绑定一个本地文件系统中的路径作为地址。&lt;/p>
&lt;h3 id="aio与io_uring">aio与io_uring
&lt;/h3>&lt;p>&lt;a class="link" href="https://blog.csdn.net/youzhangjing_/article/details/127848418" target="_blank" rel="noopener"
>https://blog.csdn.net/youzhangjing_/article/details/127848418&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://arthurchiao.art/blog/intro-to-io-uring-zh/" target="_blank" rel="noopener"
>https://arthurchiao.art/blog/intro-to-io-uring-zh/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://kdocs.cn/l/chW272CU3dmZ" target="_blank" rel="noopener"
>https://kdocs.cn/l/chW272CU3dmZ&lt;/a>&lt;/p>
&lt;p>aio和io_uring是linux中实现异步io的两种框架。io_uring改善了aio存在的一些问题。&lt;/p>
&lt;ol>
&lt;li>在aio中，提交io操作和获取io操作结果都需要通过系统调用完成，但是系统调用有切换内核态的开销。&lt;/li>
&lt;li>aio只支持dio，不支持buffer io&lt;/li>
&lt;li>aio中提交和获取io操作接口存在用户态和内核态之间的拷贝&lt;/li>
&lt;/ol>
&lt;p>io_uring中在用户态映射了一块共享内存，从而消除了内核态切换的开销。用户进程向共享内存提交需要发起的IO操作，内核线程从共享内存中读取IO操作，并且写入返回结果。&lt;/p>
&lt;p>io_uring创建了3块共享内存，分别是提交队列、完成队列和提交队列项数组。这三个队列都是环形的，类似与NVMe协议中的环形命令队列。提交队列存储待执行的IO操作索引，具体的IO操作参数放在提交队列项数组中。完成队列存储操作结果。&lt;/p>
&lt;p>操作流程是用户提交SQE，内核处理，结果写入CQE，用户读取CQE。整个过程不需要用户态和内核态之间的转换和拷贝。&lt;/p>
&lt;h3 id="如何优化malloc">如何优化malloc
&lt;/h3>&lt;p>如果所有的线程都从同一个地方分配内存，会使得竞争激烈，所以可以划分不同的分配区。优化malloc有预分配和线程本地缓存的思路。比如tcmalloc就是每个线程独立维护一个本地缓存，用于快速分配小对象。优点在于线程的本地缓存不需要获取全局锁，线程之间没有竞争，所以速度快。中对象的缓存全局共享，大对象用mmap分配。中和大对象使用自旋锁。&lt;/p>
&lt;p>还有jemalloc，将分配区划分更细粒度，每个线程绑定一块区域从而减少全局锁争用。释放空间时还会合并相邻空闲块减少碎片。&lt;/p>
&lt;p>tcmalloc小对象分配更快，jemalloc可以控制碎片化，但是内存占用更高&lt;/p>
&lt;p>注意：ptmalloc分配时，brk在堆上分配需要加锁，因为线程共用一个堆。mmap在映射区分配空间时，每个线程可以绑定自己的分配区（arena），不需要全局加锁，只需要局部锁。&lt;/p>
&lt;h3 id="linux中fsync过程">linux中fsync过程
&lt;/h3>&lt;p>用户通过fsync(fd)系统调用发起请求，内核检查fd的有效性，获取对应的struct file对象，根据文件系统调用注册的fsync实现函数。&lt;/p>
&lt;p>fsync会将文件的脏页从page cache写回磁盘，还会将元数据同步回磁盘&lt;/p>
&lt;h3 id="信号量是如何唤醒和阻塞线程的">信号量是如何唤醒和阻塞线程的
&lt;/h3>&lt;p>信号量由一个计数器和等待队列组成。计数器代表当前可用资源的数量，当计数器为正数时，线程可以进入临界区，当计数器为0或负数时，线程需要进入等待队列。等待队列存储因资源不足而被阻塞的线程，调度策略可以是FIFO或按优先级排序的&lt;/p>
&lt;h2 id="网络">网络
&lt;/h2>&lt;h3 id="tcp如何保证可靠">tcp如何保证可靠
&lt;/h3>&lt;p>TCP通过握手挥手建立连接、校验和、序列号确认、滑动窗口、动态重传及拥塞控制等机制，在不可靠的IP层上实现了端到端的可靠传输。其设计平衡了效率与安全性，例如通过SACK减少重传冗余、通过拥塞控制适应网络波动。实际应用中需注意半包/粘包问题（需应用层定义消息边界）及校验和的局限性（无法完全检测多比特错误）&lt;/p>
&lt;h3 id="如何用udp实现可靠传输quic">如何用UDP实现可靠传输/QUIC
&lt;/h3>&lt;p>在应用层实现序列号和确认应答机制，就是为每个数据包添加递增序列号，接收方通过ack报文确认已接受的数据包。并且超时未确认则重传。通过滑动窗口机制避免乱序。这相当于把tcp在应用层又实现了一遍。&lt;/p>
&lt;p>但是也可以采用类似QUIC的设计。quic的头部分为长头部和短头部，只有在建立连接的时候使用长头部，连接建立后使用短头部。从而降低连接开销。&lt;/p>
&lt;p>quic采用动态协商的连接ID标识连接，而不是五元组（源、目的IP；源目的端口；协议）表示。这样能够支持无缝切换网络，并且不易被追踪。&lt;/p>
&lt;p>quic采用严格递增的序列号，因此重传的序列号也不一样。避免出现TCP中的ACK歧义问题（第一次响请求的ACK在网络中堵塞，重传后又发了ACK，无法知道这两个ACK哪一个是重传的，从而不能准确计算RTT）。并且可以支持乱序确认，因为TCP丢包会导致窗口不滑动，而quic中的序列号是严格递增的，可以通过更大的序列号确认后续重发的包。&lt;/p>
&lt;p>之所以支持乱序确认，是因为数据包内容的顺序不是依赖packet number，而是依赖stream id和stream offset表示的。数据接收方根据stream id将数据归类，再根据stream offset重新排序。&lt;/p>
&lt;p>流量控制方面，quic对每个流限制了最大偏移量，防止一个流数据量过大耗尽缓冲区。quic对所有的流的总数据量也有限制，避免整体资源超出限制。根据RTT时间和缓冲区的处理速率动态调整每个流的最大偏移量和所有流的总数据量。&lt;/p>
&lt;p>拥塞控制和TCP差不多，但是可以根据不同应用选择不同拥塞控制算法，而TCP只能用同一套拥塞控制算法。&lt;/p>
&lt;h3 id="队头阻塞问题">队头阻塞问题
&lt;/h3>&lt;p>有哪些拥塞控制算法&lt;/p>
&lt;p>经典的有慢启动、拥塞避免、拥塞发生、快恢复。这是reno算法&lt;/p>
&lt;p>还有更多的，但是这里看不完了。&lt;/p>
&lt;h3 id="三次握手的过程">三次握手的过程
&lt;/h3>&lt;p>三次握手的过程是1. 服务器监听某个端口2.客户端发送第一次握手报文，包括随机初始化序列号、SYN标志并进入syn sent状态3.客户端返回第二次握手syn ack，是对第一次握手的确认，包括确认应答号是第一次握手的序列号+1，随机初始化序列号，SYN和ACK标志并进入syn rcvd状态3. 客户端返回第三次握手报文，包括确认应答号是序列号+1，而且可以携带数据包。进入established状态，4. 服务器收到第三次回收进入established状态&lt;/p>
&lt;p>注意序列号代表报文第一个字节的编号，下一个序列号是上一个序列号+上一个报文长度。确认应答号是期望收到的字节编号。例如上一个请求序列号是1，长度1000，则成功收到的确认应答号是1001，下一个报文序列号是1001。&lt;/p>
&lt;h3 id="每一次握手丢失会怎么样">每一次握手丢失会怎么样
&lt;/h3>&lt;p>首先，tcp有超时重传机制，如果迟迟收不到应答会重发请求或者响应。重发次数可以设置，每一次重发间隔是指数增长的。不过，第一次握手、第二次握手、普通报文和挥手阶段重传的参数是不一样的。&lt;/p>
&lt;p>如果第一次握手丢失，会导致一直收不到ack应答，导致触发重传。一直收不到应答则最终建立连接失败。&lt;/p>
&lt;p>如果第二次握手丢失，会导致服务端收不到第三次握手，服务端会重传ACK。此外客户端会认为是第一次握手丢失，所以会各自重传第一次握手。注意，如果客户端重传第一次握手后收到迟到的ACK响应，会与当前期望的ack不匹配，认为是旧连接，从而丢弃迟到的ack报文。如果重传次数耗尽，就会关闭连接。&lt;/p>
&lt;p>如果第三次握手丢失，服务器会以为第二次握手丢失从而重传第二次握手，客户端根据重传的第二次握手重新发送第三次握手，但是客户端不会主动重传第三次握手。&lt;/p>
&lt;h3 id="什么是syn-flood-攻击有什么危害如何解决">什么是syn flood 攻击，有什么危害，如何解决
&lt;/h3>&lt;p>如果攻击者伪造不同ip大量发起第一次握手而不发送第三次握手，就会导致服务器处于大量syn rcvd状态，从而占用服务器的系统资源。&lt;/p>
&lt;p>处于syn rcvd的连接放在服务器的半连接队列中，半连接队列过多会导致无法为新连接分配资源，导致服务器无法响应正常请求。&lt;/p>
&lt;p>可以增大半连接队列、减少第二次握手的重传次数以快速释放无效连接，或者启用syn cookie技术，就是服务器收到第一次握手后不为连接分配资源，而是再响应报文中嵌入一个cookie值，客户端返回携带正确cookie的第三次握手才会为连接分配资源。&lt;/p>
&lt;h3 id="什么是半连接队列和全连接队列">什么是半连接队列和全连接队列
&lt;/h3>&lt;p>半连接队列是服务端收到第一次握手后，处于syn rcvd状态的连接队列，全连接队列是服务端收到第三次握手后处于established状态的连接队列。&lt;/p>
&lt;p>半连接队列用于临时存放未完成握手的连接请求，全连接队列用于缓存已经建立但是来不及被处理的连接。&lt;/p>
&lt;p>半连接队列采用哈希表存储，为了收到第三次握手后快速根据tcp四元组定位特定连接。全连接队列使用链表存储，只需要先进先出取出队列头部即可。&lt;/p>
&lt;h3 id="四次挥手的过程">四次挥手的过程
&lt;/h3>&lt;p>连接双方都可以主动关闭连接，1.主动关闭放发送第一次挥手，就是设置FIN位的报文，表示主动关闭方不再发送数据但是可以接收数据，进入fin wait 1状态2.被动关闭方发送第二次握手，就是一个ack报文，表示知道关闭请求，但是自己可能还有数据要发送，可以接着发送数据。如果没有数据发送也可以将第三次挥手合并到第二次挥手一起发送。第二次挥手发送后被动关闭放进入close wait状态。3.被动关闭方没有数据要发送了，则发送携带FIN标志位的第三次挥手并进入last ack状态4.主动关闭方收到第三次挥手并发送ack报文，进入time wait状态5. 被动关闭方收到第四次挥手进入closed状态。&lt;/p>
&lt;h3 id="每一次挥手丢失会怎么样">每一次挥手丢失会怎么样
&lt;/h3>&lt;p>第一次挥手丢失，会导致主动关闭方收不到ack响应，重发第一次挥手。超过最大重传次数后就强制断开连接&lt;/p>
&lt;p>第二次挥手丢失，主动关闭方会认为第一次挥手丢失，从而重传第一次挥手，被动关闭方收到重发的第一次挥手，就再发第二次挥手。&lt;/p>
&lt;p>主动关闭方收到第二次挥手后进入fin wait2状态，如果主动关闭方用close关闭，则代表不再收发数据，因此close wait会有超时时间，如果超时时间内未收到第三次挥手则直接关闭连接。如果是shutdown关闭连接则是不发，但是可以收，因此主动关闭方可以一直处于finwait2.&lt;/p>
&lt;p>第三次挥手丢失则收不到ack，被动关闭方会重发第三次挥手。和第一次挥手相似。&lt;/p>
&lt;p>第四次挥手丢失，则被动发送方认为第三次挥手丢失，则重发第三次挥手。&lt;/p>
&lt;h3 id="time-wait和close-wait过多的原因怎么解决">time wait和close wait过多的原因，怎么解决
&lt;/h3>&lt;p>time wait是四次挥手结束后，主动发起关闭的一方进入的状态。作用是1. 防止旧连接干扰，吸收网络中残留的数据包，避免影响后续新建的同端口连接（序列号虽然随机但是可以回绕，如果序列号刚好符合下一个同端口连接则会导致数据错乱）2.如果最后一次ACK丢失则另一方会重发FIN，这时可以重发ACK避免异常关闭连接，持续2MSL，认为数据包全部死亡。&lt;/p>
&lt;p>time wait过多说明连接频繁断开，可能是因为频繁使用短连接、或者大量客户端建立连接后不发送数据导致长连接超时、或者http长连接请求的数量达到上限（每个长连接只能处理上限次请求就要关闭）。&lt;/p>
&lt;p>timewait过多会导致占用系统资源和端口资源。占用系统资源指会占用文件描述符、内存和CPU。占用端口资源是指timewait时无法对相同IP相同端口发起连接。对于客户端来说，端口资源有限，占满会导致新连接报错。对于服务端，虽然监听单一端口，但是可以处理不同客户端，只是不能和刚才这个客户端马上建立连接。但是都会占用系统资源。&lt;/p>
&lt;p>解决timewait过多可以开启长连接代替短连接、排查是否有网络问题导致大量连接超时、允许复用timewait窗口（开启tcp_te_reuse和tcp_timestamp，通过引入时间戳区分新旧数据包）、调高长连接请求上限。&lt;/p>
&lt;p>close wait是被动关闭方发送第二次挥手ACK后进入的状态，该状态允许被动关闭方继续发送数据。&lt;/p>
&lt;p>close wait过多的原因是被动关闭方可能由于代码缺陷没有正确关闭连接。&lt;/p>
&lt;p>close wait过多会导致占用系统资源（文件描述符、内存等）、占用端口。&lt;/p>
&lt;p>如果暂时close wait过多可以重启服务强制释放连接。但是根本在于排查代码的缺陷，需要正确关闭连接。&lt;/p>
&lt;h3 id="close和shutdown关闭">close和shutdown关闭
&lt;/h3>&lt;p>close是关闭socket的文件描述符，并减少引用计数，当引用计数减为0就会真正释放资源并出发4次挥手。close会完全关闭双向通信，无法会通过套接字进行读或写操作&lt;/p>
&lt;p>shutdown是关闭指定方向的通信，而不是减少引用计数。&lt;/p>
&lt;p>close会立即发送fin包，可能丢弃缓冲区的未发送数据，导致数据丢失。如果接收缓冲区有未读数据则会发rst而不是fin。shutdown会等待缓冲区处理完毕再发fin。&lt;/p>
&lt;p>主动调用close后，直接进入timewait，只有3次挥手，调用shutdown有4次&lt;/p>
&lt;h3 id="什么时候会用rst报文">什么时候会用rst报文
&lt;/h3>&lt;ol>
&lt;li>目标端口未开放，则服务器直接回复rst拒绝连接&lt;/li>
&lt;li>重复syn报文，例如一个syn报文在网络阻塞，然后重传新的syn并且建立了连接，就会返回rst终止无效请求&lt;/li>
&lt;li>连接一方因为异常终止连接，又重启，收到对方继续发的数据就会返回rst&lt;/li>
&lt;li>接收到数据包序列号不在滑动窗口范围内，或者数据包校验错误，会发rst&lt;/li>
&lt;li>尝试连接timewait状态的服务器会rst&lt;/li>
&lt;li>接收方缓冲区溢出，处理不过来&lt;/li>
&lt;li>tcp保活机制检测长时间无活动&lt;/li>
&lt;/ol>
&lt;h3 id="linux查看已连接socket端口的命令">Linux查看已连接socket、端口的命令
&lt;/h3>&lt;p>ss命令可以看，参数-a是所有，-t是tcp，-u是udp，-l是监听端口，-p是展示进程信息&lt;/p>
&lt;p>netstat可以看，参数一样，但是性能没有ss好&lt;/p>
&lt;h3 id="tcp和udp区别">TCP和UDP区别
&lt;/h3>&lt;p>tcp是面向连接的有序可靠传输，udp是无连接的不可靠传输。&lt;/p>
&lt;p>tcp需要复杂的重传和建立释放连接开销，头部大。udp传输效率高但是可能丢失，头部小。&lt;/p>
&lt;p>tcp适合文件传输、网页浏览等需要可靠性的场景，udp适合实时性高，如视频通话等场景。&lt;/p>
&lt;h3 id="在电梯间内网络不稳定如何解决音视频信号传输卡顿">在电梯间内网络不稳定，如何解决音视频信号传输卡顿
&lt;/h3>&lt;p>可以动态调整码率，减少传输数据量。&lt;/p>
&lt;p>采用quic协议，首次握手时间仅需1rtt，后续可以0rtt握手。并且支持多路复用，允许并行传输数据流，支持前向纠错，发送冗余数据包，可以减少重传次数。并且切换网络可以保持连接不中断，避免重建连接。最后内置tls加密，不需要专门加密握手。&lt;/p>
&lt;p>因为弱网条件丢包率高容易卡顿，需要通过quic改善可靠性。&lt;/p>
&lt;h3 id="tcp拥塞控制过程">TCP拥塞控制过程
&lt;/h3>&lt;p>TCP拥塞控制的主要过程可以简化为以下几个阶段：&lt;/p>
&lt;p>​慢启动（Slow Start）​
TCP连接建立后，拥塞窗口（cwnd）初始化为1个MSS（最大报文段长度）。
每收到一个ACK确认，cwnd增加1个MSS，因此cwnd呈指数增长。
当cwnd达到慢启动阈值（ssthresh）时，进入拥塞避免阶段&lt;/p>
&lt;p>拥塞避免（Congestion Avoidance）​
在拥塞避免阶段，cwnd每经过一个RTT（往返时间）增加1个MSS，呈线性增长。
目的是避免cwnd增长过快导致网络拥塞&lt;/p>
&lt;p>​拥塞发生（Congestion Detection）​
如果发生超时，TCP认为网络拥塞严重，将ssthresh设置为cwnd的一半，cwnd重置为1，重新进入慢启动阶段。
如果收到3个重复ACK（快速重传），TCP认为发生部分丢包，进入快速恢复阶段&lt;/p>
&lt;p>​快速恢复（Fast Recovery）​
在快速恢复阶段，ssthresh设置为cwnd的一半，cwnd减半并加上3个MSS，然后进入拥塞避免阶段。
目的是在部分丢包的情况下快速恢复传输效率&lt;/p>
&lt;p>总结：TCP拥塞控制通过慢启动、拥塞避免、拥塞发生和快速恢复四个阶段动态调整发送速率，避免网络拥塞并提高传输效率&lt;/p>
&lt;h3 id="两个进程可以用同一个端口吗">两个进程可以用同一个端口吗
&lt;/h3>&lt;p>如果是不同协议，如一个是TCP，一个是UDP，则各自端口空间独立，可以重用。&lt;/p>
&lt;p>如果是同一协议，但是不是同一IP，也可以重用。因为可以配置多个网卡，转发到不同应用。&lt;/p>
&lt;p>内核通过四元组表示连接，如果四元组相同，默认不能显式绑定同一IP地址的同一端口。&lt;/p>
&lt;p>如果开启SO_REUSEADDR选项，则可以复用timewait状态的端口。或者开启tcp_tw_reuse和tcp时间戳，也可以重用time wait状态的端口&lt;/p>
&lt;p>如果开启SO_REUSEPORT选项，则可以多个进程绑定同一个IP和端口。绑定同样IP和端口的连接放到一条哈希冲突链上，&lt;/p>
&lt;h3 id="socket怎么重用连接">socket怎么重用连接
&lt;/h3>&lt;p>为了避免频繁创建和销毁socket，可以使用socket连接池。原理是预创建多个socket，需要用到连接时取出，用完归还。&lt;/p>
&lt;p>初始化时创建一组socket放入池中，避免后面请求时同步的三次握手建立连接。需要使用连接时从池中获取空闲连接，用完后归还到池中而不是关闭。从而允许下次再用。&lt;/p>
&lt;p>需要定期检查连接的有效性，发送心跳包探测连接是否断开。&lt;/p>
&lt;p>连接池可以动态扩展和收缩，根据当前负载和资源消耗。&lt;/p>
&lt;p>空闲连接超时后需要释放，避免资源泄漏。&lt;/p>
&lt;h3 id="一条tcp连接上可以发多少个http请求">一条TCP连接上可以发多少个http请求
&lt;/h3>&lt;p>短连接模式下，每个http请求结束后会立即释放tcp连接。&lt;/p>
&lt;p>长连接模式下，多个http请求可以复用一条tcp连接。理论上只要tcp存在，则可以发的http请求没有上限，但是服务端会限制单个tcp连接处理的http请求次数，这个参数可以调整。&lt;/p>
&lt;p>socket连接中，如果客户端在read()的时候服务器挂掉，会怎么做？客户端有感知吗&lt;/p>
&lt;ol>
&lt;li>如果是服务器进程崩溃了，则内核会回收其socket资源，并发送FIN报文，触发四次挥手。客户端的read会立刻返回0，表示对方已经关闭连接，所以客户端有感知&lt;/li>
&lt;li>如果服务器宕机，
a. 如果开启了tcp保活机制，则一段时间后会发送探测报文，探测报文多次无响应会断开连接
b. 如果没有开启则会一直阻塞，直到客户端下一次给服务器发送报文得不到响应，并且超时重传也得不到响应才会断开&lt;/li>
&lt;/ol>
&lt;h2 id="数据库">数据库
&lt;/h2>&lt;h3 id="事务的特性如何保证">事务的特性，如何保证
&lt;/h3>&lt;p>事务的特性是ACID，即原子性、一致性、隔离性、持久性。&lt;/p>
&lt;p>原子性是指一个事务中的所有操作，要么全部完成，要么全都不完成。&lt;/p>
&lt;p>一致性是指事务操作前后，数据满足完整性约束，不能出现我账户的钱减少而对方账户钱不增加的情况。&lt;/p>
&lt;p>隔离性是指，数据库允许多个并发事务读写数据，需要隔离多个事务读写数据时的相互干扰。&lt;/p>
&lt;p>持久性是指，数据库事务提交后，对数据的修改是永久的，即使系统故障也不会丢失。&lt;/p>
&lt;p>原子性通过undo log回滚保证，在事务执行之前，数据库会记录操作前的数据状态到undo log，如果事务失败则根据undo log逆向操作，将数据恢复事务之前的状态。&lt;/p>
&lt;p>一致性是由原子性隔离性和持久性保证的&lt;/p>
&lt;p>隔离性可以通过锁机制和多版本并发控制保证。&lt;/p>
&lt;p>持久性可以通过redo log保证。&lt;/p>
&lt;h3 id="undo-log和redo-log什么时候起作用">undo log和redo log什么时候起作用
&lt;/h3>&lt;p>undo log用来保证事务的原子性，保证事务失败时可以通过undo log回滚到事务发生之前的状态。redo log用来保证事务的持久性，保证系统故障时可以根据redo log重放操作。
事务在commit之前不会落盘，因此这个阶段主要是根据undo log保证能够回滚。事务在commit之后保证落盘，这个阶段如果出问题就根据redo log重放操作。&lt;/p>
&lt;h3 id="事务的隔离级别">事务的隔离级别
&lt;/h3>&lt;p>四个级别：读未提交、读已提交、可重复读、串行化&lt;/p>
&lt;p>读未提交是一个事务的修改在提交之前就可以被其他事务看到。&lt;/p>
&lt;p>读已提交是一个事务的修改只有在提交之后才能被其他事务看到。&lt;/p>
&lt;p>可重复读是一个事务执行过程中看到的数据一直和事务启动时看到的数据是一致的。是innodb引擎的默认隔离级别&lt;/p>
&lt;p>串行化是对记录加读写锁，多个事务通过读写锁访问数据。&lt;/p>
&lt;p>脏读是指读取到其他事务还未提交的数据，这些数据是有可能回滚的。&lt;/p>
&lt;p>不可重复读是一个事务多次读取同一个数据，但是前后读到的不一样。比如数据被其他事务提交，但是这个数据和本事务开始时看到的不一样&lt;/p>
&lt;p>幻读是一个事务中满足查询记录的条目数量会因为其他事务提交数据而变化。&lt;/p>
&lt;p>读未提交可能发生脏读、幻读、不可重复读&lt;/p>
&lt;p>读已提交可能发生不可重复读和幻读&lt;/p>
&lt;p>可重复读可能发生幻读&lt;/p>
&lt;p>串行化不会发生这些现象。&lt;/p>
&lt;h3 id="可重复读的实现原理">可重复读的实现原理
&lt;/h3>&lt;p>在可重复读级别下，每个事务在第一次查询时会生成一个readview，后续的查询语句会利用read view找到开始查询时的数据，所以每次查询都是一样的。&lt;/p>
&lt;h3 id="可重复读不能解决幻读">可重复读不能解决幻读
&lt;/h3>&lt;p>事务的读取有快照读和当前读。快照读是普通的select语句，基于事务启动时的read view。当前读是select dor update、update或insert等显式要求读取最新数据或者可能修改数据的操作。&lt;/p>
&lt;p>事务如果更新了其他事务插入的数据（虽然看不到），会导致更新快照，后续查询会包含新数据。&lt;/p>
&lt;p>可以在开启事务后，马上执行当前读语句，这样会给记录加next key锁，避免其他事务插入新记录。&lt;/p>
&lt;h3 id="mvcc版本链实现记录的可见性">MVCC版本链实现、记录的可见性
&lt;/h3>&lt;p>读提交在每个select执行之前重新生成read view&lt;/p>
&lt;p>可重复读在执行第一个select时生成一个read view，然后该事务都用这个read view&lt;/p>
&lt;p>read view有4个字段，包括创建read view 的事务id，创建read view时当前数据库中未提交的事务id列表，创建readview时当前数据库中未提交的事务中最小事务的id，创建read view时当前数据库预留的下一个事务的id&lt;/p>
&lt;p>innodb存储引擎的数据表记录中，每条记录会有隐藏列，包括事务id和指向旧版本记录的指针。指针的意思是说，每次改动记录时会将旧版本的记录写到undo日志中，这个指针就可以找到旧版本记录。&lt;/p>
&lt;p>如果记录的事务id小于read view中未提交事务的最小id，就说明记录在创建read view之前已经提交，所以可见。&lt;/p>
&lt;p>如果记录的事务id大于read view预留的下一个id，说明事务是在创建read view 之后创建，所以不可见。&lt;/p>
&lt;p>如果记录的事务id在两者之间，则检查read view的未提交事务列表，如果在列表则说明未提交，所以不可见，如果不在则已经提交，所以（对读提交来说）可见&lt;/p>
&lt;h3 id="事务没有commit之前会不会持久化为什么需要undo-log">事务没有commit之前会不会持久化，为什么需要undo log
&lt;/h3>&lt;p>事务在commit之前，数据的持久化程度取决于redo log的刷盘策略。&lt;/p>
&lt;p>在事务的运行过程中，mysql会把日志写到redo log buffer中，等到事务真正提交的时候，再将buffer中的内容写到redo log文件中。但是这个过程没有绕过page cache，也就是说提交的时候只是写到了pagecache，还需调用fsync保证落盘。&lt;/p>
&lt;p>但是，在事务还未提交的时候，redolog也可能落盘，因为innodb有一个后台线程，会定期将redolog buffer中的日志写到pagecache，然后调用fsync持久化，因此事务没有commit也会部分落盘。并且其他事务提交时，可以设置将redo log buffer全部落盘，因此可能被带着持久化。第三种情况是事务的redo log buffer超过指定大小，这时候也需要写盘。&lt;/p>
&lt;p>因为事务在未提交时候也可能部分落盘，所以需要undo log。&lt;/p>
&lt;h3 id="一条update是不是原子性的">一条update是不是原子性的
&lt;/h3>&lt;p>update是原子性的，主要通过锁和undolog日志保证。执行update时会加行级锁，保证一个事务更新一条记录时不会被其他事务打扰。事务执行过程中会生成undolog，如果执行失败可以根据undolog回滚。&lt;/p>
&lt;h3 id="一个事务的语句特别多会怎样">一个事务的语句特别多会怎样
&lt;/h3>&lt;p>为了保证事务的原子性和一致性需要加锁，如果语句过多会导致锁住太多数据，使得数据库性能下降，并可能会锁超时。其次需要保存的回滚记录太多占用空间。最后这个事务的执行时间长，会导致主从延迟（？）&lt;/p>
&lt;h3 id="mysql的锁">mysql的锁
&lt;/h3>&lt;p>mysql中有全局锁、表级锁和行级锁。&lt;/p>
&lt;p>全局锁会将整个数据库锁住，用于全库备份。&lt;/p>
&lt;p>表级锁：
• 表锁：lock tables 表名 read/write，read就是读锁（共享锁，其他线程只读），write就是写锁（独占锁，其他线程不能访问）。注意加锁之后在解锁之前本线程不允许访问其他表。表锁的颗粒度大，影响并发性能
• 元数据锁：这里的元数据是指的表结构，操作数据表时会自动加元数据锁。CRUD加读锁，更改表结构加写锁。注意这里写锁申请不到，会导致所有事务不能申请读锁。阻塞住
• 意向锁：当事务需要对某行加锁时，先申请表级的意向共享锁或者意向排他锁，这样其他事务可以快速判断该表中是否有行级锁，避免逐行扫描。比如一张表获取了行级独占锁，那么另一个事务就不能对这张表加锁。
• auto inc锁用于管理表内的自增列，保证自增字段的唯一性和连续性。auto inc锁是插入语句执行完就释放，而不是等待事务结束再释放。还有一种更轻量的自增锁，将自增字段赋值之后就释放了，而不是等到插入语句完成。&lt;/p>
&lt;p>行级锁：innodb引擎支持，myisam不支持，需要先加表级意向锁避免逐行扫描
• 记录锁：
◦ 锁住的是记录，可以有共享和独占两种。一个事务对一行加共享锁后，其他事务还可以对这一行加共享锁，但是不能加独占锁。如果加了独占锁，其他事务不能对这行加锁。
• 间隙锁
◦ 间隙锁是在可重复读级别下引入的一种行级锁，锁定的是一个区间而不是具体的记录。加锁之后不能对区间中做插入操作，从而避免幻读。
• next key锁
◦ 结合了记录锁和间隙锁，既能锁定记录本身不被修改，又不允许在范围内插入记录。&lt;/p>
&lt;ol>
&lt;li>Level DB&lt;/li>
&lt;li>join table 实现方式&lt;/li>
&lt;li>数据库如何处理null&lt;/li>
&lt;li>数据库如何判断事务的可见性
• 数据库存储引擎格式
• B+树上数据记录1 1 1，一个操作将其更新为 1 2 2，如何操作？
◦ 记录日志
• mysql中事务A读 1 1 1，另一个事务B将其update为1 2 2，但没有提交，那么当前处理器，B+树中存了哪些数据，页面的值是什么，哪些信息发生了变化
• 版本号存在哪里，如何组织
• RocksDB
• 主键索引和联合索引的区别
• 主键索引在索引表上只存有索引数据吗&lt;/li>
&lt;/ol>
&lt;h2 id="分布式">分布式
&lt;/h2>&lt;p>RDMA&lt;/p>
&lt;p>raft协议&lt;/p>
&lt;p>GFS如何保证高可用&lt;/p>
&lt;p>存储系统如何做容灾备份&lt;/p>
&lt;h2 id="linux命令">Linux命令
&lt;/h2>&lt;p>• 查看磁盘使用量的命令
◦ df命令查看文件系统的整体磁盘空间占用情况，-h转换成MBGB显示，-i显示inode使用情况，-T显示文件系统类型
◦ du命令查看目录或文件的磁盘占用
◦ 有隐藏文件怎么办
▪ 隐藏文件以一个点开头，可以指定通配符：.[!.]*
• .*表示以.开头的所有文件
• [!.]表示第二个不为. 即不包括父目录
◦ df统计文件系统整体空间，包括已删除但被进程占用的文件，du统计现存文件的占用。两者差异过大可以用lsof列出系统打开文件进行排查
• 查看某个端口被哪个服务占用的命令
◦ ss命令
◦ netstat命令
查看dd命令进度的方法
在较新版本的dd中，可直接通过status=progress参数显示实时进度&lt;/p>
&lt;h2 id="git场景用法">git场景用法
&lt;/h2>&lt;h2 id="数据结构与算法">数据结构与算法
&lt;/h2>&lt;p>B+树、基数树、红黑树、还有哪些树结构、比较&lt;/p>
&lt;p>口述一下用两个栈模拟队列&lt;/p>
&lt;p>用两个栈模拟队列就是需要两次翻转。两个栈分别是入队栈和出队栈。比如将12345加入入队栈，在出栈的时候先将其压入出队栈变成54321，最后弹出出队栈就变成了12345.&lt;/p>
&lt;h3 id="八个常见排序算法">八个常见排序算法
&lt;/h3>&lt;p>排序算法分为基于比较的和非比较的。非比较的排序算法中一个数的值就决定了应该放在哪个位置
基于比较的排序算法有 选择排序、冒泡排序、插入排序、希尔排序、归并排序、快速排序、堆排序
非比较的排序算法有计数排序、基数排序、桶排序。
非比较的排序算法很有局限性，对数据有很多限定。例如计数排序需要小范围整数、基数排序需要数据是相同位数、桶排序需要数据均匀分布。并且非比较算法通常需要较多辅助空间。&lt;/p>
&lt;p>选择排序：每次扫描数组可以选出本轮最小的元素，交换到数组的开头。因此需要On2。选择排序的执行时间与数据无关。
冒泡排序：每一轮扫描将较大的数据和后面相邻元素交换。On2如果某一轮没有数据交换，则说明已经有序可以退出。因此顺序数组可以实现On的复杂度
插入排序：类似扑克牌方式，数组的前端是有序数组，每次将当前的元素插入有序部分，也就是逐个交换，直到前面的元素比该元素小。如果本身有序则On。插入排序比选择排序好，因为对于有序数组可以降为On，而且内层循环很有可能提前终止，而冒泡排序提前终止比较少见。插入排序很适合接近有序或规模较小的数组，因为这些数组很容易提前终止内层循环。归并排序和快速排序拆分到较小子区间的时候可以转为使用插入排序，更快。
希尔排序：比快排差但是不需要递归，可以用在不支持递归的环境。希尔排序是分组插入排序，将数组按间隔分为多个组（比如0，4，8为1组，1，5，9为一组等），对每组执行插入排序。接下来将间隔缩减为一半，再执行插入。因此数据会越来越有序，适合插入排序。最后间隔为1.&lt;/p>
&lt;p>快速排序：随机选择区间内某一个元素作为基准，将区间内所有小于基准的交换到基准之前，将所有大于基准的交换到基准之后。因此基准就在应该在的地方。分别再排序pivot左边和pivot右边区间
之所以随机选择是因为对于有序数组来说会使得左边的子区间特别小、右边子区间特别大，使得递归树倾斜
双路快排是pivot相等元素过多时，避免重复元素堆积到单侧，导致容易出现有序情况，从而递归树倾斜。每次将等于pivot的元素平均分到pivot两侧：&lt;/p>
&lt;ol>
&lt;li>选择基准值（通常为左端元素，但推荐随机化选择&lt;/li>
&lt;li>i指针向右移动，直到遇到大于基准值的元素；j指针向左移动，直到遇到小于基准值的元素。&lt;/li>
&lt;li>交换i和j的元素，继续扫描直至两指针相遇。&lt;/li>
&lt;li>将基准值与j指针位置交换，完成分区。
优势：通过双向扫描，减少单侧元素堆积，使分区更均衡，降低递归深度
三路快排是每次将等于pivot的元素都排到一起，可以避免接下来的区间中再出现pivot，从而减少了左右递归区间的长度
• 指针定义与初始化
◦ lt（左边界）：初始指向l，左侧区域的上界。
◦ gt（右边界）：初始指向r+1，右侧区域的下界。
◦ i（遍历指针）：初始指向l+1，从左向右扫描元素。
• 遍历与交换逻辑
◦ 当前元素 &amp;lt; 基准值：与lt+1位置的元素交换，lt和i均右移。
◦ 当前元素 &amp;gt; 基准值：与gt-1位置的元素交换，gt左移（i不动，需重新检查交换后的元素）。
◦ 当前元素 = 基准值：仅i右移。
• 终止条件：当i与gt相遇时，遍历结束。
• 基准值归位
◦ 将基准值（原左端元素）与lt位置的元素交换，此时基准值位于中间区域的左边界。
◦ 递归处理左区域（l至lt-1）和右区域（gt至r），中间区域无需处理&lt;/li>
&lt;/ol>
&lt;h3 id="b树-增删查olog_mn-n为总数据量m为每个节点的最大子节点树">B+树 增、删、查Olog_m^n n为总数据量，m为每个节点的最大子节点树
&lt;/h3>&lt;p>B+树是一种多路平衡查找树，所有数据记录在叶子节点，非叶子节点只存键和子结点指针。叶子节点形成一个链表，便于范围查找和遍历。由于多路，节点存储密度高，适合磁盘，能够减少磁盘IO次数，例如EXT4中的extent。传统inode使用多级间接索引，而B+树可以减少查询次数，提高效率&lt;/p>
&lt;p>B树 增、删、查Olog_m^n n为总数据量，m为每个节点的最大子节点树&lt;/p>
&lt;p>B树也是一种多路平衡查找树，数据放在叶子节点和内部节点上，叶子节点既存储键值又存储数据本身或者数据的指针。并且叶子节点没有链式连接，遍历不方便（这是因为数据在非叶子节点上，有链表也没用）&lt;/p>
&lt;p>与B+树相比，B树不适合范围查询，因为需要回溯遍历。B树不如B+树扁平，因为B+树的非叶子节点不存储数据，可以放更多子节点指针。B树的删除插入节点可能在任意层分裂和调整。而B+树只影响叶子节点，复杂度较小。&lt;/p>
&lt;p>B树的优点在于键值唯一，因为B+树只有叶子节点才放值，可能存储重复的键&lt;/p>
&lt;h3 id="红黑树">红黑树
&lt;/h3>&lt;p>红黑树是一种自平衡的二叉查找树，最长路径不超过最短路径的两倍，特点是插入删除的时候，旋转次数少，保证增删改查的时间复杂度是Ologn，适合内存中的数据结构，比如虚拟内存管理中的VMA
通过颜色翻转和很少的旋转可以保持平衡，常数时间&lt;/p>
&lt;p>B+树如果插入导致叶子节点分裂需要递归调整父节点的索引键&lt;/p>
&lt;h3 id="b树插入流程">B+树插入流程
&lt;/h3>&lt;p>插入步骤&lt;/p>
&lt;p>• 定位叶子节点&lt;/p>
&lt;p>从根节点开始，根据关键字大小向下查找，直到找到对应的叶子节点（插入操作仅在叶子层进行）&lt;/p>
&lt;p>• 直接插入（未溢出）&lt;/p>
&lt;p>若叶子节点当前关键字数 k&amp;lt;m−1，直接按序插入新关键字并更新指针，操作结束&lt;/p>
&lt;p>• 分裂叶子节点（溢出处理）&lt;/p>
&lt;p>若插入后关键字数 k=m，则分裂为两个节点：&lt;/p>
&lt;p>• 左节点：保留前 ⌈m/2⌉ 个关键字。&lt;/p>
&lt;p>• 右节点：包含剩余 ⌊m/2⌋ 个关键字。&lt;/p>
&lt;p>• 中间关键字上浮：将第 ⌈m/2⌉ 个关键字（即左节点的最大值）复制到父节点作为索引&lt;/p>
&lt;p>• 递归调整父节点
◦ 若父节点因接收上浮关键字导致 k=m，则继续分裂父节点，直至根节点。
◦ 若根节点分裂，则生成新根（树高增加1），新根包含1个关键字和2个子指针&lt;/p>
&lt;p>示例（4阶B+树）&lt;/p>
&lt;ol>
&lt;li>
&lt;p>插入43：根节点（也是叶子节点）变为 [43]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>插入48, 36：叶子节点变为 [36, 43, 48]。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>插入32：节点分裂为 [32, 36] 和 [43, 48]，关键字36上浮到父节点&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>关键点&lt;/p>
&lt;p>• 分裂策略：偶数阶（如4阶）取 ⌈m/2⌉（即第2个关键字）上浮；奇数阶（如3阶）取中间关键字&lt;/p>
&lt;p>• 索引更新：内部节点仅存储关键字副本（或最大值）和子指针，不存储实际数据&lt;/p>
&lt;h3 id="avl树">AVL树
&lt;/h3>&lt;p>AVL树也是一种自平衡二叉查找树，可以保证时间复杂度为logn。AVL树要求每个节点的左右子树高度差不超过1，否则需要旋转调整。树的高度比红黑树小，因为红黑树只是保证最长路径不超过最短路径的两倍。但是旋转调整的开销大。红黑树由于放宽了平衡限制，可以保证旋转操作不超过3次，所以适合频繁修改的场景。&lt;/p>
&lt;h3 id="基数树-ok">基数树 Ok
&lt;/h3>&lt;p>基数树是一种前缀树，结点存储字符或部分字符串，路径从根到叶子标识完整键，适合需要按前缀快速检索字符串的场景，通过合并公共前缀减少存储冗余，例如page cache就是基数树&lt;/p>
&lt;h3 id="三种树比较">三种树比较
&lt;/h3>&lt;p>B+树和红黑树查询都是Ologn，但是红黑树插入删除的开销小。&lt;/p>
&lt;p>B+树是为磁盘优化的，一是树的高度小，便于减少访存，适合大数据量场景，二是结点与磁盘页面对齐，可以预读其他结点，三是双向链表便于范围查找和遍历。&lt;/p>
&lt;p>红黑树的高度高于B+树，但是插入删除结点的旋转的次数少，开销小。而B+树需要合并和分裂结点，操作复杂度为Ologn&lt;/p>
&lt;p>B+树用于文件系统和数据库索引，大规模数据树高可控。&lt;/p>
&lt;p>红黑树适合内存中经常修改删除的场景，能够减少更新开销。比如stl中的map和set。&lt;/p>
&lt;p>基数树能够通过共享前缀减少存储量。例如两个字符串共享前缀，则前缀放在父节点中，后面不同的部分放在两个子节点。通过前缀的匹配能够快速查询字符串，Ok，k是最长字符串长度。比如在page cache中将文件偏移量映射到物理页，偏移量作为键，4K页的地址作为值。&lt;/p>
&lt;h3 id="完全二叉树">完全二叉树
&lt;/h3>&lt;p>只允许最后一排不满， 中间不可以有空缺，最后一排必须从左往右排序。&lt;/p>
&lt;h3 id="堆">堆
&lt;/h3>&lt;p>堆是一种完全二叉树。&lt;/p>
&lt;p>大根堆是指堆中每个节点都要大于等于子节点，小根堆是堆中每个节点都要小于等于子节点。&lt;/p>
&lt;p>堆通常用数组的形式实现，按照层序遍历存放在数组中&lt;/p>
&lt;p>建堆：1. 自下而上：将新元素插入叶子节点并且向上过滤；2.自上而下： 将新元素插入根节点并向下过滤&lt;/p>
&lt;p>向上过滤：将某个叶子节点与父节点比较，如果大于/小于父节点就交换，直到根节点。&lt;/p>
&lt;p>向下过滤：将父节点与子节点比较，若小于子节点就和最大/最小的子节点交换，直到叶子节点。&lt;/p>
&lt;p>堆排序&lt;/p>
&lt;p>从小到大排序就是小顶堆（每次弹出最小的根节点），从大到小排序就是大顶堆。&lt;/p>
&lt;p>小顶堆/大顶堆建堆：第一步将数组调整为堆，On&lt;/p>
&lt;p>• 从最后一个非叶子节点开始逆序下沉/上浮&lt;/p>
&lt;p>排序：每次将堆顶元素交换到末尾，并缩小堆范围重新建堆，Onlogn&lt;/p>
&lt;h2 id="其他">其他
&lt;/h2>&lt;h3 id="实时系统优化">实时系统优化
&lt;/h3>&lt;p>可以从任务调度、高可靠性和资源利用方面展开。比如调度进程的时候可以分配优先级，并且采用抢占式调度，让更紧急的任务提前执行。&lt;/p>
&lt;p>内存优化
• 预分配内存池：避免动态内存分配导致的碎片和延迟。例如，在启动阶段为实时任务预留固定内存区域
• 大页内存（HugePage）：减少TLB缺失率，提升内存访问效率（适用于高频访问的数据缓冲区）&lt;/p>
&lt;h3 id="将zns用在云存储上">将ZNS用在云存储上
&lt;/h3>&lt;p>&lt;a class="link" href="https://mp.weixin.qq.com/s?__biz=Mzg3MjY5MTc0Ng==&amp;amp;mid=2247485054&amp;amp;idx=1&amp;amp;sn=3606a61e043dee464899134109496a9d&amp;amp;chksm=cf0c4dc9e45288826fc3e866dd3a67f92afebb709f0e3c6141842d9eb2f891da28327af6f6cf#rd" target="_blank" rel="noopener"
>https://mp.weixin.qq.com/s?__biz=Mzg3MjY5MTc0Ng==&amp;mid=2247485054&amp;idx=1&amp;sn=3606a61e043dee464899134109496a9d&amp;chksm=cf0c4dc9e45288826fc3e866dd3a67f92afebb709f0e3c6141842d9eb2f891da28327af6f6cf#rd&lt;/a>&lt;/p>
&lt;p>字节跳动做过相关的研究，实际上效果并不好。一方面，使用ZNS需要对软件栈做较大的修改，比如这个顺序写限制。那么对于现有的生态适配是一个挑战。第二个，就是ZNS本身的优化也有点虚。比如，他最原始的那篇文章中是将文件系统层次的GC也当作正常的IO带宽来算，因为盘并不知道文件系统的GC操作，而GC也就是把数据从盘上读出来再写到另一个地方去，那你带宽当然是大的。但是垃圾回收的带宽并不是用户真是想要的，所以ZNS的性能优化本身就是存疑的。第三点，ZNS将盘内管理的工作交给主机去控制，从某种程度来说是给主机增加了负担，因为盘上本身是有一个主控的。对于云服务来说更是这样，本身存储节点也有一定计算能力。那现在将这些结点上的计算能力浪费了。因此不是特别合适。但是我手机上没这个问题，因为手机上一方面用的本身是F2FS，他的管理方式本来就适合ZNS，不会因为使用ZNS额外增加开销。另一方面手机的UFS本身没有计算能力，确实比较适合ZNS。但是对于云服务来说，我看不是特别适合。&lt;/p>
&lt;h3 id="怎么解决多-cpu-下同时访问自旋锁的性能问题">怎么解决多 CPU 下同时访问自旋锁的性能问题
&lt;/h3>&lt;p>无锁数据结构替代：对高频访问场景（如计数器），优先使用原子变量或无锁队列&lt;/p>
&lt;p>混合锁策略：对长临界区代码切换为互斥锁（如pthread_mutex），避免CPU资源浪费&lt;/p>
&lt;p>读写锁分离（Read-Write Lock）&lt;/p>
&lt;p>对读多写少场景，使用读写自旋锁（如rwlock），允许多个读线程并发访问，减少写线程阻塞时间&lt;/p>
&lt;p>缓存行填充（Cache Line Padding）&lt;/p>
&lt;p>将锁变量独占一个缓存行（如64字节对齐），避免与其他变量共享缓存行。例如Linux内核的spinlock_t结构体通过__attribute__((aligned(64)))强制对齐&lt;/p>
&lt;p>分片锁（Sharded Lock）&lt;/p>
&lt;p>将全局锁拆分为多个子锁，细化锁的粒度，通过哈希函数将资源映射到不同子锁，降低单个锁的争用率。例如，天翼云在高并发CDN场景中采用外层锁+内层锁的分级架构，通过哈希算法将80个Worker进程的竞争分散到多个外层锁，最终仅少数进程进入内层锁竞争&lt;/p>
&lt;h3 id="缓存行乒乓效应">缓存行乒乓效应
&lt;/h3>&lt;p>缓存行乒乓效应（Cache Line Ping-Pong Effect）是多核系统中因多个处理器频繁读写同一缓存行导致的高性能损耗现象，其本质是缓存一致性协议（如MESI）的频繁触发。以下从原理、影响及优化策略展开分析：
共享缓存行的争用&lt;/p>
&lt;p>当多个CPU核心同时访问同一缓存行内的数据时（即使数据不同），会触发缓存一致性协议（如MESI）的广播机制。例如：&lt;/p>
&lt;p>假共享（False Sharing）：不同线程访问同一缓存行中的独立数据（如数组相邻元素），导致缓存行被频繁无效化&lt;/p>
&lt;p>硬件机制的限制&lt;/p>
&lt;p>缓存行粒度：缓存以固定大小（通常64字节）的缓存行为单位管理，无法区分同一缓存行内的不同数据
MESI协议开销：每次缓存行状态变更（如从Modified到Invalid）需跨核心同步，导致总线带宽和CPU周期浪费&lt;/p>
&lt;p>二、性能影响&lt;/p>
&lt;p>吞吐量下降&lt;/p>
&lt;p>单核场景下操作耗时若为1单位，双核可能因乒乓效应增至2-3单位&lt;/p>
&lt;p>例如，全局计数器在多核下的吞吐量可能随线程数增加而指数级下降&lt;/p>
&lt;p>资源浪费&lt;/p>
&lt;p>缓存带宽占用：缓存行频繁传递占用内存控制器带宽；&lt;/p>
&lt;p>CPU空闲等待：核心因等待缓存行同步而无法执行有效指令&lt;/p>
&lt;p>三、优化策略&lt;/p>
&lt;p>将高频访问的变量独占一个缓存行，避免假共享。例如：&lt;/p></description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>疑难经验 on The Orange Flavored Whisper</title><link>https://realcedriccheng.github.io/categories/%E7%96%91%E9%9A%BE%E7%BB%8F%E9%AA%8C/</link><description>Recent content in 疑难经验 on The Orange Flavored Whisper</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 13 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://realcedriccheng.github.io/categories/%E7%96%91%E9%9A%BE%E7%BB%8F%E9%AA%8C/index.xml" rel="self" type="application/rss+xml"/><item><title>以力扣49为例 - 自定义哈希函数</title><link>https://realcedriccheng.github.io/p/self_define_hash/</link><pubDate>Thu, 13 Feb 2025 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/self_define_hash/</guid><description>&lt;p>题目链接： &lt;a class="link" href="https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/" target="_blank" rel="noopener"
>https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/&lt;/a>&lt;/p>
&lt;p>题解中定义了&lt;code>array&amp;lt;int, 26&amp;gt;&lt;/code>到 &lt;code>vector&amp;lt;string&amp;gt;&lt;/code>的映射，其中前者为一个大小为26的int数组。C++中，除了vector这种变长数组，还提供了固定大小数组的std::array这个容器类模板。用意是更好的类型检查和防止越界错误，还可以使用标准库的很多算法函数。性能和原生数组相同。使用前需要&lt;code>#include &amp;lt;array&amp;gt;&lt;/code>。&lt;/p>
&lt;p>之所以要定义这个映射，是因为互为字母异位词的两个字符串，他们每个字母出现的频率是相同的。所以用&lt;code>array&amp;lt;int, 26&amp;gt;&lt;/code>作为key，将字母异位词分组。而key相同的字符串需要插入映射的&lt;code>vector&amp;lt;string&amp;gt;&lt;/code>中。&lt;/p>
&lt;p>unordered_map和unordered_set等基于哈希表的容器默认只能处理内置类型（如整数、指针）和一些标准库类型（string等）。对于自定义类型或复杂类型，如&lt;code>array&amp;lt;int, 26&amp;gt;&lt;/code>，需要提供一个合适的哈希函数才能作为key。&lt;/p>
&lt;p>哈希函数的目的是区分不同的key。合适的哈希函数需要将相同的key映射到相同的slot，而哈希碰撞的概率很小。在实现哈希函数时，注意：&lt;/p>
&lt;ul>
&lt;li>函数返回值为size_t类型，这是因为unordered_map是基于哈希表的数据结构，索引是基于哈希值的，而哈希值就是一个无符号整数。不用int是为了避免符号扩展的问题。具体需要参考unordered_map的实现。&lt;/li>
&lt;li>一般的设计方法有
&lt;ul>
&lt;li>利用&lt;code>std::hash&amp;lt;int&amp;gt;&lt;/code>函数，需要&lt;code>#include &amp;lt;functional&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;strong>位运算&lt;/strong>：如位移、异或等操作可以帮助混合不同的比特位。&lt;/li>
&lt;li>&lt;strong>乘法和加法&lt;/strong>：通过乘以素数并加上其他数值，可以使结果更加随机化。&lt;/li>
&lt;li>&lt;strong>组合多个哈希值&lt;/strong>：如果输入数据由多个字段组成，可以分别对每个字段进行哈希计算，然后将这些哈希值组合起来。
总之，自定义哈希函数就是要保证输入相同的key时，返回值相同；输入不同的key时，返回值尽量不同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>本题中，key是一个整数数组。因此可以组合数组中每一位整数的哈希值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span class="line">&lt;span class="cl">&lt;span class="n">size_t&lt;/span> &lt;span class="n">my_hash&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">const&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="n">array&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="ne">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">26&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="ne">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">size_t&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">k&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">hash&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">hash&lt;/span> &lt;span class="o">&amp;lt;&amp;lt;&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="p">::&lt;/span>&lt;span class="nb">hash&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="ne">int&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">{}(&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">hash&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>至于哈希函数&lt;code>std::hash&amp;lt;int&amp;gt;{}()&lt;/code>中为什么有{}，这是因为std::hash是一个类模板，()是他定义的函数运算操作符。&lt;code>std::hash&amp;lt;int&amp;gt;{}&lt;/code>的意思是临时创建一个&lt;code>std::hash&amp;lt;int&amp;gt;&lt;/code>类型的匿名临时对象，{}是参数列表（不需要参数）。这个对象后面再用()，就是调用了该临时对象定义的操作符。&lt;/p>
&lt;p>使用左移和异或就是想要哈希函数映射得更均匀，尽量保留每一位的特征。&lt;/p>
&lt;p>题解使用了嵌套的Lambda表达式，太复杂。还可以使用函数对象（仿函数）实现。函数对象是一个具有operator()的类实例。不仅可以像函数一样调用，还可以保存状态。此处不介绍。&lt;/p></description></item><item><title>什么是trim命令</title><link>https://realcedriccheng.github.io/p/what_is_trim_command/</link><pubDate>Sun, 08 Dec 2024 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/what_is_trim_command/</guid><description>&lt;p>操作系统通过trim命令通知SSD哪些块不再使用，可以擦除或回收。&lt;/p>
&lt;p>文件系统在删除文件时，仅将数据块标记为未使用。因此文件所在的位置只有下一次写入时才会被覆盖。但是对于SSD，数据页在重写之前必须擦除其所在块。因此存在垃圾回收和写放大。&lt;/p>
&lt;p>trim命令使得SSD知道哪些数据页是无效的，在做垃圾回收时不搬移这些页。&lt;/p>
&lt;p>因此，在SSD做过垃圾回收之后几乎不可能恢复数据。但是HDD中被删除的数据仍有可能恢复。&lt;/p></description></item><item><title>linux中查看内核信息总是报fd0错</title><link>https://realcedriccheng.github.io/p/fd0/</link><pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/fd0/</guid><description>&lt;p>&lt;img src="https://realcedriccheng.github.io/p/fd0/1.png"
width="1160"
height="66"
srcset="https://realcedriccheng.github.io/p/fd0/1_hu_22616f040a65aade.png 480w, https://realcedriccheng.github.io/p/fd0/1_hu_ce547a2e4c6ed346.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1757"
data-flex-basis="4218px"
>&lt;/p>
&lt;p>开机以后查看内核信息，总是报fd0相关的错误。这是因为系统启动的时候加载了软盘驱动，但是没有软盘。所以fd0是用不了的。可以忽略这些信息，也可以禁用软盘。&lt;/p></description></item><item><title>配置riscv64-unknown-elf-gdb环境</title><link>https://realcedriccheng.github.io/p/riscv64-unknown-elf-gdb/</link><pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate><guid>https://realcedriccheng.github.io/p/riscv64-unknown-elf-gdb/</guid><description>&lt;p>由于实验用到的汇编代码是riscv的，不能直接用gdb调试，而要用riscv64-unknown-elf-gdb。这个版本的gdb属于riscv工具链。&lt;/p>
&lt;p>要安装riscv工具链，可以下载源代码自己编译，也可以下载预编译的二进制文件。这里我从&lt;a class="link" href="https://mirror.iscas.ac.cn/riscv-toolchains/release/riscv-collab/riscv-gnu-toolchain/LatestRelease/" target="_blank" rel="noopener"
>ttps://mirror.iscas.ac.cn/riscv-toolchains/release/riscv-collab/riscv-gnu-toolchain/LatestRelease/&lt;/a>或者&lt;a class="link" href="https://github.com/riscv-collab/riscv-gnu-toolchain/releases" target="_blank" rel="noopener"
>https://github.com/riscv-collab/riscv-gnu-toolchain/releases&lt;/a>选择适合的版本下载，我下载的是riscv64-elf-ubuntu-18.04-nightly-2022.11.12-nightly.tar.gz。&lt;/p>
&lt;p>在ubuntu中解压后，将riscv目录复制到要安装的地点，再将安装目录下的riscv/bin添加到环境变量。查看版本证明安装成功。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">riscv64-unknown-elf-gdb --version
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意：&lt;/p>
&lt;p>从&lt;a class="link" href="https://static.dev.sifive.com/dev-tools/freedom-tools/v2020.08/riscv64-unknown-elf-gcc-10.1.0-2020.08.2-x86_64-linux-ubuntu14.tar.gz" target="_blank" rel="noopener"
>https://static.dev.sifive.com/dev-tools/freedom-tools/v2020.08/riscv64-unknown-elf-gcc-10.1.0-2020.08.2-x86_64-linux-ubuntu14.tar.gz&lt;/a>下载的预编译工具不好，没有TUI界面。&lt;/p>
&lt;p>要把riscv/bin目录添加到环境变量，而不是riscv&lt;/p>
&lt;p>其实解压出来也就是安装了，只是要把用到的二进制文件添加到PATH以便使用&lt;/p></description></item></channel></rss>
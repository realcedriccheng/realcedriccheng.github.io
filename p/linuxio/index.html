<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="https://arthurchiao.art/blog/intro-to-io-uring-zh/\n• How io_uring and eBPF Will Revolutionize Programming in Linux, ScyllaDB, 2020 • An Introduction to the io_uring Asynchronous I/O Framework, Oracle, 2020\nio_uring 是 2019 年 Linux 5.1 内核首次引入的高性能异步 I/O 框架，能显著加速 I/O 密集型应用的性能。 但如果你的应用已经在使用 传统 Linux AIO 了，并且使用方式恰当，那 io_uring并不会带来太大的性能提升 —— 根据原文测试（以及我们自己的复现），即便打开高级特性，也只有 5%。除非你真的需要这 5% 的额外性能，否则切换成 io_uring代价可能也挺大，因为要重写应用来适配 io_uring（或者让依赖的平台或框架去适配，总之需要改代码）。\n"><title>Linux IO 系统调用专题</title><link rel=canonical href=https://realcedriccheng.github.io/p/linuxio/><link rel=stylesheet href=/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css><meta property='og:title' content="Linux IO 系统调用专题"><meta property='og:description' content="https://arthurchiao.art/blog/intro-to-io-uring-zh/\n• How io_uring and eBPF Will Revolutionize Programming in Linux, ScyllaDB, 2020 • An Introduction to the io_uring Asynchronous I/O Framework, Oracle, 2020\nio_uring 是 2019 年 Linux 5.1 内核首次引入的高性能异步 I/O 框架，能显著加速 I/O 密集型应用的性能。 但如果你的应用已经在使用 传统 Linux AIO 了，并且使用方式恰当，那 io_uring并不会带来太大的性能提升 —— 根据原文测试（以及我们自己的复现），即便打开高级特性，也只有 5%。除非你真的需要这 5% 的额外性能，否则切换成 io_uring代价可能也挺大，因为要重写应用来适配 io_uring（或者让依赖的平台或框架去适配，总之需要改代码）。\n"><meta property='og:url' content='https://realcedriccheng.github.io/p/linuxio/'><meta property='og:site_name' content='The Orange Flavored Whisper'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Linux'><meta property='article:tag' content='IO路径'><meta property='article:published_time' content='2025-04-07T00:00:00+00:00'><meta property='article:modified_time' content='2025-04-07T00:00:00+00:00'><meta name=twitter:title content="Linux IO 系统调用专题"><meta name=twitter:description content="https://arthurchiao.art/blog/intro-to-io-uring-zh/\n• How io_uring and eBPF Will Revolutionize Programming in Linux, ScyllaDB, 2020 • An Introduction to the io_uring Asynchronous I/O Framework, Oracle, 2020\nio_uring 是 2019 年 Linux 5.1 内核首次引入的高性能异步 I/O 框架，能显著加速 I/O 密集型应用的性能。 但如果你的应用已经在使用 传统 Linux AIO 了，并且使用方式恰当，那 io_uring并不会带来太大的性能提升 —— 根据原文测试（以及我们自己的复现），即便打开高级特性，也只有 5%。除非你真的需要这 5% 的额外性能，否则切换成 io_uring代价可能也挺大，因为要重写应用来适配 io_uring（或者让依赖的平台或框架去适配，总之需要改代码）。\n"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_5b3a75c4f0fbbc6c.jfif width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍊</span></figure><div class=site-meta><h1 class=site-name><a href=/>The Orange Flavored Whisper</a></h1><h2 class=site-description>on tech notes</h2></div></header><ol class=menu-social><li><a href=https://github.com/realcedriccheng/ target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/cu/><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-lemon"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M17.536 3.393c3.905 3.906 3.905 10.237.0 14.143-3.906 3.905-10.237 3.905-14.143.0L17.536 3.393"/><path d="M5.868 15.06a6.5 6.5.0 009.193-9.192"/><path d="M10.464 10.464l4.597 4.597"/><path d="M10.464 10.464v6.364"/><path d="M10.464 10.464h6.364"/></svg>
<span>Cedric Update</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/>面试经验
</a><a href=/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/>理论知识</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/linuxio/>Linux IO 系统调用专题</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 07, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>9 minute read</time></div></footer></div></header><section class=article-content><p><a class=link href=https://arthurchiao.art/blog/intro-to-io-uring-zh/ target=_blank rel=noopener>https://arthurchiao.art/blog/intro-to-io-uring-zh/</a></p><p>• How io_uring and eBPF Will Revolutionize Programming in Linux, ScyllaDB, 2020
• An Introduction to the io_uring Asynchronous I/O Framework, Oracle, 2020</p><p>io_uring 是 2019 年 Linux 5.1 内核首次引入的高性能异步 I/O 框架，能显著加速 I/O 密集型应用的性能。
但如果你的应用已经在使用 传统 Linux AIO 了，并且使用方式恰当，那 io_uring并不会带来太大的性能提升 —— 根据原文测试（以及我们自己的复现），即便打开高级特性，也只有 5%。除非你真的需要这 5% 的额外性能，否则切换成 io_uring代价可能也挺大，因为要重写应用来适配 io_uring（或者让依赖的平台或框架去适配，总之需要改代码）。</p><p>既然性能跟传统 AIO 差不多，那为什么还称 io_uring 为革命性技术呢？</p><ol><li><p>它首先和最大的贡献在于：统一了 Linux 异步 I/O 框架，
◦ Linux AIO 只支持 direct I/O 模式的存储文件（storage file），而且主要用在数据库这一细分领域；
◦ io_uring 支持存储文件和网络文件（network sockets），也支持更多的异步系统调用
（accept/openat/stat/&mldr;），而非仅限于 read/write 系统调用。</p></li><li><p>在设计上是真正的异步 I/O，作为对比，Linux AIO 虽然也是异步的，但仍然可能会阻塞，某些情况下的行为也无法预测；</p></li></ol><p>似乎之前 Windows 在这块反而是领先的，更多参考：
◦ 浅析开源项目之 io_uring，“分步试存储”专栏，知乎
◦ Is there really no asynchronous block I/O on Linux?，stackoverflow</p><ol start=3><li><p>灵活性和可扩展性非常好，甚至能基于 io_uring 重写所有系统调用，而 Linux AIO 设计时就没考虑扩展性。
eBPF 也算是异步框架（事件驱动），但与 io_uring 没有本质联系，二者属于不同子系统，并且在模型上有一个本质区别：eBPF 对用户是透明的，只需升级内核（到合适的版本），应用程序无需任何改造；</p></li><li><p>io_uring 提供了新的系统调用和用户空间 API，因此需要应用程序做改造。
eBPF 作为动态跟踪工具，能够更方便地排查和观测 io_uring 等模块在执行层面的具体问题。</p></li></ol><p>本文介绍 Linux 异步 I/O 的发展历史，io_uring 的原理和功能，并给出了一些程序示例和性能压测结果（我们在 5.10内核做了类似测试，结论与原文差不多）。</p><p>很多人可能还没意识到，Linux 内核在过去几年已经发生了一场革命。这场革命源于两个激动人心的新接口的引入：eBPF 和 io_uring。</p><p>我们认为，二者将会完全改变应用与内核交互的方式，以及应用开发者思考和看待内核的方式。</p><p>本文介绍 io_uring（我们在 ScyllaDB 中有 io_uring 的深入使用经验），并略微提及一下 eBPF。</p><p>1 Linux I/O 系统调用演进</p><p>1.1 基于 fd 的阻塞式 I/O：read()/write()</p><p>作为大家最熟悉的读写方式，Linux 内核提供了基于文件描述符的系统调用，这些描述符指向的可能是存储文件（storage file），也可能是 network sockets：
ssize_t read(int fd,void* buf,size_t count);
ssize_t write(int fd,const void* buf,size_t count);二者称为阻塞式系统调用（blocking system calls），因为程序调用这些函数时会进入 sleep 状态，然后被调度出去（让出处理器），直到 I/O 操作完成：
• 如果数据在文件中，并且文件内容已经缓存在 page cache 中，调用会立即返回；
• 如果数据在另一台机器上，就需要通过网络（例如 TCP）获取，会阻塞一段时间；
• 如果数据在硬盘上，也会阻塞一段时间。
但很容易想到，随着存储设备越来越快，程序越来越复杂，阻塞式（blocking）已经这种最简单的方式已经不适用了。</p><p>1.2 非阻塞式 I/O：select()/poll()/epoll()
阻塞式之后，出现了一些新的、非阻塞的系统调用，例如 select()、poll() 以及更新的 epoll()。</p><p>应用程序在调用这些函数读写时不会阻塞，而是立即返回，返回的是一个已经 ready 的文件描述符列表。</p><p>但这种方式存在一个致命缺点：只支持 network sockets 和 pipes ——epoll() 甚至连 storage files 都不支持。</p><p>1.3 线程池方式
对于 storage I/O，经典的解决思路是 thread pool：主线程将 I/O 分发给 worker 线程，后者代替主线程进行阻塞式读写，主线程不会阻塞。</p><p>这种方式的问题是线程上下文切换开销可能非常大，后面性能压测会看到。</p><p>1.4 Direct I/O（数据库软件）：绕过 page cache
随后出现了更加灵活和强大的方式：数据库软件（database software）有时 并不想使用操作系统的 page cache，而是希望打开一个文件后，直接从设备读写这个文件（direct access to the device）。这种方式称为直接访问（direct access）或直接 I/O（direct I/O），</p><p>• 需要指定 O_DIRECT flag；
• 需要应用自己管理自己的缓存 —— 这正是数据库软件所希望的；
• 是 zero-copy I/O，因为应用的缓冲数据直接发送到设备，或者直接从设备读取。</p><p>1.5 异步 IO（AIO）
前面提到，随着存储设备越来越快，主线程和 worker 线性之间的上下文切换开销占比越来越高。</p><p>现在市场上的一些设备，例如 Intel Optane，延迟已经低到和上下文切换一个量级（微秒 us）。换个方式描述，更能让我们感受到这种开销：上下文每切换一次，我们就少一次 dispatch I/O 的机会。</p><p>因此，Linux 2.6 内核引入了异步 I/O（asynchronous I/O）接口，</p><p>方便起见，本文简写为 linux-aio。AIO 原理是很简单的：</p><p>• 用户通过 io_submit() 提交 I/O 请求，</p><p>• 过一会再调用 io_getevents() 来检查哪些 events 已经 ready 了。</p><p>• 使程序员能编写完全异步的代码。</p><p>近期，Linux AIO 甚至支持了epoll()：也就是说不仅能提交 storage I/O 请求，还能提交网络 I/O 请求。照这样发展下去，linux-aio似乎能成为一个王者。但由于它糟糕的演进之路，这个愿望几乎不可能实现了。</p><p>Linux AIO 确实问题缠身，</p><ol><li><p>只支持 O_DIRECT 文件，因此对常规的非数据库应用 （normal, non-database applications）几乎是无用的；</p></li><li><p>接口在设计时并未考虑扩展性。虽然可以扩展 —— 我们也确实这么做了 —— 但每加一个东西都相当复杂；</p></li><li><p>虽然从技术上说接口是非阻塞的，但实际上有 很多可能的原因都会导致它阻塞，而且引发的方式难以预料。</p></li></ol><p>1.6 小结</p><p>以上可以清晰地看出 Linux I/O 的演进：</p><p>• 最开始是同步（阻塞式）系统调用；</p><p>• 然后随着实际需求和具体场景，不断加入新的异步接口，还要保持与老接口的兼容和协同工作。</p><p>另外也看到，在非阻塞式读写的问题上并没有形成统一方案：</p><ol><li><p>Network socket 领域：添加一个异步接口，然后去轮询（poll）请求是否完成（readiness）；</p></li><li><p>Storage I/O 领域：只针对某一细分领域（数据库）在某一特定时期的需求，添加了一个定制版的异步接口。</p></li></ol><p>这就是 Linux I/O 的演进历史 —— 只着眼当前，出现一个问题就引入一种设计，而并没有多少前瞻性 —— 直到 io_uring 的出现。</p><p>2 io_uring</p><p>io_uring 来自资深内核开发者 Jens Axboe 的想法，他在 Linux I/O stack 领域颇有研究。</p><p>从最早的 patch aio: support for IO polling可以看出，这项工作始于一个很简单的观察：随着设备越来越快，中断驱动（interrupt-driven）模式效率已经低于轮询模式（polling for completions） —— 这也是高性能领域最常见的主题之一。</p><p>• io_uring 的基本逻辑与 linux-aio 是类似的：提供两个接口，一个将I/O 请求提交到内核，一个从内核接收完成事件。</p><p>• 但随着开发深入，它逐渐变成了一个完全不同的接口：设计者开始从源头思考如何支持完全异步的操作。</p><p>2.1 与 Linux AIO 的不同</p><p>io_uring 与 linux-aio 有着本质的不同：</p><ol><li><p>在设计上是真正异步的（truly asynchronous）。只要设置了合适的 flag，它在系统调用上下文中就只是将请求放入队列，不会做其他任何额外的事情，保证了应用永远不会阻塞。</p></li><li><p>支持任何类型的 I/O：cached files、direct-access files 甚至 blocking sockets。</p></li></ol><p>由于设计上就是异步的（async-by-design nature），因此无需 poll+read/write 来处理 sockets。</p><p>只需提交一个阻塞式读（blocking read），请求完成之后，就会出现在 completion ring。</p><ol start=3><li>灵活、可扩展：基于 io_uring 甚至能重写（re-implement）Linux 的每个系统调用。</li></ol><p>2.2 原理及核心数据结构：SQ/CQ/SQE/CQE</p><p>每个 io_uring 实例都有两个环形队列（ring），在内核和应用程序之间共享：</p><p>• 提交队列：submission queue (SQ)</p><p>• 完成队列：completion queue (CQ)</p><p>这两个队列：</p><p>• 都是单生产者、单消费者，size 是 2 的幂次；</p><p>• 提供无锁接口（lock-less access interface），内部使用内存屏障做同步（coordinated with memory barriers）。</p><p>使用方式：</p><p>• 请求</p><pre><code>◦ 应用创建 SQ entries (SQE)，更新 SQ tail；

◦ 内核消费 SQE，更新 SQ head。
</code></pre><p>• 完成</p><pre><code>◦ 内核为完成的一个或多个请求创建 CQ entries (CQE)，更新 CQ tail；

◦ 应用消费 CQE，更新 CQ head。

◦ 完成事件（completion events）可能以任意顺序到达，到总是与特定的 SQE 相关联的。

◦ 消费 CQE 过程无需切换到内核态。
</code></pre><p>2.3 带来的好处</p><p>io_uring 这种请求方式还有一个好处是：原来需要多次系统调用（读或写），现在变成批处理一次提交。</p><p>还记得 Meltdown 漏洞吗？当时我还写了一篇文章解释为什么我们的 Scylla NoSQL 数据库受影响很小：aio 已经将我们的 I/O 系统调用批处理化了。</p><p>io_uring将这种批处理能力带给了 storage I/O 系统调用之外的其他一些系统调用，包括：</p><p>• read</p><p>• write</p><p>• send</p><p>• recv</p><p>• accept</p><p>• openat</p><p>• stat</p><p>• 专用的一些系统调用，例如 fallocate</p><p>此外，io_uring 使异步 I/O 的使用场景也不再仅限于数据库应用，普通的非数据库应用也能用。这一点值得重复一遍：</p><p>虽然 io_uring 与 aio 有一些相似之处，但它的扩展性和架构是革命性的：</p><p>它将异步操作的强大能力带给了所有应用（及其开发者），而不再仅限于是数据库应用这一细分领域。</p><p>我们的 CTO Avi Kivity 在 the Core C++ 2019 event 上 有一次关于 async 的分享。</p><p>核心点包括：从延迟上来说，</p><ol><li><p>现代多核、多 CPU 设备，其内部本身就是一个基础网络；</p></li><li><p>CPU 之间是另一个网络；</p></li><li><p>CPU 和磁盘 I/O 之间又是一个网络。</p></li></ol><p>因此网络编程采用异步是明智的，而现在开发自己的应用也应该考虑异步。</p><p>这从根本上改变了 Linux 应用的设计方式：</p><p>• 之前都是一段顺序代码流，需要系统调用时才执行系统调用，</p><p>• 现在需要思考一个文件是否 ready，因而自然地引入 event-loop，不断通过共享 buffer 提交请求和接收结果。</p><p>2.4 三种工作模式</p><p>io_uring 实例可工作在三种模式：</p><ol><li>中断驱动模式（interrupt driven）</li></ol><p>默认模式。可通过 io_uring_enter() 提交 I/O 请求，然后直接检查 CQ 状态判断是否完成。</p><ol start=2><li>轮询模式（polled）</li></ol><p>Busy-waiting for an I/O completion，而不是通过异步 IRQ（Interrupt Request）接收通知。</p><p>这种模式需要文件系统（如果有）和块设备（block device）支持轮询功能。</p><p>相比中断驱动方式，这种方式延迟更低（连系统调用都省了）， 但可能会消耗更多 CPU 资源。</p><p>目前，只有指定了 O_DIRECT flag 打开的文件描述符，才能使用这种模式。当一个读或写请求提交给轮询上下文（polled context）之后，应用（application）必须调用 io_uring_enter() 来轮询 CQ 队列，判断请求是否已经完成。</p><p>对一个 io_uring 实例来说，不支持混合使用轮询和非轮询模式。</p><ol start=3><li>内核轮询模式（kernel polled）</li></ol><p>这种模式中，会 创建一个内核线程（kernel thread）来执行 SQ 的轮询工作。</p><p>使用这种模式的 io_uring 实例， 应用无需切到到内核态 就能触发（issue）I/O 操作。</p><p>通过 SQ 来提交 SQE，以及监控 CQ 的完成状态，应用无需任何系统调用，就能提交和收割 I/O（submit and reap I/Os）。</p><p>如果内核线程的空闲时间超过了用户的配置值，它会通知应用，然后进入 idle 状态。</p><p>这种情况下，应用必须调用 io_uring_enter() 来唤醒内核线程。如果 I/O 一直很繁忙，内核线性是不会 sleep 的。</p><p>后面略</p></section><footer class=article-footer><section class=article-tags><a href=/tags/linux/>Linux</a>
<a href=/tags/io%E8%B7%AF%E5%BE%84/>IO路径</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Apr 07, 2025 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/cpplilunzhishi/><div class=article-details><h2 class=article-title>C++理论知识</h2></div></a></article><article><a href=/p/caozuoxitong/><div class=article-details><h2 class=article-title>操作系统理论知识</h2></div></a></article><article><a href=/p/mianjingzongjie/><div class=article-details><h2 class=article-title>面经总结</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=realcedriccheng/utterances issue-term=pathname label=✨💬✨ crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2024 -
2025 The Orange Flavored Whisper</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>